diff --git a/Mono.Profiler/Mono.Profiler.Widgets/Makefile.am b/Mono.Profiler/Mono.Profiler.Widgets/Makefile.am
index 7b91e6b..f0bf1ec 100644
--- a/Mono.Profiler/Mono.Profiler.Widgets/Makefile.am
+++ b/Mono.Profiler/Mono.Profiler.Widgets/Makefile.am
@@ -9,7 +9,8 @@ CSFLAGS =  -noconfig -codepage:utf8 -warn:4
 ASSEMBLY_MDB = 
 endif
 
-pkglib_DATA = $(ASSEMBLY) $(ASSEMBLY_MDB)
+programfilesdir = $(pkglibdir)
+programfiles_DATA = $(ASSEMBLY) $(ASSEMBLY_MDB)
 
 CLEANFILES = $(ASSEMBLY) $(ASSEMBLY_MDB)
 
diff --git a/Mono.Profiler/heap-snapshot-explorer/Makefile.am b/Mono.Profiler/heap-snapshot-explorer/Makefile.am
index 2bb2401..a9f34a3 100644
--- a/Mono.Profiler/heap-snapshot-explorer/Makefile.am
+++ b/Mono.Profiler/heap-snapshot-explorer/Makefile.am
@@ -9,7 +9,8 @@ CSFLAGS =  -noconfig -codepage:utf8 -warn:4 -optimize+
 ASSEMBLY_MDB = 
 endif
 
-pkglib_DATA = $(ASSEMBLY) $(ASSEMBLY_MDB)
+programfilesdir = $(pkglibdir)
+programfiles_DATA = $(ASSEMBLY) $(ASSEMBLY_MDB)
 
 CLEANFILES = $(ASSEMBLY) $(ASSEMBLY_MDB)
 
diff --git a/Mono.Profiler/heap-snapshot-viewer/Makefile.am b/Mono.Profiler/heap-snapshot-viewer/Makefile.am
index 3b488be..f7b0888 100644
--- a/Mono.Profiler/heap-snapshot-viewer/Makefile.am
+++ b/Mono.Profiler/heap-snapshot-viewer/Makefile.am
@@ -8,7 +8,8 @@ CSFLAGS =  -noconfig -codepage:utf8 -warn:4 -optimize+
 ASSEMBLY_MDB = 
 endif
 
-pkglib_DATA = $(ASSEMBLY) $(ASSEMBLY_MDB)
+programfilesdir = $(pkglibdir)
+programfiles_DATA = $(ASSEMBLY) $(ASSEMBLY_MDB)
 bin_SCRIPTS = mprof-heap-viewer
 man_MANS=man/man1/mprof-heap-viewer.1
 
diff --git a/Mono.Profiler/mprof-gui/Makefile.am b/Mono.Profiler/mprof-gui/Makefile.am
index 5b00ea9..0369c2c 100644
--- a/Mono.Profiler/mprof-gui/Makefile.am
+++ b/Mono.Profiler/mprof-gui/Makefile.am
@@ -8,7 +8,8 @@ CSFLAGS =  -noconfig -codepage:utf8 -warn:4
 ASSEMBLY_MDB = 
 endif
 
-pkglib_DATA = $(ASSEMBLY) $(ASSEMBLY_MDB)
+programfilesdir = $(pkglibdir)
+programfiles_DATA = $(ASSEMBLY) $(ASSEMBLY_MDB)
 bin_SCRIPTS = emveepee
 
 CLEANFILES = $(ASSEMBLY) $(ASSEMBLY_MDB)
diff --git a/Mono.Profiler/profiler-decoder-library/Makefile.am b/Mono.Profiler/profiler-decoder-library/Makefile.am
index 115f1a7..71d49ac 100644
--- a/Mono.Profiler/profiler-decoder-library/Makefile.am
+++ b/Mono.Profiler/profiler-decoder-library/Makefile.am
@@ -9,7 +9,8 @@ CSFLAGS =  -noconfig -codepage:utf8 -warn:4 -optimize+
 ASSEMBLY_MDB = 
 endif
 
-pkglib_DATA = $(ASSEMBLY) $(ASSEMBLY_MDB)
+programfilesdir = $(pkglibdir)
+programfiles_DATA = $(ASSEMBLY) $(ASSEMBLY_MDB)
 
 CLEANFILES = $(ASSEMBLY) $(ASSEMBLY_MDB)
 
diff --git a/Mono.Profiler/profiler-file-decoder/Makefile.am b/Mono.Profiler/profiler-file-decoder/Makefile.am
index 285267f..2365dc7 100644
--- a/Mono.Profiler/profiler-file-decoder/Makefile.am
+++ b/Mono.Profiler/profiler-file-decoder/Makefile.am
@@ -9,7 +9,8 @@ CSFLAGS = -noconfig -codepage:utf8 -warn:4 -optimize+
 ASSEMBLY_MDB = 
 endif
 
-pkglib_DATA = $(ASSEMBLY) $(ASSEMBLY_MDB)
+programfilesdir = $(pkglibdir)
+programfiles_DATA = $(ASSEMBLY) $(ASSEMBLY_MDB)
 bin_SCRIPTS = mprof-decoder
 man_MANS = man/man1/mprof-decoder.1 
 
diff --git a/README b/README
index 3ad3752..a01a518 100644
--- a/README
+++ b/README
@@ -23,3 +23,12 @@ automatically executed):
     make
     make install
 
+Building on OSX with homebrew:
+------------------------------
+
+Have the following packages installed:
+autoconf pkg-config	readline automake gettext glib intltool libtool
+
+Run autogen like this:
+PKG_CONFIG_PATH=/Library/Frameworks/Mono.framework/Versions/Current/lib/pkgconfig/ ./autogen.sh 
+
diff --git a/configure.in b/configure.in
index 2a8870f..4771a2e 100644
--- a/configure.in
+++ b/configure.in
@@ -1,4 +1,4 @@
-AC_INIT([mono-tools], [2.10])
+AC_INIT([mono-tools], [2.11])
 AC_CONFIG_SRCDIR([README])
 AC_CANONICAL_SYSTEM
 AM_INIT_AUTOMAKE([tar-ustar -Wno-portability])
@@ -272,6 +272,7 @@ gendarme/swf-wizard-runner/Makefile
 gendarme/tools/Makefile
 gendarme/tools/supported/Makefile
 gendarme/tools/supported/gd2i/Makefile
+gendarme/tools/supported/templates/Makefile
 gendarme/tools/unsupported/Makefile
 gendarme/tools/unsupported/mapper/Makefile
 gendarme/tools/unsupported/typeref/Makefile
diff --git a/docbrowser/Makefile.am b/docbrowser/Makefile.am
index a1a2626..065c430 100644
--- a/docbrowser/Makefile.am
+++ b/docbrowser/Makefile.am
@@ -40,6 +40,7 @@ browser_sources   = \
 	$(srcdir)/list.cs 		\
 	$(srcdir)/elabel.cs 		\
 	$(srcdir)/history.cs 		\
+	$(srcdir)/editing.cs            \
 	$(srcdir)/Contributions.cs	\
 	$(srcdir)/XmlNodeWriter.cs	\
 	$(srcdir)/IHtmlRender.cs	\
@@ -67,7 +68,7 @@ admin_sources = \
 	$(srcdir)/admin.cs		\
 	$(srcdir)/Contributions.cs
 
-browser_assemblies = $(GTK_SHARP_LIBS) $(MONODOC_LIBS) $(GNOME_SHARP_LIBS) -r:System.Web.Services
+browser_assemblies = $(GTK_SHARP_LIBS) $(MONODOC_LIBS) $(GNOME_SHARP_LIBS) -r:System.Web.Services -r:System.Web
 # we insert gtkhtml libs if we have them for printing 
 geckorender_assemblies = $(GTK_SHARP_LIBS) $(GTKHTML_SHARP_LIBS) $(GECKO_SHARP_LIBS) $(GNOME_SHARP_LIBS) $(MONODOC_LIBS) -r:browser.exe
 gtkhtmlrender_assemblies = $(GTK_SHARP_LIBS) $(GTKHTML_SHARP_LIBS) $(GNOME_SHARP_LIBS) $(MONODOC_LIBS) -r:browser.exe
diff --git a/docbrowser/browser.cs b/docbrowser/browser.cs
index 5cc85e2..b9eb66f 100644
--- a/docbrowser/browser.cs
+++ b/docbrowser/browser.cs
@@ -60,7 +60,7 @@ class Driver {
 				v => sources.Add (v) },
 			{ "edit=",
 				"Edit mdoc(5) XML documentation found within {PATH}.",
-				v => RootTree.UncompiledHelpSources.Add (v) },
+				v => RootTree.AddUncompiledSource (v) },
 			{ "engine=",
 				"Specify which HTML rendering {ENGINE} to use:\n" + 
 					"  " + string.Join ("\n  ", engines) + "\n" +
@@ -119,6 +119,9 @@ class Driver {
 
 		List<string> topics = p.Parse (args);
 
+		if (basedir == null)
+			basedir = Directory.GetParent (System.Reflection.Assembly.GetExecutingAssembly ().Location).FullName;
+
 		if (show_version) {
 			Console.WriteLine ("Mono Documentation Browser");
 			Version ver = Assembly.GetExecutingAssembly ().GetName ().Version;
@@ -132,7 +135,7 @@ class Driver {
 			return r;
 		}
 
-		if (mergeConfigFile != null) {
+		/*if (mergeConfigFile != null) {
 			ArrayList targetDirs = new ArrayList ();
 			
 			for (int i = 0; i < topics.Count; i++)
@@ -145,7 +148,7 @@ class Driver {
 
 			e.Merge ();
 			return 0;
-		}
+		}*/
 		
 		if (r != 0 || !show_gui)
 			return r;
@@ -257,6 +260,7 @@ public class Browser {
 	TreeView search_tree;
 	TreeStore search_store;
 	SearchableIndex search_index;
+	ArrayList searchResults = new ArrayList (20);
 	string highlight_text;
 	[Glade.Widget] VBox search_vbox;
 	ProgressPanel ppanel;
@@ -578,6 +582,7 @@ public class Browser {
 		Result r = search_index.Search (term);
 		if (r == null)
 			return; //There was a problem with the index
+		searchResults.Add (r);
 		//insert the results in the tree
 		TreeIter iter;
 					
@@ -622,7 +627,7 @@ public class Browser {
 			return;
 		int i_0 = p.Indices [0];
 		int i_1 = p.Indices [1];
-		Result res = (Result) search_index.Results [i_0];
+		Result res = (Result) searchResults [i_0];
 		TreeIter parent;
 		model.IterParent (out parent, iter);
 		string term = (string) search_store.GetValue (parent, 0);
@@ -648,21 +653,21 @@ public class Browser {
 	void TextLarger (object obj, EventArgs args)
 	{
 		SettingsHandler.Settings.preferred_font_size += 10;
-		HelpSource.CssCode = null;
+		//HelpSource.CssCode = null;
 		Reload ();
 		SettingsHandler.Save ();
 	}
 	void TextSmaller (object obj, EventArgs args)
 	{
 		SettingsHandler.Settings.preferred_font_size -= 10;
-		HelpSource.CssCode = null;
+		//HelpSource.CssCode = null;
 		Reload ();
 		SettingsHandler.Save ();
 	}
 	void TextNormal (object obj, EventArgs args)
 	{
 		SettingsHandler.Settings.preferred_font_size = 100;
-		HelpSource.CssCode = null;
+		//HelpSource.CssCode = null;
 		Reload ();
 		SettingsHandler.Save ();
 	}
@@ -733,6 +738,15 @@ public class Browser {
 		
 		Node node;
 		
+		/*
+		 * The webkit library converts the url titles (N:, T:, etc.) to lower case (n:, t:, etc.)
+		 * when clicking on a link. Therefore we need to convert them to upper case, since the
+		 * monodoc backend only understands upper case titles (except for root:, afaik).
+		 */
+		string[] urlParts = url.Split (':');
+		if (urlParts [0].Length == 1)
+			url = urlParts [0].ToUpper () + url.Substring (1);
+			
 		Console.Error.WriteLine ("Trying: {0}", url);
 		try {
 			string res = Browser.GetHtml (url, null, help_tree, out node);
@@ -785,8 +799,8 @@ public class Browser {
 			//
 			string tabTitle;
 			tabTitle = matched_node.Caption; //Normal title
-			string[] parts = matched_node.URL.Split('/', '#');
-			if(matched_node.URL != null && matched_node.URL.StartsWith("ecma:")) {
+			string[] parts = matched_node.PublicUrl.Split('/', '#');
+			if(matched_node.PublicUrl != null && matched_node.PublicUrl.StartsWith("ecma:")) {
 				if(parts.Length == 3 && parts[2] != String.Empty) { //List of Members, properties, events, ...
 					tabTitle = parts[1] + ": " + matched_node.Caption;
 				} else if(parts.Length >= 4) { //Showing a concrete Member, property, ...					
@@ -937,6 +951,7 @@ ExtLoop:
 	void delete_event_cb (object o, DeleteEventArgs args)
 	{
 		Application.Quit ();
+		args.RetVal = true;
 	}
 	void on_print_activate (object sender, EventArgs e) 
 	{
@@ -1691,7 +1706,7 @@ ExtLoop:
 
 		void OnOkClicked (object sender, EventArgs a)
 		{
-			CommentService service = new CommentService();
+			//CommentService service = new CommentService();
 			// todo
 			newcomment.Hide ();
 		}
@@ -2010,7 +2025,7 @@ public class TreeBrowser {
 		if (tree_view.Selection.GetSelected (out model, out iter)){
 			Node n = (Node) iter_to_node [iter];
 			
-			string url = n.URL;
+			string url = n.PublicUrl;
 			Node match;
 			string s;
 
@@ -2038,7 +2053,7 @@ public class TreeBrowser {
 				return;
 			}
 
-			((Browser)browser).Render ("<h1>Unhandled URL</h1>" + "<p>Functionality to view the resource <i>" + n.URL + "</i> is not available on your system or has not yet been implemented.</p>", null, url);
+			((Browser)browser).Render ("<h1>Unhandled URL</h1>" + "<p>Functionality to view the resource <i>" + n.PublicUrl + "</i> is not available on your system or has not yet been implemented.</p>", null, url);
 		}
 	}
 }
@@ -2702,7 +2717,7 @@ public class Tab : Notebook {
 		string [] uSplit = EditingUtils.ParseEditUrl (edit_url);
 		
 		if (uSplit[0].StartsWith ("monodoc:"))
-			EditingUtils.SaveChange (edit_url, browser.help_tree, edit_node, EcmaHelpSource.GetNiceUrl (browser.CurrentTab.CurrentNode));
+			EditingUtils.SaveChange (edit_url, browser.help_tree, edit_node, GetNiceUrl (browser.CurrentTab.CurrentNode));
 		else if (uSplit[0].StartsWith ("file:"))
 			EditingUtils.SaveChange (edit_url, browser.help_tree, edit_node, String.Empty);
 		else
@@ -2711,6 +2726,49 @@ public class Tab : Notebook {
 		history.ActivateCurrent ();
 	}
 
+	public static string GetNiceUrl (Node node) {
+		if (node.Element.StartsWith("N:"))
+			return node.Element;
+		string name, full;
+		int bk_pos = node.Caption.IndexOf (' ');
+		// node from an overview
+		if (bk_pos != -1) {
+			name = node.Caption.Substring (0, bk_pos);
+			full = node.Parent.Caption + "." + name.Replace ('.', '+');
+			return "T:" + full;
+		}
+		// node that lists constructors, methods, fields, ...
+		if ((node.Caption == "Constructors") || (node.Caption == "Fields") || (node.Caption == "Events") 
+			|| (node.Caption == "Members") || (node.Caption == "Properties") || (node.Caption == "Methods")
+			|| (node.Caption == "Operators")) {
+			bk_pos = node.Parent.Caption.IndexOf (' ');
+			name = node.Parent.Caption.Substring (0, bk_pos);
+			full = node.Parent.Parent.Caption + "." + name.Replace ('.', '+');
+			return "T:" + full + "/" + node.Element; 
+		}
+		int pr_pos = node.Caption.IndexOf ('(');
+		// node from a constructor
+		if (node.Parent.Element == "C") {
+			name = node.Parent.Parent.Parent.Caption;
+			int idx = node.PublicUrl.IndexOf ('/');
+			return node.PublicUrl[idx+1] + ":" + name + "." + node.Caption.Replace ('.', '+');
+		// node from a method with one signature, field, property, operator
+		} else if (pr_pos == -1) {
+			bk_pos = node.Parent.Parent.Caption.IndexOf (' ');
+			name = node.Parent.Parent.Caption.Substring (0, bk_pos);
+			full = node.Parent.Parent.Parent.Caption + "." + name.Replace ('.', '+');
+			int idx = node.PublicUrl.IndexOf ('/');
+			return node.PublicUrl[idx+1] + ":" + full + "." + node.Caption;
+		// node from a method with several signatures
+		} else {
+			bk_pos = node.Parent.Parent.Parent.Caption.IndexOf (' ');
+			name = node.Parent.Parent.Parent.Caption.Substring (0, bk_pos);
+			full = node.Parent.Parent.Parent.Parent.Caption + "." + name.Replace ('.', '+');
+			int idx = node.PublicUrl.IndexOf ('/');
+			return node.PublicUrl[idx+1] + ":" + full + "." + node.Caption;
+		}
+	}
+
 	void OnCancelEdits (object sender, EventArgs a)
 	{
 		SetMode (Mode.Viewer);
@@ -2737,6 +2795,7 @@ public class Tab : Notebook {
 			
 			StringWriter sw = new StringWriter ();
 			XmlWriter w = new XmlTextWriter (sw);
+			var converter = new Monodoc.Generators.Html.Ecma2Html ();
 			
 			try {
 				edit_node.InnerXml = text_editor.Buffer.Text;
@@ -2750,7 +2809,7 @@ public class Tab : Notebook {
 			}
 			browser.statusbar.Pop (browser.context_id);
 			browser.statusbar.Push (browser.context_id, "XML OK");
-			string s = HelpSource.BuildHtml (EcmaHelpSource.css_ecma_code, sw.ToString ());
+			string s = converter.Export (sw.ToString (), new Dictionary<string, string> ());
 			html_preview.Render(s);
 
 			return false;
diff --git a/docbrowser/editing.cs b/docbrowser/editing.cs
new file mode 100644
index 0000000..d7c1e32
--- /dev/null
+++ b/docbrowser/editing.cs
@@ -0,0 +1,519 @@
+//
+// editing.cs
+//
+// Author:
+//   Ben Maurer (bmaurer@users.sourceforge.net)
+//
+// (C) 2003 Ben Maurer
+//
+
+using System;
+using System.Collections;
+using System.Collections.Specialized;
+using System.IO;
+using System.Text;
+using System.Xml;
+using System.Xml.Serialization;
+using System.Xml.XPath;
+using System.Web;
+
+namespace Monodoc {
+	public class EditingUtils {
+		
+		public static string FormatEditUri (string document_identifier, string xpath)
+		{
+			return String.Format ("edit:{0}@{1}", HttpUtility.UrlEncode (document_identifier),
+				HttpUtility.UrlEncode (xpath));
+		}
+		
+		public static string GetXPath (XPathNavigator n)
+		{
+			switch (n.NodeType) {
+				case XPathNodeType.Root: return "/";
+				case XPathNodeType.Attribute: {
+					string ret = "@" + n.Name;
+					n.MoveToParent ();
+					string s = GetXPath (n);
+					return s + (s == "/" ? "" : "/") + ret;
+				}
+
+				case XPathNodeType.Element: {
+					string ret = n.Name;
+					int i = 1;
+					while (n.MoveToPrevious ()) {
+						if (n.NodeType == XPathNodeType.Element && n.Name == ret)
+							i++;
+					}
+					ret += "[" + i + "]";
+					if (n.MoveToParent ()) {
+						string s = GetXPath (n);
+						return s + (s == "/" ? "" : "/") + ret;
+					}
+				}
+				break;
+			}
+			throw new Exception ("node type not supported for editing");
+			
+		}
+		
+		public static XmlNode GetNodeFromUrl (string url, RootTree tree)
+		{
+			Console.WriteLine ("Url is: {0}", url);
+			string [] uSplit = ParseEditUrl (url);
+			Console.WriteLine ("Results are: {0}\n{1}\n{2}", uSplit [0], uSplit [1], uSplit [2]);
+			
+			string xp = uSplit [2];
+			string id =  uSplit [1];
+			
+			XmlDocument d;
+			
+			if (uSplit[0].StartsWith("monodoc:///")) {
+				int prov = int.Parse (uSplit [0].Substring("monodoc:///".Length));
+				d = tree.GetHelpSourceFromId (prov).GetHelpXmlWithChanges (id);
+			} else if (uSplit[0].StartsWith("file:")) {
+				d = new XmlDocument();
+				d.PreserveWhitespace = true;
+				d.Load(uSplit[0].Substring(5));
+			} else {
+				throw new NotImplementedException("Don't know how to load " + url); 
+			}			
+			
+			return d.SelectSingleNode (xp);
+				
+		}
+		
+		public static void SaveChange (string url, RootTree tree, XmlNode node, string node_url)
+		{
+			/*string [] uSplit = ParseEditUrl (url);
+		
+			string xp = uSplit [2];
+			string id =  uSplit [1];
+						
+			if (uSplit[0].StartsWith("monodoc:///")) {
+				int prov = int.Parse (uSplit [0].Substring("monodoc:///".Length));
+				HelpSource hs = tree.GetHelpSourceFromId (prov);
+				
+				changes.AddChange (hs.Name, hs.GetRealPath (id), xp, node, node_url);
+				changes.Save ();
+			} else if (uSplit[0].StartsWith("file:")) {
+				uSplit[0] = uSplit[0].Substring(5);
+				
+				XmlDocument d = new XmlDocument();
+				d.PreserveWhitespace = true;
+				d.Load(uSplit[0]);
+				
+				XmlNode original = d.SelectSingleNode(xp);
+				original.ParentNode.ReplaceChild(d.ImportNode(node, true), original);
+				
+				d.Save(uSplit[0]);
+			} else {				
+				throw new NotImplementedException("Don't know how to save to " + url); 
+			}*/
+		}
+
+		public static void RemoveChange (string url, RootTree tree)
+		{
+			/*string [] uSplit = ParseEditUrl (url);
+		
+			string xp = uSplit [2];
+			string id = uSplit [1];
+						
+			if (uSplit[0].StartsWith("monodoc:///")) {
+				int prov = int.Parse (uSplit [0].Substring("monodoc:///".Length));
+				HelpSource hs = tree.GetHelpSourceFromId (prov);
+				
+				changes.RemoveChange (hs.Name, hs.GetRealPath (id), xp);
+				changes.Save ();
+			} else if (uSplit[0].StartsWith("file:")) {
+				//TODO: Not implemented
+			}*/
+		}
+		
+		public static void RenderEditPreview (string url, RootTree tree, XmlNode new_node, XmlWriter w)
+		{
+			string [] uSplit = ParseEditUrl (url);
+		
+			if (uSplit[0].StartsWith("monodoc:///")) {
+				int prov = int.Parse (uSplit [0].Substring("monodoc:///".Length));
+				HelpSource hs = tree.GetHelpSourceFromId (prov);
+				hs.RenderPreviewDocs (new_node, w);
+			} else {
+				foreach (HelpSource hs in tree.HelpSources) {
+					if (hs is Monodoc.Providers.EcmaUncompiledHelpSource) {
+						// It doesn't matter which EcmaHelpSource is chosen.
+						hs.RenderPreviewDocs (new_node, w);
+						break;
+					}
+				}				
+			}
+		}
+		
+		public static string [] ParseEditUrl (string url)
+		{
+			if (!url.StartsWith ("edit:"))
+				throw new Exception ("wtf");
+			
+			string [] parts = url.Split ('@');
+			if (parts.Length != 2)
+				throw new Exception (String.Format ("invalid editing url {0}", parts.Length));
+			
+			string xp = HttpUtility.UrlDecode (parts [1]);
+			parts = HttpUtility.UrlDecode (parts [0]).Substring ("edit:".Length).Split ('@');
+			if (parts.Length == 1) {
+				string p = parts[0];
+				parts = new string[2];
+				parts[0] = p;
+				parts[1] = "";
+			}
+			
+			return new string [] {parts [0], parts [1], xp};
+		}
+		
+		public static void AccountForChanges (XmlDocument d, string doc_set, string real_file)
+		{
+			try {
+				FileChangeset fcs = changes.GetChangeset (doc_set, real_file);
+				if (fcs == null)
+					return;
+				
+				foreach (Change c in fcs.Changes) {
+					// Filter out old changes
+					if (c.FromVersion != RootTree.MonodocVersion)
+						continue;
+					
+					XmlNode old = d.SelectSingleNode (c.XPath);
+					if (old != null)
+						old.ParentNode.ReplaceChild (d.ImportNode (c.NewNode, true), old);
+				}
+			} catch {
+				return;
+			}
+		}
+	
+		public static GlobalChangeset changes = GlobalChangeset.Load ();
+
+		static public GlobalChangeset GetChangesFrom (int starting_serial_id)
+		{
+			return changes.GetFrom (starting_serial_id);
+		}
+	}
+
+#region Data Model
+	public class GlobalChangeset {
+
+		public static XmlSerializer serializer = new XmlSerializer (typeof (GlobalChangeset));
+		static string changeset_file = Path.Combine (SettingsHandler.Path, "changeset.xml");
+		static string changeset_backup_file = Path.Combine (SettingsHandler.Path, "changeset.xml~");
+	
+		public static GlobalChangeset Load ()
+		{
+			try {
+				if (File.Exists (changeset_file))
+					return LoadFromFile (changeset_file);
+			} catch {}
+			
+			return new GlobalChangeset ();
+		}
+		
+		public static GlobalChangeset LoadFromFile (string fileName)
+		{
+			using (Stream s = File.OpenRead (fileName)) {
+				return (GlobalChangeset) serializer.Deserialize (s);
+			}
+		}			
+		
+		public void Save ()
+		{
+			SettingsHandler.EnsureSettingsDirectory ();
+
+			try {    
+				if (File.Exists(changeset_file))  // create backup copy
+					File.Copy (changeset_file, changeset_backup_file, true);
+           
+				using (FileStream fs = File.Create (changeset_file)){
+					serializer.Serialize (fs, this);
+				}
+			} catch (Exception e) {
+				Console.WriteLine ("Error while saving changes. " + e);
+				if (File.Exists(changeset_backup_file))  // if saving fails then use backup if we have one				
+					File.Copy (changeset_backup_file, changeset_file, true);
+				else
+					File.Delete (changeset_file);   // if no backup, delete invalid changeset 
+			}
+		}
+		
+		static void VerifyDirectoryExists (DirectoryInfo d) {
+			if (d.Exists)
+				return;
+
+			VerifyDirectoryExists (d.Parent);
+			d.Create ();
+		}
+
+		[XmlElement ("DocSetChangeset", typeof (DocSetChangeset))]
+		public ArrayList DocSetChangesets = new ArrayList ();
+
+		public FileChangeset GetChangeset (string doc_set, string real_file)
+		{
+			foreach (DocSetChangeset dscs in DocSetChangesets) {
+				if (dscs.DocSet != doc_set) 
+					continue;
+			
+				foreach (FileChangeset fcs in dscs.FileChangesets) {
+					if (fcs.RealFile == real_file)
+						return fcs;
+				}
+			}
+			
+			return null;
+		}
+
+		public int Count {
+			get {
+				int count = 0;
+				
+				foreach (DocSetChangeset dscs in DocSetChangesets){
+					foreach (FileChangeset fcs in dscs.FileChangesets){
+						count += fcs.Changes.Count;
+					}
+				}
+
+				return count;
+			}
+		}
+
+		Change NewChange (string xpath, XmlNode new_node, string node_url)
+		{
+			Change new_change = new Change ();
+			new_change.XPath = xpath;
+			new_change.NewNode = new_node;
+			new_change.NodeUrl = node_url;
+
+			Console.WriteLine ("New serial:" + SettingsHandler.Settings.SerialNumber);
+			new_change.Serial = SettingsHandler.Settings.SerialNumber;
+
+			return new_change;
+		}
+		
+		public void AddChange (string doc_set, string real_file, string xpath, XmlNode new_node, string node_url)
+		{
+			FileChangeset new_file_change_set;
+			Change new_change = NewChange (xpath, new_node, node_url);
+			
+			if (real_file == null)
+				throw new Exception ("Could not find real_file. Please talk to Miguel or Ben about this");
+			
+			foreach (DocSetChangeset dscs in DocSetChangesets) {
+				if (dscs.DocSet != doc_set) 
+					continue;
+
+				foreach (FileChangeset fcs in dscs.FileChangesets) {
+					if (fcs.RealFile != real_file)
+						continue;
+					
+					foreach (Change c in fcs.Changes) {
+						if (c.XPath == xpath) {
+							c.NewNode = new_node;
+							c.Serial = SettingsHandler.Settings.SerialNumber;
+							return;
+						}
+					}
+
+					fcs.Changes.Add (new_change);
+					return;
+					
+				}
+				
+				new_file_change_set = new FileChangeset ();
+				new_file_change_set.RealFile = real_file;
+				new_file_change_set.Changes.Add (new_change);
+				dscs.FileChangesets.Add (new_file_change_set);
+				return;
+					
+			}
+			
+			DocSetChangeset new_dcs = new DocSetChangeset ();
+			new_dcs.DocSet = doc_set;
+			
+			new_file_change_set = new FileChangeset ();
+			new_file_change_set.RealFile = real_file;
+			
+			new_file_change_set.Changes.Add (new_change);
+			new_dcs.FileChangesets.Add (new_file_change_set);
+			DocSetChangesets.Add (new_dcs);
+		}
+
+		public void RemoveChange (string doc_set, string real_file, string xpath)
+		{
+			if (real_file == null)
+				throw new Exception ("Could not find real_file. Please talk to Miguel or Ben about this");
+			
+			for (int i = 0; i < DocSetChangesets.Count; i++) {
+				DocSetChangeset dscs = DocSetChangesets [i] as DocSetChangeset;
+				if (dscs.DocSet != doc_set) 
+					continue;
+
+				for (int j = 0; j < dscs.FileChangesets.Count; j++) {
+					FileChangeset fcs = dscs.FileChangesets [j] as FileChangeset;
+					if (fcs.RealFile != real_file)
+						continue;
+
+					for (int k = 0; k < fcs.Changes.Count; k++) {
+						Change c = fcs.Changes [k] as Change;
+						if (c.XPath == xpath) {
+							fcs.Changes.Remove (c);
+							break;
+						}
+					}
+					if (fcs.Changes.Count == 0)
+						dscs.FileChangesets.Remove (fcs);
+				}
+
+				if (dscs.FileChangesets.Count == 0)
+					DocSetChangesets.Remove (dscs);
+			}
+		}
+
+		public GlobalChangeset GetFrom (int starting_serial_id)
+		{
+			GlobalChangeset s = null;
+			
+			foreach (DocSetChangeset dscs in DocSetChangesets){
+				object o = dscs.GetFrom (starting_serial_id);
+				if (o == null)
+					continue;
+				if (s == null)
+					s = new GlobalChangeset ();
+				s.DocSetChangesets.Add (o);
+			}
+			return s;
+		}
+	}
+	
+	public class DocSetChangeset {
+		[XmlAttribute] public string DocSet;
+		
+		[XmlElement ("FileChangeset", typeof (FileChangeset))]
+		public ArrayList FileChangesets = new ArrayList ();
+
+		public DocSetChangeset GetFrom (int starting_serial_id)
+		{
+			DocSetChangeset dsc = null;
+			
+			foreach (FileChangeset fcs in FileChangesets){
+				object o = fcs.GetFrom (starting_serial_id);
+				if (o == null)
+					continue;
+				if (dsc == null){
+					dsc = new DocSetChangeset ();
+					dsc.DocSet = DocSet;
+				}
+				dsc.FileChangesets.Add (o);
+			}
+			return dsc;
+		}
+	}
+	
+	public class FileChangeset {
+		[XmlAttribute] public string RealFile;
+		
+		[XmlElement ("Change", typeof (Change))]
+		public ArrayList Changes = new ArrayList ();
+
+		public FileChangeset GetFrom (int starting_serial_id)
+		{
+			FileChangeset fcs = null;
+
+			foreach (Change c in Changes){
+				if (c.Serial < starting_serial_id)
+					continue;
+				if (fcs == null){
+					fcs = new FileChangeset ();
+					fcs.RealFile = RealFile;
+				}
+				fcs.Changes.Add (c);
+			}
+			return fcs;
+		}
+	}
+	
+	public class Change {
+		[XmlAttribute] public string XPath;
+		[XmlAttribute] public int FromVersion = RootTree.MonodocVersion;
+		[XmlAttribute] public string NodeUrl;
+		
+		public XmlNode NewNode;
+
+		public int Serial;
+
+		bool applied = false;
+		
+		//
+		// These are not a property, because we dont want them serialized;
+		// Only used by the Admin Client.
+		//
+		public bool Applied ()
+		{
+			return applied;
+		}
+
+		public void SetApplied (bool value)
+		{
+			applied = value;
+		}
+	}
+#endregion
+	
+	public class EditMerger {
+		GlobalChangeset changeset;
+		ArrayList targetDirs;
+		
+		public EditMerger (GlobalChangeset changeset, ArrayList targetDirs)
+		{
+			this.changeset = changeset;
+			this.targetDirs = targetDirs;
+		}
+		
+		public void Merge ()
+		{
+			foreach (DocSetChangeset dsc in changeset.DocSetChangesets) {
+				bool merged = false;
+				foreach (string path in targetDirs) {
+					if (File.Exists (Path.Combine (path, dsc.DocSet + ".source"))) {
+						Merge (dsc, path);
+						merged = true;
+						break;
+					}
+				}
+				if (!merged) Console.WriteLine ("Could not merge docset {0}", dsc.DocSet);
+			}
+		}
+		
+		void Merge (DocSetChangeset dsc, string path)
+		{
+			Console.WriteLine ("Merging changes in {0} ({1})", dsc.DocSet, path);
+			
+			foreach (FileChangeset fcs in dsc.FileChangesets) {
+				if (File.Exists (Path.Combine (path, fcs.RealFile)))
+					Merge (fcs, path);
+				else
+					Console.WriteLine ("\tCould not find file {0}", Path.Combine (path, fcs.RealFile));
+			}
+		}
+		
+		void Merge (FileChangeset fcs, string path)
+		{
+			XmlDocument d = new XmlDocument ();
+			d.Load (Path.Combine (path, fcs.RealFile));
+			
+			foreach (Change c in fcs.Changes) {
+				XmlNode old = d.SelectSingleNode (c.XPath);
+				if (old != null)
+					old.ParentNode.ReplaceChild (d.ImportNode (c.NewNode, true), old);
+			}
+			
+			d.Save (Path.Combine (path, fcs.RealFile));
+		}
+	}
+}
+
diff --git a/docbrowser/monodoc.in b/docbrowser/monodoc.in
index a532918..806b163 100644
--- a/docbrowser/monodoc.in
+++ b/docbrowser/monodoc.in
@@ -75,7 +75,7 @@ elif test x@MOZILLA_HOME@ != x; then
     if [ -f @MOZILLA_HOME@/chrome/comm.jar ]; then
         MOZILLA_HOME=@MOZILLA_HOME@
     fi 
-elif grep GRE_PATH /etc/gre.d/*.conf > /dev/null ; then
+elif grep -qs GRE_PATH /etc/gre.d/*.conf > /dev/null ; then
 	MOZILLA_HOME=$(grep -h GRE_PATH= /etc/gre.d/*.conf | cut -d '"' -f 2 -d = | head -n 1)
 elif [ $(which xulrunner 2> /dev/null) ] > /dev/null ; then
     MOZILLA_FIVE_HOME=`getdirectory xulrunner`
diff --git a/gendarme/AssemblyStaticInfo.cs b/gendarme/AssemblyStaticInfo.cs
index 2ca215e..130eb9d 100644
--- a/gendarme/AssemblyStaticInfo.cs
+++ b/gendarme/AssemblyStaticInfo.cs
@@ -18,10 +18,9 @@ using System.Security.Permissions;
 [assembly: AssemblyCopyright ("Copyright (C) 2005-2011 Novell, Inc. and contributors")]
 [assembly: AssemblyCompany ("Novell, Inc.")]
 
-[assembly: PermissionSet (SecurityAction.RequestMinimum, Unrestricted = true)]
 [assembly: CLSCompliant (false)]
 [assembly: ComVisible (false)]
 
 #if RELEASE
-[assembly: AssemblyVersion ("2.10.0.0")]
+[assembly: AssemblyVersion ("2.11.0.0")]
 #endif
diff --git a/gendarme/MIT.X11 b/gendarme/MIT.X11
index 8d90e9d..b3e59de 100644
--- a/gendarme/MIT.X11
+++ b/gendarme/MIT.X11
@@ -1,4 +1,4 @@
-Copyright (c) 2005-2010 Novell, Inc and the individuals listed on the 
+Copyright (c) 2005-2011 Novell, Inc and the individuals listed on the 
 ChangeLog entries.
 
 Permission is hereby granted, free of charge, to any person obtaining
diff --git a/gendarme/Makefile.am b/gendarme/Makefile.am
index 890f0f2..2d96376 100644
--- a/gendarme/Makefile.am
+++ b/gendarme/Makefile.am
@@ -45,7 +45,8 @@ check-test: all bin/gendarme.exe.config test
 		--ignore=unit-test.ignore --severity=all --confidence=all @unit-test.list
 
 test-regress: all
-	mono --debug bin/gendarme.exe --config rules/rules.xml --set self-test --log regress.log testcases/*.dll testcases/*.exe
+	mono --debug bin/gendarme.exe --config rules/rules.xml --set self-test --log regress.log \
+		--severity=all --confidence=all testcases/*.dll testcases/*.exe
 	
 TEST1 ?= AvoidVisibleConstantFieldTest
 test1_file = $(shell find rules -name "\.svn" -prune -o  -name "*$(TEST1)*" -print)
@@ -101,16 +102,3 @@ zip-bin: bin extra-bin
 	cd ..; \
 	rm -rf gendarme.$(GENDARME_VERSION);
 
-instruct.xsd:
-	wget http://www.ohloh.net/instruct.xsd
-
-push: instruct.xsd
-	xmllint --schema instruct.xsd gendarme.xml
-#	scp gendarme-2.8preview1-bin.zip $(USER)@upload.ohloh.net:gendarme/files; \
-#	scp gendarme-2.8preview1-win32-setup.zip $(USER)@upload.ohloh.net:gendarme/files; \
-#	scp gendarme.xml $(USER)@upload.ohloh.net:gendarme/instructs
-
-pull-log:
-	scp $(USER)@upload.ohloh.net:gendarme/logs/upload.log .
-	cat upload.log
-
diff --git a/gendarme/console/ConsoleRunner.cs b/gendarme/console/ConsoleRunner.cs
index 97afccb..bf9814c 100644
--- a/gendarme/console/ConsoleRunner.cs
+++ b/gendarme/console/ConsoleRunner.cs
@@ -29,6 +29,7 @@
 using System;
 using System.Collections.Generic;
 using System.Diagnostics;
+using System.Globalization;
 using System.IO;
 using System.Linq;
 using System.Reflection;
@@ -53,21 +54,23 @@ namespace Gendarme {
 		private string log_file;
 		private string xml_file;
 		private string ignore_file;
-		private string limit;
-		private string severity_filter;
-		private string confidence_filter;
 		private bool help;
 		private bool quiet;
 		private bool version;
+		private bool console;
 		private List<string> assembly_names;
 
+		static string [] SplitOptions (string value)
+		{
+			return value.ToUpperInvariant ().Split (new char [] { ',' }, StringSplitOptions.RemoveEmptyEntries);
+		}
+
 		// parse severity filter
 		// e.g. Audit,High+ == Audit, High and Critical
-		void ParseSeverity ()
+		bool ParseSeverity (string filter)
 		{
 			SeverityBitmask.ClearAll ();
-			string [] options = severity_filter.ToUpperInvariant ().Split (',');
-			foreach (string option in options) {
+			foreach (string option in SplitOptions (filter)) {
 				Severity severity;
 
 				switch (option) {
@@ -101,28 +104,26 @@ namespace Gendarme {
 					SeverityBitmask.SetAll ();
 					continue;
 				default:
-					continue;
+					string msg = String.Format (CultureInfo.CurrentCulture, "Unknown severity level '{0}'", option);
+					throw new OptionException (msg, "severity");
 				}
 
 				char end = option [option.Length - 1];
 				if (end == '+') {
 					SeverityBitmask.SetDown (severity);
-					Console.WriteLine ("SetDown {0} -> {1}", severity, SeverityBitmask);
 				} else if (end == '-') {
 					SeverityBitmask.SetUp (severity);
-					Console.WriteLine ("SetUp {0} -> {1}", severity, SeverityBitmask);
 				} else {
 					SeverityBitmask.Set (severity);
-					Console.WriteLine ("Set {0} -> {1}", severity, SeverityBitmask);
 				}
 			}
+			return true;
 		}
 
-		void ParseConfidence ()
+		bool ParseConfidence (string filter)
 		{
 			ConfidenceBitmask.ClearAll ();
-			string [] options = confidence_filter.ToUpperInvariant ().Split (',');
-			foreach (string option in options) {
+			foreach (string option in SplitOptions (filter)) {
 				Confidence confidence;
 
 				switch (option) {
@@ -151,7 +152,8 @@ namespace Gendarme {
 					ConfidenceBitmask.SetAll ();
 					continue;
 				default:
-					continue;
+					string msg = String.Format (CultureInfo.CurrentCulture, "Unknown confidence level '{0}'", option);
+					throw new OptionException (msg, "confidence");
 				}
 
 				char end = option [option.Length - 1];
@@ -163,48 +165,104 @@ namespace Gendarme {
 					ConfidenceBitmask.Set (confidence);
 				}
 			}
+			return true;
+		}
+
+		static string ValidateInputFile (string option, string file)
+		{
+			if (!File.Exists (file)) {
+				string msg = String.Format (CultureInfo.CurrentCulture, "File '{0}' could not be found", file);
+				throw new OptionException (msg, option);
+			}
+			return file;
+		}
+
+		static string ValidateOutputFile (string option, string file)
+		{
+			string msg = String.Empty;
+			if (file.Length > 0) {
+				string path = Path.GetDirectoryName (file);
+				if (path.Length > 0) {
+					if (path.IndexOfAny (Path.GetInvalidPathChars ()) != -1)
+						msg = String.Format (CultureInfo.CurrentCulture, "Invalid path '{0}'", file);
+					else if (!Directory.Exists (path))
+						msg = String.Format (CultureInfo.CurrentCulture, "Path '{0}' does not exists", file);
+				}
+			}
+
+			string fname = Path.GetFileName (file);
+			if ((fname.Length == 0) || (fname.IndexOfAny (Path.GetInvalidFileNameChars ()) != -1)) {
+				msg = String.Format (CultureInfo.CurrentCulture, "Filename '{0}' is not valid", fname);
+			}
+
+			if (msg.Length > 0)
+				throw new OptionException (msg, option);
+
+			return file;
+		}
+
+		static string ValidateRuleSet (string ruleSet)
+		{
+			if (String.IsNullOrEmpty (ruleSet)) {
+				throw new OptionException ("Missing rule set name", "set");
+			}
+			return ruleSet;
+		}
+
+		static int ValidateLimit (string limit)
+		{
+			int defects_limit;
+			if (String.IsNullOrEmpty (limit) || !Int32.TryParse (limit, out defects_limit)) {
+				string msg = String.Format (CultureInfo.CurrentCulture, "Invalid value '{0}' to limit defects", limit);
+				throw new OptionException (msg, "limit");
+			}
+			return defects_limit;
 		}
 
 		byte Parse (string [] args)
 		{
+			bool severity = false;
+			bool confidence = false;
+			// if supplied, use the user limit on defects (otherwise 2^31 is used)
+			DefectsLimit = Int32.MaxValue;
+
 			var p = new OptionSet () {
-				{ "config=",	v => config_file = v },
-				{ "set=",	v => rule_set = v },
-				{ "log=",	v => log_file = v },
-				{ "xml=",	v => xml_file = v },
-				{ "html=",	v => html_file = v },
-				{ "ignore=",	v => ignore_file = v },
-				{ "limit=",	v => limit = v },
-				{ "severity=",	v => severity_filter = v },
-				{ "confidence=",v => confidence_filter = v },
+				{ "config=",	v => config_file = ValidateInputFile ("config", v) },
+				{ "set=",	v => rule_set = ValidateRuleSet (v) },
+				{ "log=",	v => log_file = ValidateOutputFile ("log", v) },
+				{ "xml=",	v => xml_file = ValidateOutputFile ("xml", v) },
+				{ "html=",	v => html_file = ValidateOutputFile ("html", v) },
+				{ "ignore=",	v => ignore_file = ValidateInputFile ("ignore", v) },
+				{ "limit=",	v => DefectsLimit = ValidateLimit (v) },
+				{ "severity=",	v => severity = ParseSeverity (v) },
+				{ "confidence=",v => confidence = ParseConfidence (v) },
 				{ "v|verbose",  v => ++VerbosityLevel },
+				{ "console",	v => console = v != null },
 				{ "quiet",	v => quiet = v != null },
 				{ "version",	v => version = v != null },
 				{ "h|?|help",	v => help = v != null },
 			};
-			assembly_names = p.Parse (args);
 
-			// if supplied, use the user limit on defects (otherwise 2^31 is used)
-			int defects_limit;
-			if (String.IsNullOrEmpty (limit) || !Int32.TryParse (limit, out defects_limit))
-				defects_limit = Int32.MaxValue;
-			DefectsLimit = defects_limit;
+			try {
+				assembly_names = p.Parse (args);
+			}
+			catch (OptionException e) {
+				Console.WriteLine ("Error parsing option '{0}' : {1}", e.OptionName, e.Message);
+				Console.WriteLine ();
+				return 1;
+			}
 
 			// by default the runner will ignore Audit and Low severity defects
-			if (String.IsNullOrEmpty (severity_filter)) {
+			if (!severity) {
 				SeverityBitmask.SetAll ();
 				SeverityBitmask.Clear (Severity.Audit);
 				SeverityBitmask.Clear (Severity.Low);
-			} else {
-				ParseSeverity ();
 			}
 
 			// by default the runner will ignore Low confidence defects
-			if (String.IsNullOrEmpty (confidence_filter)) {
+			if (!confidence) {
 				ConfidenceBitmask.SetAll ();
 				ConfidenceBitmask.Clear (Confidence.Low);
-			} else {
-				ParseConfidence ();
 			}
 
 			return (byte) ((assembly_names.Count > 0) ? 0 : 1);
@@ -281,7 +339,7 @@ namespace Gendarme {
 			}
 
 			// generate text report (default, to console, if xml and html aren't specified)
-			if ((log_file != null) || ((xml_file == null) && (html_file == null))) {
+			if (console || (log_file != null) || ((xml_file == null) && (html_file == null))) {
 				using (TextResultWriter writer = new TextResultWriter (this, log_file)) {
 					writer.Report ();
 				}
@@ -380,7 +438,7 @@ namespace Gendarme {
 		private static string TimeToString (TimeSpan time)
 		{
 			if (time >= TimeSpan.FromMilliseconds (100))
-				return string.Format ("{0:0.0} seconds", time.TotalSeconds);
+				return String.Format (CultureInfo.CurrentCulture, "{0:0.0} seconds", time.TotalSeconds);
 			else
 				return "<0.1 seconds";
 		}
@@ -441,9 +499,10 @@ namespace Gendarme {
 				if (null != log_file || null != xml_file || null != html_file) {
 					List<string> files = new List<string> (new string [] { log_file, xml_file, html_file });
 					files.RemoveAll (string.IsNullOrEmpty);
-					hint = string.Format ("Report{0} written to: {1}.",
+					hint = String.Format (CultureInfo.CurrentCulture, "Report{0} written to: {1}.",
 						(files.Count > 1) ? "s" : string.Empty,
-						string.Join (",", files.Select (file => string.Format ("`{0}'", file)).ToArray ()));
+						string.Join (",", files.Select (file => 
+							String.Format (CultureInfo.CurrentCulture, "`{0}'", file)).ToArray ()));
 				}
 
 				if (Defects.Count == 0)
@@ -519,6 +578,7 @@ namespace Gendarme {
 			Console.WriteLine ("  --confidence [all | [[low | normal | high | total][+|-]],...");
 			Console.WriteLine ("\t\t\tFilter defects for the specified confidence levels.");
 			Console.WriteLine ("\t\t\tDefault is 'normal+'");
+			Console.WriteLine ("  --console\t\tShow defects on the console even if --log, --xml or --html are specified.");
 			Console.WriteLine ("  --quiet\t\tUsed to disable progress and other information which is normally written to stdout.");
 			Console.WriteLine ("  --v\t\t\tWhen present additional progress information is written to stdout (can be used multiple times).");
 			Console.WriteLine ("  assemblies\t\tSpecify the assemblies to verify.");
diff --git a/gendarme/console/Helpers.cs b/gendarme/console/Helpers.cs
index c399452..3ef8361 100644
--- a/gendarme/console/Helpers.cs
+++ b/gendarme/console/Helpers.cs
@@ -38,7 +38,7 @@ namespace Gendarme {
 		{
 			Assembly executing = Assembly.GetExecutingAssembly ();
 			foreach (string resource in executing.GetManifestResourceNames ()) {
-				if (resource.EndsWith (resourceName))
+				if (resource.EndsWith (resourceName, StringComparison.Ordinal))
 					return executing.GetManifestResourceStream (resource);
 			}
 			return null;
diff --git a/gendarme/console/IgnoreFileList.cs b/gendarme/console/IgnoreFileList.cs
index acf0d1d..b714ded 100644
--- a/gendarme/console/IgnoreFileList.cs
+++ b/gendarme/console/IgnoreFileList.cs
@@ -61,13 +61,13 @@ namespace Gendarme {
 
 		private void Parse ()
 		{
+			char [] buffer = new char [4096];
 			while (files.Count > 0) {
 				string fileName = files.Pop ();
-				using (StreamReader sr = new StreamReader (fileName)) {
-					string s = sr.ReadLine ();
-					while (s != null) {
-						ProcessLine (s);
-						s = sr.ReadLine ();
+				using (StreamLineReader sr = new StreamLineReader (fileName)) {
+					while (!sr.EndOfStream) {
+						int length = sr.ReadLine (buffer, 0, buffer.Length);
+						ProcessLine (buffer, length);
 					}
 				}
 			}
@@ -87,19 +87,33 @@ namespace Gendarme {
 			rules.Add (rule);
 		}
 
-		private void ProcessLine (string line)
+		static string GetString (char [] buffer, int length)
 		{
-			if (line.Length < 1)
+			// skip the 'type' + ':' characters when looking for whitespace separator(s)
+			int start = 2;
+			while (Char.IsWhiteSpace (buffer [start]) && (start < buffer.Length))
+				start++;
+
+			int end = length;
+			while (Char.IsWhiteSpace (buffer [end]) && (end >= start))
+				end--;
+
+			return new string (buffer, start, end - start);
+		}
+
+		private void ProcessLine (char [] buffer, int length)
+		{
+			if (length < 1)
 				return;
 
-			switch (line [0]) {
+			switch (buffer [0]) {
 			case '#': // comment
 				break;
 			case 'R': // rule
-				current_rule = line.Substring (line.LastIndexOf (' ') + 1);
+				current_rule = GetString (buffer, length);
 				break;
 			case 'A': // assembly - we support Name, FullName and *
-				string target = line.Substring (2).Trim ();
+				string target = GetString (buffer, length);
 				if (target == "*") {
 					foreach (AssemblyDefinition assembly in Runner.Assemblies) {
 						Add (assemblies, current_rule, assembly.Name.FullName);
@@ -109,19 +123,19 @@ namespace Gendarme {
 				}
 				break;
 			case 'T': // type (no space allowed)
-				Add (types, current_rule, line.Substring (line.LastIndexOf (' ') + 1));
+				Add (types, current_rule, GetString (buffer, length));
 				break;
 			case 'M': // method
-				Add (methods, current_rule, line.Substring (2).Trim ());
+				Add (methods, current_rule, GetString (buffer, length));
 				break;
 			case 'N': // namespace - special case (no need to resolve)
-				base.Add (current_rule, NamespaceDefinition.GetDefinition (line.Substring (2).Trim ()));
+				base.Add (current_rule, NamespaceDefinition.GetDefinition (GetString (buffer, length)));
 				break;
 			case '@': // include file
-				files.Push (line.Substring (2).Trim ());
+				files.Push (GetString (buffer, length));
 				break;
 			default:
-				Console.Error.WriteLine ("Bad ignore entry : '{0}'", line);
+				Console.Error.WriteLine ("Bad ignore entry : '{0}'", new string (buffer));
 				break;
 			}
 		}
@@ -148,14 +162,13 @@ namespace Gendarme {
 
 				foreach (ModuleDefinition module in assembly.Modules) {
 					foreach (TypeDefinition type in module.GetAllTypes ()) {
-						if (types.TryGetValue (type.FullName, out rules)) {
+						if (types.TryGetValue (type.GetFullName (), out rules)) {
 							AddList (type, rules);
 						}
 
 						if (type.HasMethods) {
 							foreach (MethodDefinition method in type.Methods) {
-								// FIXME avoid (allocations in) ToString call
-								if (methods.TryGetValue (method.ToString (), out rules)) {
+								if (methods.TryGetValue (method.GetFullName (), out rules)) {
 									AddList (method, rules);
 								}
 							}
diff --git a/gendarme/console/Makefile.am b/gendarme/console/Makefile.am
index f74ab23..43c0a4a 100644
--- a/gendarme/console/Makefile.am
+++ b/gendarme/console/Makefile.am
@@ -30,7 +30,7 @@ gendarme_prefix_resources = $(addprefix $(srcdir)/, $(gendarme_resources))
 gendarme_build_resources = $(foreach res,$(gendarme_prefix_resources), $(addprefix -resource:,$(res)),$(notdir $(res)))
 
 ../bin/gendarme.exe: $(gendarme_build_sources) $(gendarme_prefix_resources)
-	$(GMCS) $(GENDARME_OPTIONS) -r:$(CECIL_ASM) -r:System.Xml.Linq -r:../bin/Gendarme.Framework.dll \
+	$(MCS) $(GENDARME_OPTIONS) -r:$(CECIL_ASM) -r:System.Xml.Linq -r:../bin/Gendarme.Framework.dll \
 		-out:$@ $(gendarme_build_sources) $(gendarme_build_resources)
 
 self-test: ../bin/gendarme.exe
diff --git a/gendarme/console/Settings.cs b/gendarme/console/Settings.cs
index 3ecafec..23b5429 100644
--- a/gendarme/console/Settings.cs
+++ b/gendarme/console/Settings.cs
@@ -4,7 +4,7 @@
 // Authors:
 //	Sebastien Pouliot <sebastien@ximian.com>
 //
-// Copyright (C) 2008 Novell, Inc (http://www.novell.com)
+// Copyright (C) 2008, 2011 Novell, Inc (http://www.novell.com)
 //
 // Permission is hereby granted, free of charge, to any person obtaining
 // a copy of this software and associated documentation files (the
@@ -27,6 +27,7 @@
 //
 
 using System;
+using System.Globalization;
 using System.IO;
 using System.Reflection;
 using System.Collections.Generic;
@@ -150,7 +151,8 @@ namespace Gendarme {
 
 		private void OnValidationErrors (object sender, ValidationEventArgs args)
 		{
-			validation_errors.Add (args.Exception.Message.Replace ("XmlSchema error", String.Format ("Error in the configuration file {0}", config_file)));
+			validation_errors.Add (args.Exception.Message.Replace ("XmlSchema error", 
+				String.Format (CultureInfo.CurrentCulture, "Error in the configuration file {0}", config_file)));
 		}
 
 		private void ValidateXmlDocument ()
@@ -228,7 +230,8 @@ namespace Gendarme {
 
 		static Exception GetException (string message, string ruleName, string propertyName, string value)
 		{
-			return new XmlException (String.Format (message + ".  Review your configuration file.", ruleName, propertyName, value));
+			return new XmlException (String.Format (CultureInfo.CurrentCulture, 
+				message + ".  Review your configuration file.", ruleName, propertyName, value));
 		}
 
 		public bool Load ()
diff --git a/gendarme/console/XmlResultWriter.cs b/gendarme/console/XmlResultWriter.cs
index 3a5e0f4..3dcdff1 100644
--- a/gendarme/console/XmlResultWriter.cs
+++ b/gendarme/console/XmlResultWriter.cs
@@ -31,6 +31,7 @@
 //
 
 using System;
+using System.Globalization;
 using System.IO;
 using System.Linq;
 using System.Text;
@@ -70,7 +71,7 @@ namespace Gendarme {
 		{
 			writer.WriteStartDocument ();
 			writer.WriteStartElement ("gendarme-output");
-			writer.WriteAttributeString ("date", DateTime.UtcNow.ToString ());
+			writer.WriteAttributeString ("date", DateTime.UtcNow.ToString (CultureInfo.InvariantCulture));
 		}
 
 		protected override void Write ()
diff --git a/gendarme/console/gendarme.csproj b/gendarme/console/gendarme.csproj
index 4f70bf5..eefae5e 100755
--- a/gendarme/console/gendarme.csproj
+++ b/gendarme/console/gendarme.csproj
@@ -1,5 +1,5 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
-<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="3.5">
+<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="4.0">
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
     <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
@@ -12,9 +12,13 @@
     <AssemblyName>gendarme</AssemblyName>
     <FileUpgradeFlags>
     </FileUpgradeFlags>
-    <OldToolsVersion>2.0</OldToolsVersion>
+    <OldToolsVersion>3.5</OldToolsVersion>
     <UpgradeBackupLocation>
     </UpgradeBackupLocation>
+    <IsWebBootstrapper>true</IsWebBootstrapper>
+    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
+    <SignAssembly>false</SignAssembly>
+    <AssemblyOriginatorKeyFile>gendarme.snk</AssemblyOriginatorKeyFile>
     <PublishUrl>http://localhost/gendarme/</PublishUrl>
     <Install>true</Install>
     <InstallFrom>Web</InstallFrom>
@@ -27,12 +31,9 @@
     <MapFileExtensions>true</MapFileExtensions>
     <ApplicationRevision>0</ApplicationRevision>
     <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
-    <IsWebBootstrapper>true</IsWebBootstrapper>
     <UseApplicationTrust>false</UseApplicationTrust>
     <BootstrapperEnabled>true</BootstrapperEnabled>
-    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
-    <SignAssembly>false</SignAssembly>
-    <AssemblyOriginatorKeyFile>gendarme.snk</AssemblyOriginatorKeyFile>
+    <TargetFrameworkProfile />
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
     <DebugSymbols>true</DebugSymbols>
@@ -42,6 +43,7 @@
     <DefineConstants>TRACE;DEBUG</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
     <DebugType>pdbonly</DebugType>
@@ -50,6 +52,7 @@
     <DefineConstants>TRACE;RELEASE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <ItemGroup>
     <Reference Include="System" />
@@ -88,6 +91,10 @@
       <Project>{CD6818D5-B398-486C-B180-92A07B143AFD}</Project>
       <Name>Gendarme.Framework</Name>
     </ProjectReference>
+    <ProjectReference Include="..\..\..\cecil\symbols\mdb\Mono.Cecil.Mdb.csproj">
+      <Project>{8559DD7F-A16F-46D0-A05A-9139FAEBA8FD}</Project>
+      <Name>Mono.Cecil.Mdb</Name>
+    </ProjectReference>
   </ItemGroup>
   <ItemGroup>
     <None Include="ChangeLog" />
@@ -95,30 +102,53 @@
     <EmbeddedResource Include="gendarme.xsl" />
   </ItemGroup>
   <ItemGroup>
+    <BootstrapperPackage Include="Microsoft.Net.Client.3.5">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1 Client Profile</ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
     <BootstrapperPackage Include="Microsoft.Net.Framework.2.0">
       <Visible>False</Visible>
+      <ProductName>
+      </ProductName>
+      <Install>false</Install>
     </BootstrapperPackage>
     <BootstrapperPackage Include="Microsoft.Net.Framework.3.0">
       <Visible>False</Visible>
+      <ProductName>
+      </ProductName>
+      <Install>false</Install>
     </BootstrapperPackage>
     <BootstrapperPackage Include="Microsoft.Net.Framework.3.5">
       <Visible>False</Visible>
+      <ProductName>
+      </ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1</ProductName>
+      <Install>false</Install>
     </BootstrapperPackage>
   </ItemGroup>
   <Import Project="$(MSBuildBinPath)\Microsoft.CSharp.targets" />
   <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
        Other similar extension points exist, see Microsoft.Common.targets.
-  <Target Name="BeforeBuild">
-  </Target>
-  <Target Name="AfterBuild">
-  </Target>
+  <Target Name="BeforeBuild">
+  </Target>
   -->
+  <Target Name="AfterBuild">
+    <Copy
+      SourceFiles="$(TargetDir)..\..\..\rules\rules.xml"
+      DestinationFolder="$(TargetDir)"
+      SkipUnchangedFiles="True"
+    />
+  </Target>
   <PropertyGroup>
     <PreBuildEvent>
     </PreBuildEvent>
-    <PostBuildEvent>copy "$(TargetDir)..\..\..\rules\rules.xml" "$(TargetDir)"
-copy "$(TargetDir)..\..\..\..\..\cecil\bin\net_3_5_Release\Mono.Cecil.Pdb.*" "$(TargetDir)"
-copy "$(TargetDir)..\..\..\..\..\cecil\bin\net_3_5_Release\Mono.Cecil.Mdb.*" "$(TargetDir)"</PostBuildEvent>
+    <PostBuildEvent>
+    </PostBuildEvent>
   </PropertyGroup>
   <ProjectExtensions>
     <MonoDevelop>
diff --git a/gendarme/framework/Gendarme.Framework.Engines/SuppressMessageEngine.cs b/gendarme/framework/Gendarme.Framework.Engines/SuppressMessageEngine.cs
index a98a6bc..70ef7ba 100644
--- a/gendarme/framework/Gendarme.Framework.Engines/SuppressMessageEngine.cs
+++ b/gendarme/framework/Gendarme.Framework.Engines/SuppressMessageEngine.cs
@@ -71,7 +71,7 @@ namespace Gendarme.Framework.Engines {
 		{
 			// we only need to check the custom attributes if [SuppressMessage] is referenced (note: won't work for mscorlib)
 			AssemblyDefinition assembly = (sender as AssemblyDefinition);
-			if (assembly.MainModule.HasTypeReference (SuppressMessage)) {
+			if (assembly.MainModule.AnyTypeReference ((TypeReference tr) => { return tr.IsNamed ("System.Diagnostics.CodeAnalysis", "SuppressMessageAttribute"); })) {
 				Controller.BuildingCustomAttributes += new EventHandler<EngineEventArgs> (OnCustomAttributes);
 			} else {
 				Controller.BuildingCustomAttributes -= new EventHandler<EngineEventArgs> (OnCustomAttributes);
@@ -103,7 +103,7 @@ namespace Gendarme.Framework.Engines {
 			foreach (CustomAttribute ca in cap.CustomAttributes) {
 				if (!ca.HasConstructorArguments)
 					continue;
-				if (ca.AttributeType.FullName != SuppressMessage)
+				if (!ca.AttributeType.IsNamed ("System.Diagnostics.CodeAnalysis", "SuppressMessageAttribute"))
 					continue;
 
 				var arguments = ca.ConstructorArguments;
@@ -200,7 +200,7 @@ namespace Gendarme.Framework.Engines {
 				foreach (ModuleDefinition module in assembly.Modules) {
 					// TODO ...
 					foreach (TypeDefinition type in module.GetAllTypes ()) {
-						if (targets.TryGetValue (type.FullName, out rules))
+						if (targets.TryGetValue (type.GetFullName (), out rules))
 							Add (type, rules);
 
 						if (type.HasMethods) {
@@ -213,11 +213,11 @@ namespace Gendarme.Framework.Engines {
 			targets.Clear ();
 		}
 
-		private void ResolveMethod (IMetadataTokenProvider method)
+		private void ResolveMethod (MemberReference method)
 		{
 			HashSet<string> rules;
 
-			string m = method.ToString ();
+			string m = method.GetFullName ();
 			m = m.Substring (m.IndexOf (' ') + 1);
 
 			if (targets.TryGetValue (m, out rules))
diff --git a/gendarme/framework/Gendarme.Framework.Helpers/Log.cs b/gendarme/framework/Gendarme.Framework.Helpers/Log.cs
index 262c7e9..759ba9f 100644
--- a/gendarme/framework/Gendarme.Framework.Helpers/Log.cs
+++ b/gendarme/framework/Gendarme.Framework.Helpers/Log.cs
@@ -30,6 +30,7 @@ using System.Diagnostics;
 using System.Collections.Generic;
 
 using Mono.Cecil;
+using Gendarme.Framework.Rocks;
 
 namespace Gendarme.Framework.Helpers {
 
@@ -83,9 +84,9 @@ namespace Gendarme.Framework.Helpers {
 		}
 		
 		[Conditional ("DEBUG")]
-		public static void WriteLine<T> (T category, MethodDefinition method)
+		public static void WriteLine<T> (T category, MemberReference member)
 		{
-			WriteLine (typeof (T).Name, method);
+			WriteLine (typeof (T).Name, member);
 		}
 		
 		// WriteLine (string)
@@ -104,10 +105,15 @@ namespace Gendarme.Framework.Helpers {
 		}
 		
 		[Conditional ("DEBUG")]
-		public static void WriteLine (string category, MethodDefinition method)
+		public static void WriteLine (string category, MemberReference member)
 		{
-			if (IsEnabled (category))
-				Debug.WriteLine (new MethodPrinter (method).ToString ());
+			if (IsEnabled (category)) {
+				MethodDefinition md = (member as MethodDefinition);
+				if (md != null)
+					Debug.WriteLine (new MethodPrinter (md).ToString ());
+				else
+					Debug.WriteLine (member.GetFullName ());
+			}
 		}
 		
 		// Misc
diff --git a/gendarme/framework/Gendarme.Framework.Helpers/MethodPrinter.cs b/gendarme/framework/Gendarme.Framework.Helpers/MethodPrinter.cs
index af3638c..ef40dcc 100644
--- a/gendarme/framework/Gendarme.Framework.Helpers/MethodPrinter.cs
+++ b/gendarme/framework/Gendarme.Framework.Helpers/MethodPrinter.cs
@@ -15,6 +15,7 @@ using System;
 using System.Collections;
 using System.Collections.Generic;
 using System.Diagnostics;
+using System.Globalization;
 using System.Text;
 using Mono.Cecil;
 using Mono.Cecil.Cil;
@@ -60,17 +61,28 @@ namespace Gendarme.Framework.Helpers {
 						buffer.Append ("* ");
 					else
 						buffer.Append ("  ");
-					buffer.AppendFormat ("  {0}: {1}", instr.Offset.ToString ("X4"),
-							instr.OpCode.Name);
+
+					buffer.Append ("  ");
+					buffer.Append (instr.Offset.ToString ("X4", CultureInfo.InvariantCulture));
+					buffer.Append (": ");
+					buffer.Append (instr.OpCode.Name);
+
 					int[] targets = BranchTargets (instr);
-					if (targets != null)
-						foreach (int target in targets)
-							buffer.AppendFormat (" {0}", target.ToString ("X4"));
-					else if (instr.Operand is string)
-						buffer.AppendFormat (" \"{0}\"", instr.Operand.ToString ());
-					else if (instr.Operand != null)
-						buffer.AppendFormat (" {0}", instr.Operand.ToString ());
-					buffer.AppendLine (string.Empty);
+					if (targets != null) {
+						foreach (int target in targets) {
+							buffer.Append (' ');
+							buffer.Append (target.ToString ("X4", CultureInfo.InvariantCulture));
+						}
+					} else if (instr.Operand is string) {
+						buffer.Append (" \"");
+						buffer.Append (instr.Operand);
+						buffer.Append ('"');
+					} else if (instr.Operand != null) {
+						buffer.Append (" ");
+						buffer.Append (instr.Operand);
+					}
+					buffer.AppendLine ();
+
 					prevInstr = instr;
 					if (EndsTryRegion (instr) != null)
 						buffer.AppendLine ("} (Try)");
diff --git a/gendarme/framework/Gendarme.Framework.Helpers/MethodSignature.cs b/gendarme/framework/Gendarme.Framework.Helpers/MethodSignature.cs
index e6fd265..a17ae07 100644
--- a/gendarme/framework/Gendarme.Framework.Helpers/MethodSignature.cs
+++ b/gendarme/framework/Gendarme.Framework.Helpers/MethodSignature.cs
@@ -34,6 +34,7 @@ using System.Collections.Generic;
 using System.Text;
 
 using Mono.Cecil;
+using Gendarme.Framework.Rocks;
 
 namespace Gendarme.Framework.Helpers {
 
@@ -49,7 +50,7 @@ namespace Gendarme.Framework.Helpers {
 	/// }
 	/// </code>
 	/// </example>
-	// <seealso cref="Gendarme.Framework.Helpers.MethodSignatures"/>
+	/// <seealso cref="Gendarme.Framework.Helpers.MethodSignatures"/>
 	public class MethodSignature {
 
 		/// <summary>
@@ -121,7 +122,7 @@ namespace Gendarme.Framework.Helpers {
 			if (Name != null && method.Name != Name)
 				return false;
 
-			if (ReturnType != null && method.ReturnType.FullName != ReturnType)
+			if (ReturnType != null && !method.ReturnType.IsNamed (ReturnType))
 				return false;
 
 			if (Parameters != null) {
@@ -132,7 +133,7 @@ namespace Gendarme.Framework.Helpers {
 					for (int i = 0; i < Parameters.Count; i++) {
 						if (Parameters [i] == null)
 							continue;//ignore parameter
-						if (Parameters [i] != pdc [i].ParameterType.FullName) {
+						if (!pdc [i].ParameterType.IsNamed (Parameters [i])) {
 							return false;
 						}
 					}
diff --git a/gendarme/framework/Gendarme.Framework.Helpers/MethodSignatures.cs b/gendarme/framework/Gendarme.Framework.Helpers/MethodSignatures.cs
index 3b8b4ad..27116fa 100644
--- a/gendarme/framework/Gendarme.Framework.Helpers/MethodSignatures.cs
+++ b/gendarme/framework/Gendarme.Framework.Helpers/MethodSignatures.cs
@@ -32,6 +32,7 @@ using System;
 using System.Collections.Generic;
 
 using Mono.Cecil;
+using Gendarme.Framework.Rocks;
 
 namespace Gendarme.Framework.Helpers {
 
@@ -120,19 +121,23 @@ namespace Gendarme.Framework.Helpers {
 		// TryParse
 		public static readonly MethodSignature TryParse = new MethodSignature ("TryParse",
 			delegate (MethodReference method) {
-				if (method.ReturnType.FullName != "System.Boolean")
+				if (!method.ReturnType.IsNamed ("System", "Boolean"))
 					return false;
 
 				IList<ParameterDefinition> pdc = method.Parameters;
-				if (pdc [0].ParameterType.FullName != "System.String")
+				if (!pdc [0].ParameterType.IsNamed ("System", "String"))
 					return false;
 
 				TypeReference last = pdc [pdc.Count - 1].ParameterType;
 				if (!last.IsByReference)
 					return false;
 
-				string pt_name = last.FullName;
-				return (String.Compare (pt_name, 0, method.DeclaringType.FullName, 0, pt_name.Length - 1) == 0);
+				TypeReference mtype = method.DeclaringType;
+				if (last.Namespace != mtype.Namespace)
+					return false;
+
+				string pt_name = last.Name;
+				return (String.Compare (pt_name, 0, mtype.Name, 0, pt_name.Length - 1, StringComparison.Ordinal) == 0);
 			}
 		);
 
@@ -141,9 +146,9 @@ namespace Gendarme.Framework.Helpers {
 			delegate (MethodReference method) {
 				if (!method.HasParameters)
 					return false;
-				if (method.ReturnType.FullName != method.DeclaringType.FullName)
+				if (!method.ReturnType.IsNamed (method.DeclaringType.Namespace, method.DeclaringType.Name))
 					return false;
-				return (method.Parameters [0].ParameterType.FullName == "System.String");
+				return method.Parameters [0].ParameterType.IsNamed ("System", "String");
 			}
 		);
 	}
diff --git a/gendarme/framework/Gendarme.Framework.Helpers/OpCodeBitmask.cs b/gendarme/framework/Gendarme.Framework.Helpers/OpCodeBitmask.cs
index f7ceeac..6058fbe 100644
--- a/gendarme/framework/Gendarme.Framework.Helpers/OpCodeBitmask.cs
+++ b/gendarme/framework/Gendarme.Framework.Helpers/OpCodeBitmask.cs
@@ -26,6 +26,7 @@
 //
 
 using System;
+using System.Globalization;
 using System.Text;
 
 using Mono.Cecil.Cil;
@@ -144,12 +145,12 @@ namespace Gendarme.Framework.Helpers {
 			return Equals (obj as OpCodeBitmask);
 		}
 
-		public bool Equals (OpCodeBitmask set)
+		public bool Equals (OpCodeBitmask other)
 		{
-			if (set == null)
+			if (other == null)
 				return false;
-			return ((mask [0] == set.mask [0]) || (mask [1] == set.mask [1]) ||
-				(mask [2] == set.mask [2]) || (mask [3] == set.mask [3]));
+			return ((mask [0] == other.mask [0]) || (mask [1] == other.mask [1]) ||
+				(mask [2] == other.mask [2]) || (mask [3] == other.mask [3]));
 		}
 
 		public override int GetHashCode ()
@@ -159,7 +160,8 @@ namespace Gendarme.Framework.Helpers {
 
 		public override string ToString ()
 		{
-			return String.Format ("0x{0:X}:0x{1:X}:0x{2:X}:0x{3:X}", mask [0], mask [1], mask [2], mask [3]);
+			return String.Format (CultureInfo.InvariantCulture, "0x{0:X}:0x{1:X}:0x{2:X}:0x{3:X}", 
+				mask [0], mask [1], mask [2], mask [3]);
 		}
 
 
diff --git a/gendarme/framework/Gendarme.Framework.Helpers/StackEntryAnalysis.cs b/gendarme/framework/Gendarme.Framework.Helpers/StackEntryAnalysis.cs
index 61d5f9b..156aef1 100644
--- a/gendarme/framework/Gendarme.Framework.Helpers/StackEntryAnalysis.cs
+++ b/gendarme/framework/Gendarme.Framework.Helpers/StackEntryAnalysis.cs
@@ -97,9 +97,9 @@ namespace Gendarme.Framework.Helpers {
 				return this == other;
 			}
 
-			public bool Equals (StoreSlot storeSlot)
+			public bool Equals (StoreSlot other)
 			{
-				return this == storeSlot;
+				return this == other;
 			}
 
 			public override int GetHashCode ()
@@ -182,40 +182,14 @@ namespace Gendarme.Framework.Helpers {
 				return false;
 			}
 
-			public bool Equals (InstructionWithLeave iwl)
+			public bool Equals (InstructionWithLeave other)
 			{
-				if (Instruction != iwl.Instruction)
-					return false;
-
-				if (LeaveStack == null)
-					return (iwl.LeaveStack == null);
-
-				if (iwl.LeaveStack == null)
-					return false;
-
-				if (LeaveStack.Length != iwl.LeaveStack.Length)
-					return false;
-
-				for (int i = 0; i < LeaveStack.Length; i++) {
-					if (LeaveStack [i] != iwl.LeaveStack [i])
-						return false;
-				}
-				return true;
+				return (Instruction == other.Instruction);
 			}
 
 			public override int GetHashCode ()
 			{
-				int hc = 0;
-				
-				unchecked {
-					hc ^= Instruction.GetHashCode ();
-					if (LeaveStack != null) {
-						foreach (Instruction ins in LeaveStack)
-							hc ^= ins.GetHashCode ();
-					}
-				}
-				
-				return hc;
+				return Instruction.GetHashCode ();
 			}
 
 			public static bool operator == (InstructionWithLeave left, InstructionWithLeave right)
@@ -527,7 +501,7 @@ namespace Gendarme.Framework.Helpers {
 				return new StoreSlot (StoreType.Argument, ins.OpCode.Code - Code.Ldarg_0);
 			case Code.Ldarg_S:
 			case Code.Ldarg: {
-					int sequence = ((ParameterDefinition) ins.Operand).GetSequence ();
+					int sequence = ((ParameterDefinition) ins.Operand).Index + 1;
 					if (!this.Method.HasThis)
 						sequence--;
 					return new StoreSlot (StoreType.Argument, sequence);
@@ -581,7 +555,7 @@ namespace Gendarme.Framework.Helpers {
 
 			case Code.Starg_S: //store arg (not ref / out etc)
 			case Code.Starg: {
-					int sequence = ((ParameterDefinition) ins.Operand).GetSequence ();
+					int sequence = ((ParameterDefinition) ins.Operand).Index + 1;
 					if (!this.Method.HasThis)
 						sequence--;
 					return new StoreSlot (StoreType.Argument, sequence);
diff --git a/gendarme/framework/Gendarme.Framework.Helpers/StackEntryUsageResult.cs b/gendarme/framework/Gendarme.Framework.Helpers/StackEntryUsageResult.cs
index 1fa302f..9c69872 100644
--- a/gendarme/framework/Gendarme.Framework.Helpers/StackEntryUsageResult.cs
+++ b/gendarme/framework/Gendarme.Framework.Helpers/StackEntryUsageResult.cs
@@ -61,9 +61,9 @@ namespace Gendarme.Framework.Helpers {
 			return false;
 		}
 
-		public bool Equals (StackEntryUsageResult usageResult)
+		public bool Equals (StackEntryUsageResult other)
 		{
-			return (Instruction == usageResult.Instruction) && (StackOffset == usageResult.StackOffset);
+			return (Instruction == other.Instruction) && (StackOffset == other.StackOffset);
 		}
 
 		public override int GetHashCode ()
diff --git a/gendarme/framework/Gendarme.Framework.Helpers/StreamLineReader.cs b/gendarme/framework/Gendarme.Framework.Helpers/StreamLineReader.cs
new file mode 100644
index 0000000..3242474
--- /dev/null
+++ b/gendarme/framework/Gendarme.Framework.Helpers/StreamLineReader.cs
@@ -0,0 +1,122 @@
+//
+// StreamLineReader - A StringReader-like class that avoid creating string
+//
+// Authors:
+//	Sebastien Pouliot <sebastien@ximian.com>
+//
+// Copyright (C) 2011 Novell, Inc (http://www.novell.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.IO;
+
+namespace Gendarme.Framework.Helpers {
+
+	// note: inheriting from StreamReader was not possible since we cannot
+	// override EndOfStream and ensure integrity with other Read ops
+	public class StreamLineReader : IDisposable {
+
+		StreamReader sr;
+		char [] buff;
+		int n;
+		int max;
+
+		public StreamLineReader (string fileName)
+		{
+			sr = new StreamReader (fileName);
+			Initialize ();
+		}
+
+		public StreamLineReader (Stream stream)
+		{
+			sr = new StreamReader (stream);
+			Initialize ();
+		}
+
+		void Initialize ()
+		{
+			buff = new char [4096];
+			max = n = buff.Length;
+		}
+
+		public bool EndOfStream {
+			get { return (n == max || max == 0) && sr.EndOfStream; }
+		}
+
+		public int ReadLine (char [] buffer, int index, int count)
+		{
+			if (Disposed)
+				throw new ObjectDisposedException ("StreamLineReader");
+			if (buffer == null)
+				throw new ArgumentNullException ("buffer");
+			if (index < 0)
+				throw new ArgumentOutOfRangeException ("index", "< 0");
+			if (count < 0)
+				throw new ArgumentOutOfRangeException ("count", "< 0");
+			// ordered to avoid possible integer overflow
+			if (index > buffer.Length - count)
+				throw new ArgumentException ("index + count > buffer.Length");
+
+			int len = 0;
+			while (len < count) {
+				if (n == max) {
+					max = sr.ReadBlock (buff, 0, buff.Length);
+					if (max == 0) break;
+					n = 0;
+				}
+				char c = buff [n++];
+				switch (c) {
+				case '\r':
+					continue;
+				case '\n':
+					Array.Clear (buffer, len, buffer.Length - len);
+					return len;
+				default:
+					buffer [index++] = c;
+					len++;
+					break;
+				}
+			}
+			return len;
+		}
+
+		public void Dispose ()
+		{
+			Dispose (true);
+			GC.SuppressFinalize (this);
+		}
+
+		protected virtual void Dispose (bool disposing)
+		{
+			try {
+				if (!Disposed)
+					sr.Dispose ();
+			}
+			finally {
+				Disposed = true;
+			}
+		}
+
+		protected bool Disposed { get; private set; }
+	}
+}
+
diff --git a/gendarme/framework/Gendarme.Framework.Rocks/CecilRocks.cs b/gendarme/framework/Gendarme.Framework.Rocks/CecilRocks.cs
index a1b2cfc..12c6345 100644
--- a/gendarme/framework/Gendarme.Framework.Rocks/CecilRocks.cs
+++ b/gendarme/framework/Gendarme.Framework.Rocks/CecilRocks.cs
@@ -27,6 +27,7 @@
 //
 
 using System;
+using System.Collections.Generic;
 
 using Mono.Cecil;
 using Mono.Cecil.Metadata;
@@ -157,5 +158,30 @@ namespace Gendarme.Framework.Rocks {
 			// compare assemblies tokens (but do not recurse)
 			return other == null ? false : self_assembly.MetadataToken.Equals (other_assembly.MetadataToken);
 		}
+
+		static Dictionary<MemberReference, string> full_name_cache = new Dictionary<MemberReference, string> ();
+
+		/// <summary>
+		/// Get the string value of the MemberReference FullName property without the cost 
+		/// of allocating a new string for each (or most) calls. 
+		/// </summary>
+		/// <param name="self">The MemberReference instance where the method is applied.</param>
+		/// <returns>The cached FullName property of the MemberReference</returns>
+		/// <remarks>Cecil needs to rebuild most of the FullName properties on each call in order to
+		/// be able to write assemblies. However this is a waste of memory when an application, like 
+		/// Gendarme, use it for read-only purposes.</remarks>
+		public static string GetFullName (this MemberReference self)
+		{
+			if (self == null)
+				return String.Empty;
+
+			string full_name;
+			if (!full_name_cache.TryGetValue (self, out full_name)) {
+				full_name = self.FullName;
+				full_name_cache.Add (self, full_name);
+			}
+
+			return full_name;
+		}
 	}
 }
diff --git a/gendarme/framework/Gendarme.Framework.Rocks/CustomAttributeRocks.cs b/gendarme/framework/Gendarme.Framework.Rocks/CustomAttributeRocks.cs
index 26b6401..ebfb1ba 100644
--- a/gendarme/framework/Gendarme.Framework.Rocks/CustomAttributeRocks.cs
+++ b/gendarme/framework/Gendarme.Framework.Rocks/CustomAttributeRocks.cs
@@ -44,51 +44,16 @@ namespace Gendarme.Framework.Rocks {
 	/// </summary>
 	public static class CustomAttributeRocks {
 
-		internal static string [] GeneratedCodeAttributes = {
-			 "System.CodeDom.Compiler.GeneratedCodeAttribute",
-			 "System.Runtime.CompilerServices.CompilerGeneratedAttribute"
-		};
-
-		/// <summary>
-		/// Check if the custom attribute collection contains an attribute of a specified type.
-		/// </summary>
-		/// <param name="self">The CustomAttribute enumerable on which the extension method can be called.</param>
-		/// <param name="attributeTypeName">Full type name of the attribute class.</param>
-		/// <returns>True if the collection contains an attribute of the same name,
-		/// False otherwise.</returns>
-		public static bool ContainsType (this IEnumerable<CustomAttribute> self, string attributeTypeName)
+		internal static bool HasAnyGeneratedCodeAttribute (this ICustomAttributeProvider self)
 		{
-			if (attributeTypeName == null)
-				throw new ArgumentNullException ("attributeTypeName");
-			if (self == null)
+			if ((self == null) || !self.HasCustomAttributes)
 				return false;
 
-			foreach (CustomAttribute ca in self) {
-				if (ca.AttributeType.FullName == attributeTypeName)
+			foreach (CustomAttribute ca in self.CustomAttributes) {
+				TypeReference cat = ca.AttributeType;
+				if (cat.IsNamed ("System.CodeDom.Compiler", "GeneratedCodeAttribute") ||
+					cat.IsNamed ("System.Runtime.CompilerServices", "CompilerGeneratedAttribute")) {
 					return true;
-			}
-			return false;
-		}
-
-		/// <summary>
-		/// Check if the custom attribute collection contains any of the specified type.
-		/// </summary>
-		/// <param name="self">The CustomAttribute enumerable on which the extension method can be called.</param>
-		/// <param name="attributeTypeNames">A strings array of full type names of the attributes.</param>
-		/// <returns>True if the collection contains any attribute matching one specified,
-		/// False otherwise.</returns>
-		public static bool ContainsAnyType (this IEnumerable<CustomAttribute> self, string[] attributeTypeNames)
-		{
-			if (attributeTypeNames == null)
-				throw new ArgumentNullException ("attributeTypeNames");
-			if (self == null)
-				return false;
-
-			foreach (CustomAttribute ca in self) {
-				string fullname = ca.AttributeType.FullName;
-				foreach (string attribute_full_name in attributeTypeNames) {
-					if (fullname == attribute_full_name)
-						return true;
 				}
 			}
 			return false;
@@ -99,17 +64,25 @@ namespace Gendarme.Framework.Rocks {
 		/// </summary>
 		/// <param name="self">The ICustomAttributeProvider (e.g. AssemblyDefinition, TypeReference, MethodReference,
 		/// FieldReference...) on which the extension method can be called.</param>
-		/// <param name="attributeName">Full name of the attribute class</param>
+		/// <param name="nameSpace">The namespace of the attribute to be matched</param>
+		/// <param name="name">The name of the attribute to be matched</param>
 		/// <returns>True if the provider contains an attribute of the same name,
 		/// False otherwise.</returns>
-		public static bool HasAttribute (this ICustomAttributeProvider self, string attributeName)
+		public static bool HasAttribute (this ICustomAttributeProvider self, string nameSpace, string name)
 		{
-			if (attributeName == null)
-				throw new ArgumentNullException ("attributeName");
+			if (nameSpace == null)
+				throw new ArgumentNullException ("nameSpace");
+			if (name == null)
+				throw new ArgumentNullException ("name");
 
 			if ((self == null) || !self.HasCustomAttributes)
 				return false;
-			return self.CustomAttributes.ContainsType (attributeName);
+
+			foreach (CustomAttribute ca in self.CustomAttributes) {
+				if (ca.AttributeType.IsNamed (nameSpace, name))
+					return true;
+			}
+			return false;
 		}
 	}
 }
diff --git a/gendarme/framework/Gendarme.Framework.Rocks/FieldRocks.cs b/gendarme/framework/Gendarme.Framework.Rocks/FieldRocks.cs
index 39641f5..bf3b30b 100644
--- a/gendarme/framework/Gendarme.Framework.Rocks/FieldRocks.cs
+++ b/gendarme/framework/Gendarme.Framework.Rocks/FieldRocks.cs
@@ -49,10 +49,9 @@ namespace Gendarme.Framework.Rocks {
 			if (field == null)
 				return false;
 
-			if (field.HasCustomAttributes) {
-				if (field.CustomAttributes.ContainsAnyType (CustomAttributeRocks.GeneratedCodeAttributes))
-					return true;
-			}
+			if (field.HasAnyGeneratedCodeAttribute ())
+				return true;
+
 			return field.DeclaringType.IsGeneratedCode ();
 		}
 
diff --git a/gendarme/framework/Gendarme.Framework.Rocks/InstructionRocks.cs b/gendarme/framework/Gendarme.Framework.Rocks/InstructionRocks.cs
index 6c8aaf6..aef546a 100644
--- a/gendarme/framework/Gendarme.Framework.Rocks/InstructionRocks.cs
+++ b/gendarme/framework/Gendarme.Framework.Rocks/InstructionRocks.cs
@@ -27,6 +27,7 @@
 // THE SOFTWARE.
 
 using System;
+using System.Globalization;
 
 using Mono.Cecil;
 using Mono.Cecil.Cil;
@@ -291,7 +292,7 @@ namespace Gendarme.Framework.Rocks {
 			case StackBehaviour.Varpop:
 				switch (self.OpCode.FlowControl) {
 				case FlowControl.Return:
-					return method.ReturnType.FullName == "System.Void" ? 0 : 1;
+					return method.ReturnType.IsNamed ("System", "Void") ? 0 : 1;
 
 				case FlowControl.Call:
 					IMethodSignature calledMethod = (IMethodSignature) self.Operand;
@@ -310,7 +311,8 @@ namespace Gendarme.Framework.Rocks {
 			case StackBehaviour.PopAll:
 				return -1;
 			default:
-				string unknown = String.Format ("'{0}' is not a valid value for instruction '{1}'.",
+				string unknown = String.Format (CultureInfo.InvariantCulture,
+					"'{0}' is not a valid value for instruction '{1}'.",
 					self.OpCode.StackBehaviourPush, self.OpCode);
 				throw new InvalidOperationException (unknown);
 			}
@@ -344,11 +346,12 @@ namespace Gendarme.Framework.Rocks {
 			case StackBehaviour.Varpush:
 				IMethodSignature calledMethod = (IMethodSignature) self.Operand;
 				if (calledMethod != null)
-					return (calledMethod.ReturnType.FullName == "System.Void") ? 0 : 1;
+					return calledMethod.ReturnType.IsNamed ("System", "Void") ? 0 : 1;
 
 				throw new NotImplementedException ("Varpush not supported for this Instruction.");
 			default:
-				string unknown = String.Format ("'{0}' is not a valid value for instruction '{1}'.",
+				string unknown = String.Format (CultureInfo.InvariantCulture,
+					"'{0}' is not a valid value for instruction '{1}'.",
 					self.OpCode.StackBehaviourPush, self.OpCode);
 				throw new InvalidOperationException (unknown);
 			}
diff --git a/gendarme/framework/Gendarme.Framework.Rocks/MethodRocks.cs b/gendarme/framework/Gendarme.Framework.Rocks/MethodRocks.cs
index f4a604c..eace40a 100644
--- a/gendarme/framework/Gendarme.Framework.Rocks/MethodRocks.cs
+++ b/gendarme/framework/Gendarme.Framework.Rocks/MethodRocks.cs
@@ -55,6 +55,15 @@ namespace Gendarme.Framework.Rocks {
 	/// </summary>
 	public static class MethodRocks {
 
+		public static bool IsNamed (this MemberReference self, string nameSpace, string typeName, string methodName)
+		{
+			if (methodName == null)
+				throw new ArgumentNullException ("methodName");
+			if (self == null)
+				return false;
+			return ((self.Name == methodName) && self.DeclaringType.IsNamed (nameSpace, typeName));
+		}
+
 		/// <summary>
 		/// Check if the MethodReference is defined as the entry point of it's assembly.
 		/// </summary>
@@ -76,7 +85,7 @@ namespace Gendarme.Framework.Rocks {
 				return false;
 
 			return (self.HasThis && !self.HasParameters && (self.Name == "Finalize") &&
-				(self.ReturnType.FullName == "System.Void"));
+				self.ReturnType.IsNamed ("System", "Void"));
 		}
 
 		/// <summary>
@@ -91,10 +100,9 @@ namespace Gendarme.Framework.Rocks {
 				return false;
 
 			MethodDefinition method = self.Resolve ();
-			if ((method != null) && method.HasCustomAttributes) {
-				if (method.CustomAttributes.ContainsAnyType (CustomAttributeRocks.GeneratedCodeAttributes))
-					return true;
-			}
+			if (method.HasAnyGeneratedCodeAttribute ())
+				return true;
+
 			return self.DeclaringType.IsGeneratedCode ();
 		}
 
@@ -161,27 +169,10 @@ namespace Gendarme.Framework.Rocks {
 			TypeDefinition parent = declaring.BaseType != null ? declaring.BaseType.Resolve () : null;
 			while (parent != null) {
 				string name = method.Name;
-				string retval = method.ReturnType.FullName;
-				int pcount = method.HasParameters ? method.Parameters.Count : 0;
 				foreach (MethodDefinition md in parent.Methods) {
 					if (name != md.Name)
 						continue;
-					if (retval != md.ReturnType.FullName)
-						continue;
-					if (md.HasParameters && (pcount == 0))
-						continue;
-					IList<ParameterDefinition> ppdc = md.Parameters;
-					if (pcount != ppdc.Count)
-						continue;
-
-					bool ok = true;
-					for (int i = 0; i < pcount; i++) {
-						if (method.Parameters [i].ParameterType.FullName != ppdc [i].ParameterType.FullName) {
-							ok = false;
-							break;
-						}
-					}
-					if (!ok)
+					if (!method.CompareSignature (md))
 						continue;
 
 					return md.IsVirtual;
@@ -246,11 +237,11 @@ namespace Gendarme.Framework.Rocks {
 			TypeReference type = parameters [1].ParameterType;
 			GenericParameter gp = (type as GenericParameter);
 			if (gp == null)
-				return type.Inherits ("System.EventArgs");
+				return type.Inherits ("System", "EventArgs");
 
 			if (gp.HasConstraints) {
 				IList<TypeReference> cc = gp.Constraints;
-				return ((cc.Count == 1) && (cc [0].FullName == "System.EventArgs"));
+				return ((cc.Count == 1) && cc [0].IsNamed ("System", "EventArgs"));
 			}
 
 			return false;
@@ -283,7 +274,7 @@ namespace Gendarme.Framework.Rocks {
 
 		private static bool AreSameElementTypes (TypeReference a, TypeReference b)
 		{
-			return a.GetElementType ().FullName == b.GetElementType ().FullName;
+			return a.IsGenericParameter || b.IsGenericParameter || b.IsNamed (a.Namespace, a.Name);
 		}
 
 		/// <summary>
diff --git a/gendarme/framework/Gendarme.Framework.Rocks/ModuleRocks.cs b/gendarme/framework/Gendarme.Framework.Rocks/ModuleRocks.cs
index 06a946c..3aad117 100644
--- a/gendarme/framework/Gendarme.Framework.Rocks/ModuleRocks.cs
+++ b/gendarme/framework/Gendarme.Framework.Rocks/ModuleRocks.cs
@@ -4,7 +4,7 @@
 // Authors:
 //	Sebastien Pouliot  <sebastien@ximian.com>
 //
-// Copyright (C) 2008 Novell, Inc (http://www.novell.com)
+// Copyright (C) 2008, 2011 Novell, Inc (http://www.novell.com)
 //
 // Permission is hereby granted, free of charge, to any person obtaining a copy
 // of this software and associated documentation files (the "Software"), to deal
@@ -155,19 +155,58 @@ namespace Gendarme.Framework.Rocks {
 				yield return type;
 		}
 
-		public static bool HasAnyTypeReference (this ModuleDefinition self, string [] typeNames)
+		static Dictionary<ModuleDefinition, IEnumerable<MemberReference>> member_ref_cache = new Dictionary<ModuleDefinition, IEnumerable<MemberReference>> ();
+
+		/// <summary>
+		/// Check if any MemberReference, referenced by the current ModuleDefinition, satisfies the
+		/// specified predicate.
+		/// </summary>
+		/// <param name="self">The ModuleDefinition on which the extension method can be called.</param>
+		/// <param name="predicate">The condition to execute on a provided MemberReference</param>
+		/// <returns>True if 'predicate' returns true for any MemberReference in the module's referenced types.</returns>
+		/// <remarks>Cecil's GetMemberReferences method will allocate a new array each time it is called.
+		/// This extension method will cache the IEnumerable, on the first use, to reduce memory consumption.</remarks>
+		public static bool AnyMemberReference (this ModuleDefinition self, Func<MemberReference, bool> predicate)
 		{
 			if (self == null)
 				return false;
 
-			if (typeNames == null)
-				throw new ArgumentNullException ("typeNames");
+			// since ModuleDefinition.GetMemberReferences allocates an array (always identical if the
+			// assembly is opened "read-only", like Gendarme does) we'll cache and retrieve the array
+			IEnumerable<MemberReference> refs;
+			if (!member_ref_cache.TryGetValue (self, out refs)) {
+				refs = self.GetMemberReferences ();
+				member_ref_cache.Add (self, refs);
+			}
+
+			return refs.Any (predicate);
+		}
+
+		static Dictionary<ModuleDefinition, IEnumerable<TypeReference>> type_ref_cache = new Dictionary<ModuleDefinition, IEnumerable<TypeReference>> ();
 
-			foreach (var typeName in typeNames)
-				if (self.HasTypeReference (typeName))
-					return true;
+		/// <summary>
+		/// Check if any TypeReference, referenced by the current ModuleDefinition, satisfies the
+		/// specified predicate.
+		/// </summary>
+		/// <param name="self">The ModuleDefinition on which the extension method can be called.</param>
+		/// <param name="predicate">The condition to execute on a provided TypeReference</param>
+		/// <returns>True if 'predicate' returns true for any TypeReference in the module's referenced types.</returns>
+		/// <remarks>Cecil's GetTypeReferences method will allocate a new array each time it is called.
+		/// This extension method will cache the IEnumerable, on the first use, to reduce memory consumption.</remarks>
+		public static bool AnyTypeReference (this ModuleDefinition self, Func<TypeReference, bool> predicate)
+		{
+			if (self == null)
+				return false;
+
+			// since ModuleDefinition.GetTypeReferences allocates an array (always identical if the
+			// assembly is opened "read-only", like Gendarme does) we'll cache and retrieve the array
+			IEnumerable<TypeReference> refs;
+			if (!type_ref_cache.TryGetValue (self, out refs)) {
+				refs = self.GetTypeReferences ();
+				type_ref_cache.Add (self, refs);
+			}
 
-			return false;
+			return refs.Any (predicate);
 		}
 	}
 }
diff --git a/gendarme/framework/Gendarme.Framework.Rocks/ParameterRocks.cs b/gendarme/framework/Gendarme.Framework.Rocks/ParameterRocks.cs
index cfc87ca..7a41c01 100644
--- a/gendarme/framework/Gendarme.Framework.Rocks/ParameterRocks.cs
+++ b/gendarme/framework/Gendarme.Framework.Rocks/ParameterRocks.cs
@@ -39,22 +39,7 @@ namespace Gendarme.Framework.Rocks {
 		/// <returns>True if the parameter represents a list of parameters, false otherwise.</returns>
 		public static bool IsParams (this ParameterDefinition self)
 		{
-			if (self == null || !self.HasCustomAttributes)
-				return false;
-			return self.CustomAttributes.ContainsType ("System.ParamArrayAttribute");
-		}
-
-		/// <summary>
-		/// Returns the sequence number as found in the metadata
-		/// </summary>
-		/// <param name="self">The ParameterDefinition on which the extension method can be called.</param>
-		/// <returns>The integer value of the sequence number of the parameter.</returns>
-		public static int GetSequence (this ParameterReference self)
-		{
-			if (self == null)
-				return -1;
-
-			return self.Index + 1;
+			return self.HasAttribute ("System", "ParamArrayAttribute");
 		}
 	}
 }
diff --git a/gendarme/framework/Gendarme.Framework.Rocks/PropertyRocks.cs b/gendarme/framework/Gendarme.Framework.Rocks/PropertyRocks.cs
index 293f9db..112d323 100644
--- a/gendarme/framework/Gendarme.Framework.Rocks/PropertyRocks.cs
+++ b/gendarme/framework/Gendarme.Framework.Rocks/PropertyRocks.cs
@@ -59,10 +59,9 @@ namespace Gendarme.Framework.Rocks {
 			if (self == null)
 				return false;
 
-			if (self.HasCustomAttributes) {
-				if (self.CustomAttributes.ContainsAnyType (CustomAttributeRocks.GeneratedCodeAttributes))
-					return true;
-			}
+			if (self.HasAnyGeneratedCodeAttribute ())
+				return true;
+
 			return self.DeclaringType.IsGeneratedCode ();
 		}
 	}
diff --git a/gendarme/framework/Gendarme.Framework.Rocks/TypeRocks.cs b/gendarme/framework/Gendarme.Framework.Rocks/TypeRocks.cs
index d549c63..efdcc0f 100644
--- a/gendarme/framework/Gendarme.Framework.Rocks/TypeRocks.cs
+++ b/gendarme/framework/Gendarme.Framework.Rocks/TypeRocks.cs
@@ -84,51 +84,6 @@ namespace Gendarme.Framework.Rocks {
 		}
 
 		/// <summary>
-		/// Check if a type reference collection contains a type of a specific name.
-		/// </summary>
-		/// <param name="self">The TypeReferenceCollection on which the extension method can be called.</param>
-		/// <param name="typeName">Full name of the type.</param>
-		/// <returns>True if the collection contains an type of the same name,
-		/// False otherwise.</returns>
-		public static bool ContainsType (this IEnumerable<TypeReference> self, string typeName)
-		{
-			if (typeName == null)
-				throw new ArgumentNullException ("typeName");
-			if (self == null)
-				return false;
-
-			foreach (TypeReference type in self) {
-				if (type.FullName == typeName)
-					return true;
-			}
-			return false;
-		}
-
-		/// <summary>
-		/// Check if a type reference collection contains any of the specified type names.
-		/// </summary>
-		/// <param name="self">The TypeReferenceCollection on which the extension method can be called.</param>
-		/// <param name="typeNames">A string array of full type names.</param>
-		/// <returns>True if the collection contains any types matching one specified,
-		/// False otherwise.</returns>
-		public static bool ContainsAnyType (this IEnumerable<TypeReference> self, string [] typeNames)
-		{
-			if (typeNames == null)
-				throw new ArgumentNullException ("typeNames");
-			if (self == null)
-				return false;
-
-			foreach (TypeReference type in self) {
-				string fullname = type.FullName;
-				foreach (string type_full_name in typeNames) {
-					if (fullname == type_full_name)
-						return true;
-				}
-			}
-			return false;
-		}
-
-		/// <summary>
 		/// Returns the first MethodDefinition that satisfies a given MethodSignature.
 		/// </summary>
 		/// <param name="self">The TypeReference on which the extension method can be called.</param>
@@ -177,7 +132,7 @@ namespace Gendarme.Framework.Rocks {
 					continue;
 				if ((method.Attributes & attributes) != attributes)
 					continue;
-				if (returnType != null && method.ReturnType.FullName != returnType)
+				if (returnType != null && !method.ReturnType.IsNamed (returnType))
 					continue;
 				if (parameters != null) {
 					if (method.HasParameters) {
@@ -188,7 +143,7 @@ namespace Gendarme.Framework.Rocks {
 						for (int i = 0; i < parameters.Length; i++) {
 							if (parameters [i] == null)
 								continue;//ignore parameter
-							if (parameters [i] != pdc [i].ParameterType.GetElementType ().FullName) {
+							if (!pdc [i].ParameterType.GetElementType ().IsNamed (parameters [i])) {
 								parameterError = true;
 								break;
 							}
@@ -284,13 +239,16 @@ namespace Gendarme.Framework.Rocks {
 		/// where the information resides could be unavailable. False is returned in this case.
 		/// </summary>
 		/// <param name="self">The TypeDefinition on which the extension method can be called.</param>
-		/// <param name="interfaceName">Full name of the interface</param>
+		/// <param name="nameSpace">The namespace of the interface to be matched</param>
+		/// <param name="name">The name of the interface to be matched</param>
 		/// <returns>True if we found that the type implements the interface, False otherwise (either it
 		/// does not implement it, or we could not find where it does).</returns>
-		public static bool Implements (this TypeReference self, string interfaceName)
+		public static bool Implements (this TypeReference self, string nameSpace, string name)
 		{
-			if (interfaceName == null)
-				throw new ArgumentNullException ("interfaceName");
+			if (nameSpace == null)
+				throw new ArgumentNullException ("nameSpace");
+			if (name == null)
+				throw new ArgumentNullException ("name");
 			if (self == null)
 				return false;
 
@@ -299,23 +257,22 @@ namespace Gendarme.Framework.Rocks {
 				return false;	// not enough information available
 
 			// special case, check if we implement ourselves
-			if (type.IsInterface && (type.FullName == interfaceName))
+			if (type.IsInterface && type.IsNamed (nameSpace, name))
 				return true;
 
-			return Implements (type, interfaceName, (interfaceName.IndexOf ('`') >= 0));
+			return Implements (type, nameSpace, name);
 		}
 
-		private static bool Implements (TypeDefinition type, string interfaceName, bool generic)
+		private static bool Implements (TypeDefinition type, string nameSpace, string iname)
 		{
 			while (type != null) {
 				// does the type implements it itself
 				if (type.HasInterfaces) {
 					foreach (TypeReference iface in type.Interfaces) {
-						string fullname = (generic) ? iface.GetElementType ().FullName : iface.FullName;
-						if (fullname == interfaceName)
+						if (iface.IsNamed (nameSpace, iname))
 							return true;
 						//if not, then maybe one of its parent interfaces does
-						if (Implements (iface.Resolve (), interfaceName, generic))
+						if (Implements (iface.Resolve (), nameSpace, iname))
 							return true;
 					}
 				}
@@ -331,21 +288,23 @@ namespace Gendarme.Framework.Rocks {
 		/// where the information resides could be unavailable.
 		/// </summary>
 		/// <param name="self">The TypeReference on which the extension method can be called.</param>
-		/// <param name="className">Full name of the base class</param>
+		/// <param name="nameSpace">The namespace of the base class to be matched</param>
+		/// <param name="name">The name of the base class to be matched</param>
 		/// <returns>True if the type inherits from specified class, False otherwise</returns>
-		public static bool Inherits (this TypeReference self, string className)
+		public static bool Inherits (this TypeReference self, string nameSpace, string name)
 		{
-			if (className == null)
-				throw new ArgumentNullException ("className");
+			if (nameSpace == null)
+				throw new ArgumentNullException ("nameSpace");
+			if (name == null)
+				throw new ArgumentNullException ("name");
 			if (self == null)
 				return false;
 
 			TypeReference current = self.Resolve ();
 			while (current != null) {
-				string fullname = current.FullName;
-				if (fullname == className)
+				if (current.IsNamed (nameSpace, name))
 					return true;
-				if (fullname == "System.Object")
+				if (current.IsNamed ("System", "Object"))
 					return false;
 
 				TypeDefinition td = current.Resolve ();
@@ -357,6 +316,70 @@ namespace Gendarme.Framework.Rocks {
 		}
 
 		/// <summary>
+		/// Check if the type and its namespace are named like the provided parameters.
+		/// This is preferred to checking the FullName property since the later can allocate (string) memory.
+		/// </summary>
+		/// <param name="self">The TypeReference on which the extension method can be called.</param>
+		/// <param name="nameSpace">The namespace to be matched</param>
+		/// <param name="name">The type name to be matched</param>
+		/// <returns>True if the type is namespace and name match the arguments, False otherwise</returns>
+		public static bool IsNamed (this TypeReference self, string nameSpace, string name)
+		{
+			if (nameSpace == null)
+				throw new ArgumentNullException ("nameSpace");
+			if (name == null)
+				throw new ArgumentNullException ("name");
+			if (self == null)
+				return false;
+
+			if (self.IsNested) {
+				int spos = name.LastIndexOf ('/');
+				if (spos == -1)
+					return false;
+				// GetFullName could be optimized away but it's a fairly uncommon case
+				return (nameSpace + "." + name == self.GetFullName ());
+			}
+
+			return ((self.Namespace == nameSpace) && (self.Name == name));
+		}
+
+		/// <summary>
+		/// Check if the type full name match the provided parameter.
+		/// Note: prefer the overload where the namespace and type name can be supplied individually
+		/// </summary>
+		/// <param name="self">The TypeReference on which the extension method can be called.</param>
+		/// <param name="fullName">The full name to be matched</param>
+		/// <returns>True if the type is namespace and name match the arguments, False otherwise</returns>
+		public static bool IsNamed (this TypeReference self, string fullName)
+		{
+			if (fullName == null)
+				throw new ArgumentNullException ("fullName");
+			if (self == null)
+				return false;
+
+			if (self.IsNested) {
+				int spos = fullName.LastIndexOf ('/');
+				if (spos == -1)
+					return false;
+				// FIXME: GetFullName could be optimized away but it's a fairly uncommon case
+				return (fullName == self.GetFullName ());
+			}
+
+			int dpos = fullName.LastIndexOf ('.');
+			string nspace = self.Namespace;
+			if (dpos != nspace.Length)
+				return false;
+
+			if (String.CompareOrdinal (nspace, 0, fullName, 0, dpos) != 0)
+				return false;
+
+			string name = self.Name;
+			if (fullName.Length - dpos - 1 != name.Length)
+				return false;
+			return (String.CompareOrdinal (name, 0, fullName, dpos + 1, fullName.Length - dpos - 1) == 0);
+		}
+
+		/// <summary>
 		/// Checks if type is attribute. Note that it is possible that
 		/// we might now be able to know all inheritance since the assembly where 
 		/// the information resides could be unavailable.
@@ -369,7 +392,7 @@ namespace Gendarme.Framework.Rocks {
 			if (self == null)
 				return false;
 
-			return self.Inherits ("System.Attribute");
+			return self.Inherits ("System", "Attribute");
 		}
 
 		/// <summary>
@@ -387,13 +410,11 @@ namespace Gendarme.Framework.Rocks {
 			if (null == type || type.BaseType == null)
 				return false;
 
-			switch (type.BaseType.FullName) {
-			case "System.Delegate":
-			case "System.MulticastDelegate":
-				return true;
-			default:
+			if (type.BaseType.Namespace != "System")
 				return false;
-			}
+
+			string name = type.BaseType.Name;
+			return ((name == "Delegate") || (name == "MulticastDelegate"));
 		}
 
 		/// <summary>
@@ -410,7 +431,7 @@ namespace Gendarme.Framework.Rocks {
 			if ((type == null) || !type.IsEnum || !type.HasCustomAttributes)
 				return false;
 
-			return type.HasAttribute ("System.FlagsAttribute");
+			return type.HasAttribute ("System", "FlagsAttribute");
 		}
 
 		/// <summary>
@@ -423,9 +444,11 @@ namespace Gendarme.Framework.Rocks {
 			if (self == null)
 				return false;
 
-			string full_name = self.FullName;
-			return ((full_name == "System.Single") ||
-				(full_name == "System.Double"));
+			if (self.Namespace != "System")
+				return false;
+
+			string name = self.Name;
+			return ((name == "Single") || (name == "Double"));
 		}
 
 		/// <summary>
@@ -443,7 +466,7 @@ namespace Gendarme.Framework.Rocks {
 				TypeDefinition type = self.Resolve ();
 				// both helpful attributes only exists in 2.0 and more recent frameworks
 				if (type.Module.Runtime >= TargetRuntime.Net_2_0) {
-					if (type.CustomAttributes.ContainsAnyType (CustomAttributeRocks.GeneratedCodeAttributes))
+					if (type.HasAnyGeneratedCodeAttribute ())
 						return true;
 				}
 			}
@@ -471,14 +494,11 @@ namespace Gendarme.Framework.Rocks {
 			if (self == null)
 				return false;
 
-			switch (self.FullName) {
-			case "System.IntPtr":
-			case "System.UIntPtr":
-			case "System.Runtime.InteropServices.HandleRef":
-				return true;
-			default:
-				return false;
+			if (self.Namespace == "System") {
+				string name = self.Name;
+				return ((name == "IntPtr") || (name == "UIntPtr"));
 			}
+			return self.IsNamed ("System.Runtime.InteropServices", "HandleRef");
 		}
 
 		/// <summary>
diff --git a/gendarme/framework/Gendarme.Framework.Rocks/VariableDefinitionRocks.cs b/gendarme/framework/Gendarme.Framework.Rocks/VariableDefinitionRocks.cs
index 6749ebd..73e03e4 100644
--- a/gendarme/framework/Gendarme.Framework.Rocks/VariableDefinitionRocks.cs
+++ b/gendarme/framework/Gendarme.Framework.Rocks/VariableDefinitionRocks.cs
@@ -24,8 +24,9 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
-using Mono.Cecil.Cil;
 using System;
+using System.Globalization;
+using Mono.Cecil.Cil;
 
 namespace Gendarme.Framework.Rocks {
 	
@@ -53,7 +54,7 @@ namespace Gendarme.Framework.Rocks {
 		{
 			if (self == null)
 				return String.Empty;
-			return !string.IsNullOrEmpty (self.Name) ? self.Name : "V_" + self.Index.ToString ();
+			return !string.IsNullOrEmpty (self.Name) ? self.Name : "V_" + self.Index.ToString (CultureInfo.InvariantCulture);
 		}
 	}
 }
diff --git a/gendarme/framework/Gendarme.Framework.csproj b/gendarme/framework/Gendarme.Framework.csproj
index f9976af..ff5851b 100755
--- a/gendarme/framework/Gendarme.Framework.csproj
+++ b/gendarme/framework/Gendarme.Framework.csproj
@@ -1,5 +1,5 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
-<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="3.5">
+<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="4.0">
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
     <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
@@ -12,9 +12,11 @@
     <AssemblyName>Gendarme.Framework</AssemblyName>
     <FileUpgradeFlags>
     </FileUpgradeFlags>
-    <OldToolsVersion>2.0</OldToolsVersion>
+    <OldToolsVersion>3.5</OldToolsVersion>
     <UpgradeBackupLocation>
     </UpgradeBackupLocation>
+    <IsWebBootstrapper>true</IsWebBootstrapper>
+    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
     <PublishUrl>http://localhost/Gendarme.Framework/</PublishUrl>
     <Install>true</Install>
     <InstallFrom>Web</InstallFrom>
@@ -27,10 +29,9 @@
     <MapFileExtensions>true</MapFileExtensions>
     <ApplicationRevision>0</ApplicationRevision>
     <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
-    <IsWebBootstrapper>true</IsWebBootstrapper>
     <UseApplicationTrust>false</UseApplicationTrust>
     <BootstrapperEnabled>true</BootstrapperEnabled>
-    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <TargetFrameworkProfile />
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
     <DebugSymbols>true</DebugSymbols>
@@ -41,6 +42,7 @@
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>3</WarningLevel>
     <StartupObject />
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
     <DebugType>pdbonly</DebugType>
@@ -50,6 +52,7 @@
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
     <StartupObject />
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <ItemGroup>
     <Reference Include="System" />
@@ -58,12 +61,17 @@
     </Reference>
   </ItemGroup>
   <ItemGroup>
+    <ProjectReference Include="..\..\..\cecil\Mono.Cecil.csproj">
+      <Project>{D68133BD-1E63-496E-9EDE-4FBDBF77B486}</Project>
+      <Name>Mono.Cecil</Name>
+    </ProjectReference>
   </ItemGroup>
   <ItemGroup>
     <Compile Include="..\AssemblyStaticInfo.cs" />
     <Compile Include="Gendarme.Framework.Engines\SuppressMessageEngine.cs" />
     <Compile Include="Gendarme.Framework.Helpers\Log.cs" />
     <Compile Include="Gendarme.Framework.Helpers\MethodPrinter.cs" />
+    <Compile Include="Gendarme.Framework.Helpers\StreamLineReader.cs" />
     <Compile Include="Gendarme.Framework.Rocks\ParameterRocks.cs" />
     <Compile Include="Gendarme.Framework.Rocks\PropertyRocks.cs" />
     <Compile Include="Gendarme.Framework.Rocks\VariableDefinitionRocks.cs" />
@@ -118,21 +126,34 @@
     <None Include="ChangeLog" />
   </ItemGroup>
   <ItemGroup>
+    <BootstrapperPackage Include="Microsoft.Net.Client.3.5">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1 Client Profile</ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
     <BootstrapperPackage Include="Microsoft.Net.Framework.2.0">
       <Visible>False</Visible>
+      <ProductName>
+      </ProductName>
+      <Install>false</Install>
     </BootstrapperPackage>
     <BootstrapperPackage Include="Microsoft.Net.Framework.3.0">
       <Visible>False</Visible>
+      <ProductName>
+      </ProductName>
+      <Install>false</Install>
     </BootstrapperPackage>
     <BootstrapperPackage Include="Microsoft.Net.Framework.3.5">
       <Visible>False</Visible>
+      <ProductName>
+      </ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1</ProductName>
+      <Install>false</Install>
     </BootstrapperPackage>
-  </ItemGroup>
-  <ItemGroup>
-    <ProjectReference Include="..\..\..\cecil\Mono.Cecil.csproj">
-      <Project>{D68133BD-1E63-496E-9EDE-4FBDBF77B486}</Project>
-      <Name>Mono.Cecil</Name>
-    </ProjectReference>
   </ItemGroup>
   <Import Project="$(MSBuildBinPath)\Microsoft.CSharp.targets" />
   <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
diff --git a/gendarme/framework/Gendarme.Framework/Symbols.cs b/gendarme/framework/Gendarme.Framework/Symbols.cs
index 5e76c20..f572643 100644
--- a/gendarme/framework/Gendarme.Framework/Symbols.cs
+++ b/gendarme/framework/Gendarme.Framework/Symbols.cs
@@ -39,7 +39,7 @@ namespace Gendarme.Framework {
 		// http://blogs.msdn.com/jmstall/archive/2005/06/19/FeeFee_SequencePoints.aspx
 		private const int PdbHiddenLine = 0xFEEFEE;
 
-		private static string AlmostEqualTo = new string (new char [] { '\u2248' });
+		private const string AlmostEqualTo = "\u2248";
 
 		private static Instruction ExtractFirst (TypeDefinition type)
 		{
@@ -55,7 +55,7 @@ namespace Gendarme.Framework {
 
 		private static Instruction ExtractFirst (MethodDefinition method)
 		{
-			if ((method == null) || !method.HasBody)
+			if ((method == null) || !method.HasBody || method.Body.Instructions.Count == 0)
 				return null;
 			Instruction ins = method.Body.Instructions [0];
 			// note that the first instruction often does not have a sequence point
@@ -69,11 +69,11 @@ namespace Gendarme.Framework {
 		{
 			MethodDefinition method = (location as MethodDefinition);
 			if (method != null)
-				return (method.DeclaringType as TypeDefinition);
+				return method.DeclaringType;
 
 			FieldDefinition field = (location as FieldDefinition);
 			if (field != null)
-				return (field.DeclaringType as TypeDefinition);
+				return field.DeclaringType;
 
 			ParameterDefinition parameter = (location as ParameterDefinition);
 			if (parameter != null)
@@ -112,7 +112,7 @@ namespace Gendarme.Framework {
 		// include line and column.
 		private static string FormatSequencePoint (string document, int line, int column, bool exact)
 		{
-			string sline = (line == PdbHiddenLine) ? "unavailable" : line.ToString ();
+			string sline = (line == PdbHiddenLine) ? "unavailable" : line.ToString (CultureInfo.InvariantCulture);
 
 			// MDB (mono symbols) does not provide any column information (so we don't show any)
 			// there's also no point in showing a column number if we're not totally sure about the line
@@ -177,7 +177,7 @@ namespace Gendarme.Framework {
 					return FormatSource (candidate);
 
 				// we may still be lucky to find the (a) source file for the type itself
-				type = (method.DeclaringType as TypeDefinition);
+				type = method.DeclaringType;
 			}
 
 			// TypeDefinition, FieldDefinition
diff --git a/gendarme/framework/Gendarme.Framework/ThreadModelAttribute.cs b/gendarme/framework/Gendarme.Framework/ThreadModelAttribute.cs
index e40e34c..4c76f63 100644
--- a/gendarme/framework/Gendarme.Framework/ThreadModelAttribute.cs
+++ b/gendarme/framework/Gendarme.Framework/ThreadModelAttribute.cs
@@ -27,6 +27,7 @@
 //
 
 using System;
+using System.Globalization;
 
 // Note that these types are extended version of what we recommend
 // that users use. See DecorateThreadsRule documentation for a smaller version
@@ -82,7 +83,7 @@ namespace Gendarme.Framework {
 		public override string ToString ()
 		{
 			if (AllowsEveryCaller)
-				return string.Format ("{0} | AllowEveryCaller", Model);
+				return String.Format (CultureInfo.InvariantCulture, "{0} | AllowEveryCaller", Model);
 				
 			return Model.ToString ();
 		}
@@ -96,9 +97,9 @@ namespace Gendarme.Framework {
 			return this == rhs;
 		}
 		
-		public bool Equals (ThreadModelAttribute rhs)
+		public bool Equals (ThreadModelAttribute other)
 		{
-			return this == rhs;
+			return this == other;
 		}
 		
 		public static bool operator== (ThreadModelAttribute lhs, ThreadModelAttribute rhs)
diff --git a/gendarme/framework/Makefile.am b/gendarme/framework/Makefile.am
index afbf5d9..13cbf9e 100644
--- a/gendarme/framework/Makefile.am
+++ b/gendarme/framework/Makefile.am
@@ -40,6 +40,7 @@ framework_sources =  \
 	Gendarme.Framework.Helpers/PrimitiveReferences.cs \
 	Gendarme.Framework.Helpers/StackEntryAnalysis.cs \
 	Gendarme.Framework.Helpers/StackEntryUsageResult.cs \
+	Gendarme.Framework.Helpers/StreamLineReader.cs \
 	Gendarme.Framework.Rocks/AssemblyRocks.cs \
 	Gendarme.Framework.Rocks/CecilRocks.cs \
 	Gendarme.Framework.Rocks/CommonRocks.cs \
@@ -86,7 +87,7 @@ framework_build_sources += $(framework_generated_sources)
 
 ../bin/Gendarme.Framework.dll: $(framework_build_sources) $(CECIL_ASM)
 	test -d ../bin || mkdir ../bin
-	$(GMCS) $(GENDARME_OPTIONS) -target:library -doc:$(framework_SCRIPTS).doc -r:$(CECIL_ASM) \
+	$(MCS) $(GENDARME_OPTIONS) -target:library -doc:$(framework_SCRIPTS).doc -r:$(CECIL_ASM) \
 		-out:$@ $(framework_build_sources)
 
 framework_test_sources = \
@@ -108,14 +109,14 @@ framework_test_sources = \
 framework_test_build_sources = $(addprefix $(srcdir)/Test/, $(framework_test_sources))
 
 Test.Framework.dll: $(framework_test_build_sources) $(framework_rules_SCRIPTS) ../bin/Gendarme.Framework.dll $(CECIL_ASM)
-	$(GMCS) $(TESTS_OPTIONS) -target:library -d:CODE_ANALYSIS -pkg:mono-nunit \
+	$(MCS) $(TESTS_OPTIONS) -target:library -d:CODE_ANALYSIS -pkg:mono-nunit \
 		-r:$(CECIL_ASM) -r:../bin/Gendarme.Framework.dll -r:../rules/Test.Rules/Test.Rules.dll \
 		-out:$@ $(framework_test_build_sources)
 
 test: Test.Framework.dll
 
 run-test: test
-	MONO_PATH=../bin/:../rules/Test.Rules/:$(MONO_PATH) nunit-console2 -noshadow Test.Framework.dll
+	MONO_PATH=../bin/:../rules/Test.Rules/:$(MONO_PATH) $(prefix)/bin/mono $(prefix)/lib/mono/4.0/nunit-console.exe Test.Framework.dll
 
 self-test: $(framework_SCRIPTS)
 	mono --debug ../bin/gendarme.exe $(framework_SCRIPTS)
diff --git a/gendarme/framework/Test/Gendarme.Framework.Rocks/AssemblyRocksTest.cs b/gendarme/framework/Test/Gendarme.Framework.Rocks/AssemblyRocksTest.cs
index c4bbafd..061bccd 100644
--- a/gendarme/framework/Test/Gendarme.Framework.Rocks/AssemblyRocksTest.cs
+++ b/gendarme/framework/Test/Gendarme.Framework.Rocks/AssemblyRocksTest.cs
@@ -49,16 +49,23 @@ namespace Test.Framework.Rocks {
 
 		[Test]
 		[ExpectedException (typeof (ArgumentNullException))]
-		public void HasAttribute_Null ()
+		public void HasAttribute_Namespace_Null ()
 		{
-			assembly.HasAttribute (null);
+			assembly.HasAttribute (null, "a");
+		}
+
+		[Test]
+		[ExpectedException (typeof (ArgumentNullException))]
+		public void HasAttribute_Name_Null ()
+		{
+			assembly.HasAttribute ("a", null);
 		}
 
 		[Test]
 		public void HasAttribute ()
 		{
-			Assert.IsTrue (assembly.HasAttribute ("System.Runtime.CompilerServices.RuntimeCompatibilityAttribute"), "System.Runtime.CompilerServices.RuntimeCompatibilityAttribute");
-			Assert.IsFalse (assembly.HasAttribute ("NUnit.Framework.TestFixtureAttribute"), "TestFixtureAttribute");
+			Assert.IsTrue (assembly.HasAttribute ("System.Runtime.CompilerServices", "RuntimeCompatibilityAttribute"), "System.Runtime.CompilerServices.RuntimeCompatibilityAttribute");
+			Assert.IsFalse (assembly.HasAttribute ("NUnit.Framework", "TestFixtureAttribute"), "TestFixtureAttribute");
 		}
 	}
 }
diff --git a/gendarme/framework/Test/Gendarme.Framework.Rocks/CustomAttributeRocksTest.cs b/gendarme/framework/Test/Gendarme.Framework.Rocks/CustomAttributeRocksTest.cs
index 65a868e..78c6f81 100644
--- a/gendarme/framework/Test/Gendarme.Framework.Rocks/CustomAttributeRocksTest.cs
+++ b/gendarme/framework/Test/Gendarme.Framework.Rocks/CustomAttributeRocksTest.cs
@@ -50,59 +50,29 @@ namespace Test.Framework.Rocks {
 
 		[Test]
 		[ExpectedException (typeof (ArgumentNullException))]
-		public void Contains_Null ()
-		{
-			Collection<CustomAttribute> cac = new Collection<CustomAttribute> ();
-			cac.ContainsType ((string) null);
-		}
-
-		[Test]
-		public void Contains ()
-		{
-			TypeDefinition type = assembly.MainModule.GetType ("Test.Framework.Rocks.CustomAttributeRocksTest");
-			Collection<CustomAttribute> cac = type.CustomAttributes;
-			Assert.IsTrue (cac.ContainsType ("NUnit.Framework.TestFixtureAttribute"), "NUnit.Framework.TestFixtureAttribute");
-			Assert.IsFalse (cac.ContainsType ("NUnit.Framework.TestFixture"), "NUnit.Framework.TestFixture");
-		}
-
-		[Test]
-		[ExpectedException (typeof (ArgumentNullException))]
-		public void ContainsAny_Null ()
-		{
-			Collection<CustomAttribute> cac = new Collection<CustomAttribute> ();
-			cac.ContainsAnyType (null);
-		}
-
-		[Test]
-		public void ContainsAny ()
+		public void HasAttribute_Namespace_Null ()
 		{
 			TypeDefinition type = assembly.MainModule.GetType ("Test.Framework.Rocks.CustomAttributeRocksTest");
-			Collection<CustomAttribute> cac = type.CustomAttributes;
-			Assert.IsTrue (cac.ContainsAnyType (new string[] {
-				"NUnit.Framework.TestFixtureAttribute",
-				null,
-				"System.ICloneable"
-			}), "NUnit.Framework.TestFixtureAttribute");
-			Assert.IsFalse (cac.ContainsAnyType (new string[] {}), "NUnit.Framework.TestFixture");
+			type.HasAttribute (null, "a");
 		}
 
 		[Test]
 		[ExpectedException (typeof (ArgumentNullException))]
-		public void HasAttribute_Null ()
+		public void HasAttribute_Name_Null ()
 		{
 			TypeDefinition type = assembly.MainModule.GetType ("Test.Framework.Rocks.CustomAttributeRocksTest");
-			type.HasAttribute (null);
+			type.HasAttribute ("a", null);
 		}
 		
 		[Test]
 		public void HasAttribute ()
 		{
 			TypeDefinition type = null;
-			Assert.IsFalse (type.HasAttribute ("NUnit.Framework.TestFixtureAttribute"), "null-type");
+			Assert.IsFalse (type.HasAttribute ("NUnit.Framework", "TestFixtureAttribute"), "null-type");
 
 			type = assembly.MainModule.GetType ("Test.Framework.Rocks.CustomAttributeRocksTest");
-			Assert.IsTrue (type.HasAttribute ("NUnit.Framework.TestFixtureAttribute"), "true");
-			Assert.IsFalse (type.HasAttribute ("NUnit.Framework.TestAttribute"), "false");
+			Assert.IsTrue (type.HasAttribute ("NUnit.Framework", "TestFixtureAttribute"), "true");
+			Assert.IsFalse (type.HasAttribute ("NUnit.Framework", "TestAttribute"), "false");
 		}
 	}
 }
diff --git a/gendarme/framework/Test/Gendarme.Framework.Rocks/FieldRocksTest.cs b/gendarme/framework/Test/Gendarme.Framework.Rocks/FieldRocksTest.cs
index a790ed2..69ea851 100644
--- a/gendarme/framework/Test/Gendarme.Framework.Rocks/FieldRocksTest.cs
+++ b/gendarme/framework/Test/Gendarme.Framework.Rocks/FieldRocksTest.cs
@@ -74,16 +74,23 @@ namespace Test.Framework.Rocks {
 
 		[Test]
 		[ExpectedException (typeof (ArgumentNullException))]
-		public void HasAttribute_Null ()
+		public void HasAttribute_Namespace_Null ()
 		{
-			GetField ("assembly").HasAttribute (null);
+			GetField ("assembly").HasAttribute (null, "a");
+		}
+
+		[Test]
+		[ExpectedException (typeof (ArgumentNullException))]
+		public void HasAttribute_Name_Null ()
+		{
+			GetField ("assembly").HasAttribute ("a", null);
 		}
 
 		[Test]
 		public void HasAttribute ()
 		{
-			Assert.IsTrue (GetField ("cga").HasAttribute ("System.Runtime.CompilerServices.CompilerGeneratedAttribute"), "CompilerGeneratedAttribute");
-			Assert.IsFalse (GetField ("cga").HasAttribute ("NUnit.Framework.TestFixtureAttribute"), "TestFixtureAttribute");
+			Assert.IsTrue (GetField ("cga").HasAttribute ("System.Runtime.CompilerServices", "CompilerGeneratedAttribute"), "CompilerGeneratedAttribute");
+			Assert.IsFalse (GetField ("cga").HasAttribute ("NUnit.Framework", "TestFixtureAttribute"), "TestFixtureAttribute");
 		}
 
 		[Test]
diff --git a/gendarme/framework/Test/Gendarme.Framework.Rocks/MethodRocksTest.cs b/gendarme/framework/Test/Gendarme.Framework.Rocks/MethodRocksTest.cs
index c43d680..3202358 100644
--- a/gendarme/framework/Test/Gendarme.Framework.Rocks/MethodRocksTest.cs
+++ b/gendarme/framework/Test/Gendarme.Framework.Rocks/MethodRocksTest.cs
@@ -112,18 +112,26 @@ namespace Test.Framework.Rocks {
 
 		[Test]
 		[ExpectedException (typeof (ArgumentNullException))]
-		public void HasAttribute_Null ()
+		public void HasAttribute_Namespace_Null ()
 		{
 			MethodDefinition method = GetMethod ("FixtureSetUp");
-			method.HasAttribute ((string) null);
+			method.HasAttribute (null, "a");
+		}
+
+		[Test]
+		[ExpectedException (typeof (ArgumentNullException))]
+		public void HasAttribute_Name_Null ()
+		{
+			MethodDefinition method = GetMethod ("FixtureSetUp");
+			method.HasAttribute ("a", null);
 		}
 
 		[Test]
 		public void HasAttribute ()
 		{
 			MethodDefinition method = GetMethod ("FixtureSetUp");
-			Assert.IsTrue (method.HasAttribute ("NUnit.Framework.TestFixtureSetUpAttribute"), "NUnit.Framework.TestFixtureSetUpAttribute");
-			Assert.IsFalse (method.HasAttribute ("NUnit.Framework.TestFixtureSetUp"), "NUnit.Framework.TestFixtureSetUp");
+			Assert.IsTrue (method.HasAttribute ("NUnit.Framework", "TestFixtureSetUpAttribute"), "NUnit.Framework.TestFixtureSetUpAttribute");
+			Assert.IsFalse (method.HasAttribute ("NUnit.Framework", "TestFixtureSetUp"), "NUnit.Framework.TestFixtureSetUp");
 		}
 
 		[Test]
diff --git a/gendarme/framework/Test/Gendarme.Framework.Rocks/RocksTest.cs b/gendarme/framework/Test/Gendarme.Framework.Rocks/RocksTest.cs
index ed62b9c..4c746fa 100644
--- a/gendarme/framework/Test/Gendarme.Framework.Rocks/RocksTest.cs
+++ b/gendarme/framework/Test/Gendarme.Framework.Rocks/RocksTest.cs
@@ -49,6 +49,9 @@ namespace Test.Framework.Rocks {
 			public abstract void PublicMethod ();
 			protected abstract void ProtectedMethod ();
 			private void PrivateMethod () { }
+
+			public abstract class NestedNestedPublicType {
+			}
 		}
 
 		protected abstract class NestedProtectedType {
diff --git a/gendarme/framework/Test/Gendarme.Framework.Rocks/TypeRocksTest.cs b/gendarme/framework/Test/Gendarme.Framework.Rocks/TypeRocksTest.cs
index 51f782f..99366be 100644
--- a/gendarme/framework/Test/Gendarme.Framework.Rocks/TypeRocksTest.cs
+++ b/gendarme/framework/Test/Gendarme.Framework.Rocks/TypeRocksTest.cs
@@ -179,20 +179,27 @@ namespace Test.Framework.Rocks {
 
 		[Test]
 		[ExpectedException (typeof (ArgumentNullException))]
-		public void HasAttribute_Null ()
+		public void HasAttribute_Namespace_Null ()
 		{
-			GetType (String.Empty).HasAttribute (null);
+			GetType (String.Empty).HasAttribute (null, "a");
+		}
+
+		[Test]
+		[ExpectedException (typeof (ArgumentNullException))]
+		public void HasAttribute_Name_Null ()
+		{
+			GetType (String.Empty).HasAttribute ("a", null);
 		}
 
 		[Test]
 		public void HasAttribute ()
 		{
-			Assert.IsTrue (GetType (String.Empty).HasAttribute ("NUnit.Framework.TestFixtureAttribute"), "TypeRocksTest");
-			Assert.IsFalse (GetType ("/Enum").HasAttribute ("System.FlagsAttribute"), "Enum/System.FlagsAttribute");
-			Assert.IsTrue (GetType ("/Flags").HasAttribute ("System.FlagsAttribute"), "Flags/System.FlagsAttribute");
+			Assert.IsTrue (GetType (String.Empty).HasAttribute ("NUnit.Framework", "TestFixtureAttribute"), "TypeRocksTest");
+			Assert.IsFalse (GetType ("/Enum").HasAttribute ("System", "FlagsAttribute"), "Enum/System.FlagsAttribute");
+			Assert.IsTrue (GetType ("/Flags").HasAttribute ("System", "FlagsAttribute"), "Flags/System.FlagsAttribute");
 			// fullname is required
-			Assert.IsFalse (GetType ("/Flags").HasAttribute ("System.Flags"), "Flags/System.Flags");
-			Assert.IsFalse (GetType ("/Flags").HasAttribute ("FlagsAttribute"), "Flags/FlagsAttribute");
+			Assert.IsFalse (GetType ("/Flags").HasAttribute ("System", "Flags"), "Flags/System.Flags");
+			Assert.IsFalse (GetType ("/Flags").HasAttribute ("", "FlagsAttribute"), "Flags/FlagsAttribute");
 		}
 
 		[Test]
@@ -204,51 +211,65 @@ namespace Test.Framework.Rocks {
 
 		[Test]
 		[ExpectedException (typeof (ArgumentNullException))]
-		public void Implements_Null ()
+		public void Implements_Namespace_Null ()
+		{
+			GetType (String.Empty).Implements (null, "a");
+		}
+
+		[Test]
+		[ExpectedException (typeof (ArgumentNullException))]
+		public void Implements_Name_Null ()
 		{
-			GetType (String.Empty).Implements (null);
+			GetType (String.Empty).Implements ("a", null);
 		}
 
 		[Test]
 		public void Implements ()
 		{
-			Assert.IsFalse (GetType (String.Empty).Implements ("System.ICloneable"), "ICloneable");
-			Assert.IsTrue (GetType ("/IDeepCloneable").Implements ("Test.Framework.Rocks.TypeRocksTest/IDeepCloneable"), "itself");
-			Assert.IsTrue (GetType ("/IDeepCloneable").Implements ("System.ICloneable"), "interface inheritance");
-			Assert.IsTrue (GetType ("/Deep").Implements ("Test.Framework.Rocks.TypeRocksTest/IDeepCloneable"), "IDeepCloneable");
-			Assert.IsTrue (GetType ("/Deep").Implements ("System.ICloneable"), "second-level ICloneable");
-			Assert.IsTrue (GetType ("/Mixin").Implements ("Test.Framework.Rocks.TypeRocksTest/IDeepCloneable"), "parent interface inheritance");
+			Assert.IsFalse (GetType (String.Empty).Implements ("System", "ICloneable"), "ICloneable");
+			Assert.IsTrue (GetType ("/IDeepCloneable").Implements ("Test.Framework.Rocks", "TypeRocksTest/IDeepCloneable"), "itself");
+			Assert.IsTrue (GetType ("/IDeepCloneable").Implements ("System", "ICloneable"), "interface inheritance");
+			Assert.IsTrue (GetType ("/Deep").Implements ("Test.Framework.Rocks", "TypeRocksTest/IDeepCloneable"), "IDeepCloneable");
+			Assert.IsTrue (GetType ("/Deep").Implements ("System", "ICloneable"), "second-level ICloneable");
+			Assert.IsTrue (GetType ("/Mixin").Implements ("Test.Framework.Rocks", "TypeRocksTest/IDeepCloneable"), "parent interface inheritance");
 		}
 
 		[Test]
 		[ExpectedException (typeof (ArgumentNullException))]
-		public void Inherits_Null ()
+		public void Inherits_Namespace_Null ()
 		{
-			GetType (String.Empty).Inherits (null);
+			GetType (String.Empty).Inherits (null, "a");
+		}
+
+		[Test]
+		[ExpectedException (typeof (ArgumentNullException))]
+		public void Inherits_Name_Null ()
+		{
+			GetType (String.Empty).Inherits ("a", null);
 		}
 
 		[Test]
 		public void Inherits ()
 		{
-			Assert.IsFalse (GetType ("/NotAttribute").Inherits ("System.Attribute"), "NotAttribute");
-			Assert.IsTrue (GetType ("/AnAttribute").Inherits ("System.Attribute"), "AnAttribute");
-			Assert.IsFalse (GetType ("/ClassInheritsNotAttribute").Inherits ("System.Attribute"), "ClassInheritsNotAttribute");
-			Assert.IsTrue (GetType ("/AttributeInheritsAnAttribute").Inherits ("System.Attribute"), "AttributeInheritsAnAttribute");
+			Assert.IsFalse (GetType ("/NotAttribute").Inherits ("System", "Attribute"), "NotAttribute");
+			Assert.IsTrue (GetType ("/AnAttribute").Inherits ("System", "Attribute"), "AnAttribute");
+			Assert.IsFalse (GetType ("/ClassInheritsNotAttribute").Inherits ("System", "Attribute"), "ClassInheritsNotAttribute");
+			Assert.IsTrue (GetType ("/AttributeInheritsAnAttribute").Inherits ("System", "Attribute"), "AttributeInheritsAnAttribute");
 		}
 
 		[Test]
 		public void Inherits_FromAnotherAssembly ()
 		{
 			// we can't be sure here so to avoid false positives return false
-			Assert.IsTrue (GetType ("/AttributeInheritsOuterAttribute").Inherits ("System.Attribute"), "AttributeInheritsOuterAttribute");
-			Assert.IsTrue (GetType ("/AttributeInheritsOuterAttributeDerivingAttribute").Inherits ("System.Attribute"), "AttributeInheritsOuterAttributeDerivingAttribute");
+			Assert.IsTrue (GetType ("/AttributeInheritsOuterAttribute").Inherits ("System", "Attribute"), "AttributeInheritsOuterAttribute");
+			Assert.IsTrue (GetType ("/AttributeInheritsOuterAttributeDerivingAttribute").Inherits ("System", "Attribute"), "AttributeInheritsOuterAttributeDerivingAttribute");
 		}
 
 		[Test]
 		public void Inherits_Itself ()
 		{
 			TypeDefinition type = GetType (String.Empty);
-			Assert.IsTrue (type.Inherits (type.FullName), "itself");
+			Assert.IsTrue (type.Inherits (type.Namespace, type.Name), "itself");
 		}
 
 		[Test]
@@ -322,6 +343,50 @@ namespace Test.Framework.Rocks {
 		}
 
 		[Test]
+		public void IsNamed ()
+		{
+			string name = "Test.Framework.Rocks.PublicType";
+			TypeDefinition type = assembly.MainModule.GetType (name);
+
+			Assert.IsTrue (type.IsNamed ( "Test.Framework.Rocks.PublicType"));
+			Assert.IsFalse (type.IsNamed ("Test.Framework.Rocks.P"));//Missing Text
+			Assert.IsFalse (type.IsNamed ("Test.Framework.Rocks.PublicTypeExtraText"));
+
+			Assert.IsTrue (type.IsNamed ("Test.Framework.Rocks", "PublicType"));
+			Assert.IsFalse (type.IsNamed ("Test.Framework.Rocks", "P"));//Missing Text
+			Assert.IsFalse (type.IsNamed ("Test.Framework.Rocks", "PublicTypeExtraText"));
+		}
+
+		[Test]
+		public void IsNamedNestedType ()
+		{
+			string name = "Test.Framework.Rocks.PublicType/NestedPublicType";
+			TypeDefinition type = assembly.MainModule.GetType (name);
+
+			Assert.IsTrue (type.IsNamed ("Test.Framework.Rocks.PublicType/NestedPublicType"));
+			Assert.IsFalse (type.IsNamed ("Test.Framework.Rocks.PublicType/N"));//Missing Text
+			Assert.IsFalse (type.IsNamed ("Test.Framework.Rocks.PublicType/NestedPublicTypeExtaStuff"));
+
+			Assert.IsTrue (type.IsNamed ("Test.Framework.Rocks", "PublicType/NestedPublicType"));
+			Assert.IsFalse (type.IsNamed ("Test.Framework.Rocks", "PublicType/N"));//Missing Text
+			Assert.IsFalse (type.IsNamed ("Test.Framework.Rocks", "PublicType/NestedPublicTypeExtraText"));
+
+			Assert.IsFalse (type.IsNamed ("Test.Framework.Rocks", "NestedPublicType"));
+			Assert.IsFalse (type.IsNamed ("", "NestedPublicType"));
+		}
+
+		[Test]
+		public void IsNamedDoubleNestedType ()
+		{
+			string name = "Test.Framework.Rocks.PublicType/NestedPublicType/NestedNestedPublicType";
+			TypeDefinition type = assembly.MainModule.GetType (name);
+
+			Assert.IsTrue (type.IsNamed ("Test.Framework.Rocks.PublicType/NestedPublicType/NestedNestedPublicType"));
+			
+			Assert.IsTrue (type.IsNamed ("Test.Framework.Rocks", "PublicType/NestedPublicType/NestedNestedPublicType"));
+		}
+
+		[Test]
 		public void IsVisible ()
 		{
 			string name = "Test.Framework.Rocks.PublicType";
diff --git a/gendarme/man/gendarme.1.in b/gendarme/man/gendarme.1.in
index 0389780..cc1989f 100644
--- a/gendarme/man/gendarme.1.in
+++ b/gendarme/man/gendarme.1.in
@@ -33,8 +33,7 @@ Specify the rule sets and rule settings. Default is 'rules.xml'.
 Specify a rule set from configfile. Defaults to 'default'.
 .TP
 .I "--log file"
-Save the report to the specified file. If none of --log, --xml, or --html are used
-then the report is written to stdout.
+Save the report, as a text file, to the specified file.
 .TP
 .I "--xml file"
 Save the report, formatted as XML, to the specified file.
@@ -42,6 +41,11 @@ Save the report, formatted as XML, to the specified file.
 .I "--html file"
 Save the report, formatted as HTML, to the specified file.
 .TP
+.I "--console"
+Write the defects on stdout. This is the default (implicit) behavior if none of
+--log, --xml, or --html options are specified. If (explicitely) specified then 
+the defects will be shown on both stdout and inside text/xml/html report(s).
+.TP
 .I "--ignore ignore-file"
 Do not report defects listed in the specified file.
 .TP
diff --git a/gendarme/mono-options.ignore b/gendarme/mono-options.ignore
index c48ca1a..aa1799a 100644
--- a/gendarme/mono-options.ignore
+++ b/gendarme/mono-options.ignore
@@ -67,3 +67,15 @@ T: NDesk.Options.OptionSet
 R: Gendarme.Rules.Smells.AvoidCodeDuplicatedInSameClassRule
 T: NDesk.Options.OptionSet
 
+R: Gendarme.Rules.Globalization.PreferStringComparisonOverrideRule
+M: System.String NDesk.Options.OptionSet::GetArgumentName(System.Int32,System.Int32,System.String)
+
+R: Gendarme.Rules.Globalization.PreferIFormatProviderOverrideRule
+M: System.Void NDesk.Options.Option::AddSeparators(System.String,System.Int32,System.Collections.Generic.ICollection`1<System.String>)
+M: System.Boolean NDesk.Options.OptionSet::ParseBundledValue(System.String,System.String,NDesk.Options.OptionContext)
+M: System.Void NDesk.Options.OptionValueCollection::AssertValid(System.Int32)
+M: System.Void NDesk.Options.Option::.ctor(System.String,System.String,System.Int32)
+M: NDesk.Options.OptionValueType NDesk.Options.Option::ParsePrototype()
+M: T NDesk.Options.Option::Parse(System.String,NDesk.Options.OptionContext)
+M: System.Void NDesk.Options.OptionSet::ParseValue(System.String,NDesk.Options.OptionContext)
+
diff --git a/gendarme/rules/Gendarme.Rules.BadPractice/AvoidAssemblyVersionMismatchRule.cs b/gendarme/rules/Gendarme.Rules.BadPractice/AvoidAssemblyVersionMismatchRule.cs
index 3b2ba33..dc43d09 100644
--- a/gendarme/rules/Gendarme.Rules.BadPractice/AvoidAssemblyVersionMismatchRule.cs
+++ b/gendarme/rules/Gendarme.Rules.BadPractice/AvoidAssemblyVersionMismatchRule.cs
@@ -25,6 +25,7 @@
 // THE SOFTWARE.
 
 using System;
+using System.Globalization;
 
 using Mono.Cecil;
 using Mono.Cecil.Cil;
@@ -61,26 +62,6 @@ namespace Gendarme.Rules.BadPractice {
 	[Solution ("This situation can be confusing once deployed. Make sure both version are identical.")]
 	public class AvoidAssemblyVersionMismatchRule : Rule, IAssemblyRule {
 
-		static bool VersionTryParse (string input, out Version result)
-		{
-			result = null;
-			if (String.IsNullOrEmpty (input))
-				return false;
-
-			try {
-				result = new Version (input);
-				return true;
-			}
-			catch (ArgumentException) {
-				// also cover ArgumentOutOfRangeException
-			}
-			catch (FormatException) {
-			}
-			catch (OverflowException) {
-			}
-			return false;
-		}
-
 		public RuleResult CheckAssembly (AssemblyDefinition assembly)
 		{
 			if (!assembly.HasCustomAttributes)
@@ -100,11 +81,10 @@ namespace Gendarme.Rules.BadPractice {
 				// any attribute without arguments can be skipped
 				if (!ca.HasConstructorArguments)
 					continue;
-				if (ca.AttributeType.FullName != "System.Reflection.AssemblyFileVersionAttribute")
+				if (!ca.AttributeType.IsNamed ("System.Reflection", "AssemblyFileVersionAttribute"))
 					continue;
 
-				// FIXME: replace with Version.TryParse once we upgrade to FX4.0
-				VersionTryParse (ca.ConstructorArguments [0].Value as string, out file_version);
+				Version.TryParse (ca.ConstructorArguments [0].Value as string, out file_version);
 				break;
 			}
 
@@ -127,9 +107,11 @@ namespace Gendarme.Rules.BadPractice {
 			else if (assembly_version.Revision == file_version.Revision)
 				return RuleResult.Success;
 
-			string msg = String.Format ("Assembly version is '{0}' while file version is '{1}'.", assembly_version, file_version);
+			string msg = String.Format (CultureInfo.InvariantCulture,
+				"Assembly version is '{0}' while file version is '{1}'.", assembly_version, file_version);
 			Runner.Report (assembly, s, Confidence.High, msg);
 			return RuleResult.Failure;
 		}
 	}
 }
+
diff --git a/gendarme/rules/Gendarme.Rules.BadPractice/AvoidCallingProblematicMethodsRule.cs b/gendarme/rules/Gendarme.Rules.BadPractice/AvoidCallingProblematicMethodsRule.cs
index 777cc02..87d00c2 100644
--- a/gendarme/rules/Gendarme.Rules.BadPractice/AvoidCallingProblematicMethodsRule.cs
+++ b/gendarme/rules/Gendarme.Rules.BadPractice/AvoidCallingProblematicMethodsRule.cs
@@ -27,8 +27,9 @@
 //
 
 using System;
-using System.Reflection;
+using System.Globalization;
 using System.Collections.Generic;
+using System.Reflection;
 
 using Mono.Cecil;
 using Mono.Cecil.Cil;
@@ -100,22 +101,22 @@ namespace Gendarme.Rules.BadPractice {
 		public AvoidCallingProblematicMethodsRule ()
 		{
 			problematicMethods.Add ("Collect", (m, i) => 
-				(m.DeclaringType.FullName == "System.GC") ? Severity.Critical : (Severity?) null);
+				m.DeclaringType.IsNamed ("System", "GC") ? Severity.Critical : (Severity?) null);
 			problematicMethods.Add ("Suspend", (m, i) => 
-				(m.DeclaringType.FullName == "System.Threading.Thread") ? Severity.Medium : (Severity?) null);
+				m.DeclaringType.IsNamed ("System.Threading", "Thread") ? Severity.Medium : (Severity?) null);
 			problematicMethods.Add ("Resume", (m, i) => 
-				(m.DeclaringType.FullName == "System.Threading.Thread") ? Severity.Medium : (Severity?) null);
+				m.DeclaringType.IsNamed ("System.Threading", "Thread") ? Severity.Medium : (Severity?) null);
 			problematicMethods.Add ("DangerousGetHandle", (m, i) => 
-				(m.DeclaringType.FullName == "System.Runtime.InteropServices.SafeHandle") ? Severity.Critical : (Severity?) null);
+				m.DeclaringType.IsNamed ("System.Runtime.InteropServices", "SafeHandle") ? Severity.Critical : (Severity?) null);
 			problematicMethods.Add ("LoadFrom", (m, i) => 
-				(m.DeclaringType.FullName == "System.Reflection.Assembly") ? Severity.High : (Severity?) null);
+				m.DeclaringType.IsNamed ("System.Reflection", "Assembly") ? Severity.High : (Severity?) null);
 			problematicMethods.Add ("LoadFile", (m, i) => 
-				(m.DeclaringType.FullName == "System.Reflection.Assembly") ? Severity.High : (Severity?) null);
+				m.DeclaringType.IsNamed ("System.Reflection", "Assembly") ? Severity.High : (Severity?) null);
 			problematicMethods.Add ("LoadWithPartialName", (m, i) => 
-				(m.DeclaringType.FullName == "System.Reflection.Assembly") ? Severity.High : (Severity?) null);
+				m.DeclaringType.IsNamed ("System.Reflection", "Assembly") ? Severity.High : (Severity?) null);
 			problematicMethods.Add ("InvokeMember", (m, i) => 
-				(m.DeclaringType.FullName != "System.Type") ? (Severity?) null :
-				IsAccessingWithNonPublicModifiers (i) ? Severity.Critical : (Severity?) null);
+				!m.DeclaringType.IsNamed ("System", "Type") ? (Severity?) null :
+					IsAccessingWithNonPublicModifiers (i) ? Severity.Critical : (Severity?) null);
 		}
 
 		private static bool OperandIsNonPublic (BindingFlags operand)
@@ -166,7 +167,8 @@ namespace Gendarme.Rules.BadPractice {
 
 				Severity? severity = IsProblematicCall (instruction);
 				if (severity.HasValue) {
-					string msg = String.Format ("You are calling to {0}, which is a potentially problematic method", 
+					string msg = String.Format (CultureInfo.InvariantCulture,
+						"You are calling to {0}, which is a potentially problematic method", 
 						instruction.Operand);
 					Runner.Report (method, instruction, severity.Value, Confidence.High, msg);
 				}
diff --git a/gendarme/rules/Gendarme.Rules.BadPractice/AvoidNullCheckWithAsOperatorRule.cs b/gendarme/rules/Gendarme.Rules.BadPractice/AvoidNullCheckWithAsOperatorRule.cs
new file mode 100644
index 0000000..26394d9
--- /dev/null
+++ b/gendarme/rules/Gendarme.Rules.BadPractice/AvoidNullCheckWithAsOperatorRule.cs
@@ -0,0 +1,141 @@
+//
+// Gendarme.Rules.BadPractice.AvoidNullCheckWithAsOperatorRule
+//
+// Authors:
+//	Sebastien Pouliot <sebastien@ximian.com>
+//
+// Copyright (C) 2011 Novell, Inc (http://www.novell.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+
+using Mono.Cecil;
+using Mono.Cecil.Cil;
+
+using Gendarme.Framework;
+using Gendarme.Framework.Engines;
+using Gendarme.Framework.Helpers;
+using Gendarme.Framework.Rocks;
+
+namespace Gendarme.Rules.BadPractice {
+
+	/// <summary>
+	/// The rule will detect if a null check is done before using the <c>as</c> operator. 
+	/// This null check is not needed, a <c>null</c> instance will return <c>null</c>,
+	/// and the code will need to deal with <c>as</c> returning a null value anyway.
+	/// </summary>
+	/// <example>
+	/// Bad example:
+	/// <code>
+	/// public string AsString (object obj)
+	/// {
+	///	return (o == null) ? null : o as string;
+	/// }
+	/// </code>
+	/// </example>
+	/// <example>
+	/// Good example:
+	/// <code>
+	/// public string AsString (object obj)
+	/// {
+	///	return (o as string);
+	/// }
+	/// </code>
+	/// </example>
+	// as suggested in https://bugzilla.novell.com/show_bug.cgi?id=651305
+	[Problem ("An unneeded null check is done before using the 'as' operator.")]
+	[Solution ("Remove the extraneous null check")]
+	[EngineDependency (typeof (OpCodeEngine))]
+	public class AvoidNullCheckWithAsOperatorRule : Rule, IMethodRule {
+
+		OpCodeBitmask mask = new OpCodeBitmask (0x100000, 0x10000000000000, 0x0, 0x0);
+
+		static bool CheckFalseBranch (Instruction ins)
+		{
+			Instruction next = ins.Next;
+			if (!next.Is (ins.Previous.OpCode.Code))
+				return false;
+
+			if (!(ins.Operand as Instruction).Is (Code.Ldnull))
+				return false;
+
+			return CheckIsinst (next.Next);
+		}
+
+		static bool CheckTrueBranch (Instruction ins)
+		{
+			if (!ins.Next.Is (Code.Ldnull))
+				return false;
+
+			Instruction br = (ins.Operand as Instruction);
+			if (ins.Previous.OpCode.Code != br.OpCode.Code)
+				return false;
+
+			return CheckIsinst (br.Next);
+		}
+
+		static bool CheckIsinst (Instruction ins)
+		{
+			if (!ins.Is (Code.Isinst))
+				return false;
+			return (ins.Next.OpCode.FlowControl != FlowControl.Cond_Branch);
+		}
+
+		public RuleResult CheckMethod (MethodDefinition method)
+		{
+			// rule only applies to methods with IL...
+			if (!method.HasBody)
+				return RuleResult.DoesNotApply;
+
+			// and when the IL contains both a isinst and ldnull
+			if (!mask.IsSubsetOf (OpCodeEngine.GetBitmask (method)))
+				return RuleResult.DoesNotApply;
+
+			foreach (Instruction ins in method.Body.Instructions) {
+				bool detected = false;
+				switch (ins.OpCode.Code) {
+				case Code.Brfalse_S:
+				case Code.Brfalse:
+					detected = CheckFalseBranch (ins);
+					break;
+				case Code.Brtrue_S:
+				case Code.Brtrue:
+					detected = CheckTrueBranch (ins);
+					break;
+				}
+				if (detected)
+					Runner.Report (method, ins, Severity.Medium, Confidence.Normal);
+			}
+
+			return Runner.CurrentRuleResult;
+		}
+#if false
+		public void Bitmask ()
+		{
+			OpCodeBitmask mask = new OpCodeBitmask ();
+			mask.Set (Code.Isinst);
+			mask.Set (Code.Ldnull);
+			Console.WriteLine (mask);
+		}
+#endif
+	}
+}
diff --git a/gendarme/rules/Gendarme.Rules.BadPractice/AvoidVisibleConstantFieldRule.cs b/gendarme/rules/Gendarme.Rules.BadPractice/AvoidVisibleConstantFieldRule.cs
index 0831682..c18be47 100644
--- a/gendarme/rules/Gendarme.Rules.BadPractice/AvoidVisibleConstantFieldRule.cs
+++ b/gendarme/rules/Gendarme.Rules.BadPractice/AvoidVisibleConstantFieldRule.cs
@@ -24,6 +24,8 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
+using System.Globalization;
+
 using Mono.Cecil;
 using Mono.Cecil.Cil;
 
@@ -80,11 +82,12 @@ namespace Gendarme.Rules.BadPractice {
 
 				// we let null constant for all reference types (since they can't be changed to anything else)
 				// except for strings (which can be modified later)
-				string type_name = field.FieldType.FullName;
-				if (!field.FieldType.IsValueType && (type_name != "System.String"))
+				TypeReference ftype = field.FieldType;
+				if (!ftype.IsValueType && !ftype.IsNamed ("System", "String"))
 					continue;
 
-				string msg = string.Format ("'{0}' of type {1}.", field.Name, type_name);
+				string msg = string.Format (CultureInfo.InvariantCulture, "'{0}' of type {1}.", 
+					field.Name, ftype.GetFullName ());
 				Runner.Report (field, Severity.High, Confidence.High, msg);
 
 			}
diff --git a/gendarme/rules/Gendarme.Rules.BadPractice/CheckNewExceptionWithoutThrowingRule.cs b/gendarme/rules/Gendarme.Rules.BadPractice/CheckNewExceptionWithoutThrowingRule.cs
index e40aed6..183a18c 100644
--- a/gendarme/rules/Gendarme.Rules.BadPractice/CheckNewExceptionWithoutThrowingRule.cs
+++ b/gendarme/rules/Gendarme.Rules.BadPractice/CheckNewExceptionWithoutThrowingRule.cs
@@ -96,7 +96,7 @@ namespace Gendarme.Rules.BadPractice {
 
 				MethodReference constructor = (MethodReference) ins.Operand;
 
-				if (!constructor.DeclaringType.Inherits ("System.Exception"))
+				if (!constructor.DeclaringType.Inherits ("System", "Exception"))
 					continue;
 
 				// quick check to save resources
diff --git a/gendarme/rules/Gendarme.Rules.BadPractice/CheckNewThreadWithoutStartRule.cs b/gendarme/rules/Gendarme.Rules.BadPractice/CheckNewThreadWithoutStartRule.cs
index 3f01bb1..ac0c146 100644
--- a/gendarme/rules/Gendarme.Rules.BadPractice/CheckNewThreadWithoutStartRule.cs
+++ b/gendarme/rules/Gendarme.Rules.BadPractice/CheckNewThreadWithoutStartRule.cs
@@ -110,8 +110,6 @@ namespace Gendarme.Rules.BadPractice {
 			return false;
 		}
 
-		private const string Thread = "System.Threading.Thread";
-
 		public override void Initialize (IRunner runner)
 		{
 			base.Initialize (runner);
@@ -119,8 +117,10 @@ namespace Gendarme.Rules.BadPractice {
 			// if the module does not reference (sealed) System.Threading.Thread 
 			// then no code inside the module will instanciate it
 			Runner.AnalyzeModule += delegate (object o, RunnerEventArgs e) {
-				Active = (e.CurrentAssembly.Name.Name == "mscorlib") ||
-					e.CurrentModule.HasTypeReference (Thread);
+				Active = (e.CurrentAssembly.Name.Name == "mscorlib" ||
+					e.CurrentModule.AnyTypeReference ((TypeReference tr) => {
+						return tr.IsNamed ("System.Threading", "Thread");
+					}));
 			};
 		}
 
@@ -141,11 +141,11 @@ namespace Gendarme.Rules.BadPractice {
 
 				MethodReference constructor = (MethodReference) ins.Operand;
 
-				if (constructor.DeclaringType.FullName != Thread)
+				if (!constructor.DeclaringType.IsNamed ("System.Threading", "Thread"))
 					continue;
 				if (ins.Next != null && (ins.Next.OpCode.Code == Code.Call || ins.Next.OpCode.Code == Code.Callvirt)) { //quick check to safe resources
 					MethodReference calledMethod = (MethodReference) ins.Next.Operand;
-					if ((calledMethod.DeclaringType.FullName == Thread) && (calledMethod.Name == "Start"))
+					if (calledMethod.IsNamed ("System.Threading", "Thread", "Start"))
 						continue;
 				}
 
diff --git a/gendarme/rules/Gendarme.Rules.BadPractice/CloneMethodShouldNotReturnNullRule.cs b/gendarme/rules/Gendarme.Rules.BadPractice/CloneMethodShouldNotReturnNullRule.cs
index eff7ae0..e740a02 100644
--- a/gendarme/rules/Gendarme.Rules.BadPractice/CloneMethodShouldNotReturnNullRule.cs
+++ b/gendarme/rules/Gendarme.Rules.BadPractice/CloneMethodShouldNotReturnNullRule.cs
@@ -69,8 +69,6 @@ namespace Gendarme.Rules.BadPractice {
 	[Solution ("Return an appropriate object instead of returning null.")]
 	public class CloneMethodShouldNotReturnNullRule : ReturnNullRule, IMethodRule {
 
-		private const string ICloneable = "System.ICloneable";
-
 		public override void Initialize (IRunner runner)
 		{
 			base.Initialize (runner);
@@ -78,8 +76,10 @@ namespace Gendarme.Rules.BadPractice {
 			// if the module does not reference System.ICloneable then
 			// no type inside will be implementing it
 			Runner.AnalyzeModule += delegate (object o, RunnerEventArgs e) {
-				Active = (e.CurrentAssembly.Name.Name == "mscorlib") ||
-					e.CurrentModule.HasTypeReference (ICloneable);
+				Active = (e.CurrentAssembly.Name.Name == "mscorlib" ||
+					e.CurrentModule.AnyTypeReference ((TypeReference tr) => {
+						return tr.IsNamed ("System", "ICloneable");
+					}));
 			};
 		}
 
@@ -90,7 +90,7 @@ namespace Gendarme.Rules.BadPractice {
 				return RuleResult.DoesNotApply;
 
 			// where the type implements ICloneable
-			if (!method.DeclaringType.Implements (ICloneable))
+			if (!method.DeclaringType.Implements ("System", "ICloneable"))
 				return RuleResult.DoesNotApply;
 
 			// call base class to detect if the method can return null
diff --git a/gendarme/rules/Gendarme.Rules.BadPractice/ConstructorShouldNotCallVirtualMethodsRule.cs b/gendarme/rules/Gendarme.Rules.BadPractice/ConstructorShouldNotCallVirtualMethodsRule.cs
index d3758bb..7f47cf5 100644
--- a/gendarme/rules/Gendarme.Rules.BadPractice/ConstructorShouldNotCallVirtualMethodsRule.cs
+++ b/gendarme/rules/Gendarme.Rules.BadPractice/ConstructorShouldNotCallVirtualMethodsRule.cs
@@ -28,6 +28,7 @@
 
 using System;
 using System.Collections.Generic;
+using System.Globalization;
 using System.Linq;
 
 using Mono.Cecil;
@@ -177,7 +178,7 @@ namespace Gendarme.Rules.BadPractice {
 						if (mr.HasThis)
 							parameters++;
 						parameters += mr.Parameters.Count;
-						if (mr.ReturnType.FullName != "System.Void")
+						if (!mr.ReturnType.IsNamed ("System", "Void"))
 							parameters--;
 					}
 					break;
@@ -196,7 +197,7 @@ namespace Gendarme.Rules.BadPractice {
 			if (!OpCodeBitmask.Calls.Intersect (OpCodeEngine.GetBitmask (method)))
 				return;
 
-			string method_name = method.ToString ();
+			string method_name = method.GetFullName ();
 			// check to avoid constructors calling recursive methods
 			if (stack.Contains (method_name))
 				return;
@@ -216,12 +217,14 @@ namespace Gendarme.Rules.BadPractice {
 						continue;
 
 					// check that we're not calling the method on another object
-					if (!IsCallFromInstance (current.Previous, md.Parameters.Count))
+					int n = md.HasParameters ? md.Parameters.Count : 0;
+					if (!IsCallFromInstance (current.Previous, n))
 						continue;
 
 					if (md.IsVirtual && !md.IsFinal) {
 						string s = stack.Count == 0 ? method_name : stack.Aggregate ((a1, a2) => a1 + ", " + Environment.NewLine + a2);
-						s = String.Format ("Calling a virtual method, '{0}' from {1}.", md, s);
+						s = String.Format (CultureInfo.InvariantCulture,
+							"Calling a virtual method, '{0}' from {1}.", md, s);
 						Runner.Report (method, current, Severity.High, Confidence.High, s);
 					} else {
 						stack.Push (method_name);
diff --git a/gendarme/rules/Gendarme.Rules.BadPractice/DisableDebuggingCodeRule.cs b/gendarme/rules/Gendarme.Rules.BadPractice/DisableDebuggingCodeRule.cs
index f1c6049..9534ca5 100644
--- a/gendarme/rules/Gendarme.Rules.BadPractice/DisableDebuggingCodeRule.cs
+++ b/gendarme/rules/Gendarme.Rules.BadPractice/DisableDebuggingCodeRule.cs
@@ -89,9 +89,6 @@ namespace Gendarme.Rules.BadPractice {
 	[EngineDependency (typeof (OpCodeEngine))]
 	public class DisableDebuggingCodeRule : Rule, IMethodRule {
 
-		private const string ConditionalAttribute = "System.Diagnostics.ConditionalAttribute";
-		private const string Console = "System.Console";
-
 		// note: there can be multiple [Conditional] attribute on a method
 		private static bool HasConditionalAttributeForDebugging (IList<CustomAttribute> cac)
 		{
@@ -101,7 +98,7 @@ namespace Gendarme.Rules.BadPractice {
 				// any attribute without arguments can be skipped
 				if (!ca.HasConstructorArguments)
 					continue;
-				if (ca.AttributeType.FullName == ConditionalAttribute) {
+				if (ca.AttributeType.IsNamed ("System.Diagnostics", "ConditionalAttribute")) {
 					switch (ca.ConstructorArguments [0].Value as string) {
 					case "DEBUG":
 					case "TRACE":
@@ -126,7 +123,9 @@ namespace Gendarme.Rules.BadPractice {
 					// if the module does not reference System.Console then no
 					// method inside it will be calling any Console.write* methods
 					(e.CurrentAssembly.Name.Name == "mscorlib" ||
-					e.CurrentModule.HasTypeReference (Console));
+					e.CurrentModule.AnyTypeReference ((TypeReference tr) => {
+						return tr.IsNamed ("System", "Console");
+					}));
 			};
 		}
 
@@ -152,8 +151,12 @@ namespace Gendarme.Rules.BadPractice {
 					continue;
 
 				// ... to System.Console ...
-				MethodReference mr = (ins.Operand as MethodReference);
-				if (mr.DeclaringType.FullName != Console)
+				MethodReference mr = ins.Operand as MethodReference;
+                
+		                if (mr == null)
+               				continue;
+
+				if (!mr.DeclaringType.IsNamed ("System", "Console"))
 					continue;
 
 				// ... Write* methods
diff --git a/gendarme/rules/Gendarme.Rules.BadPractice/DoNotDecreaseVisibilityRule.cs b/gendarme/rules/Gendarme.Rules.BadPractice/DoNotDecreaseVisibilityRule.cs
new file mode 100644
index 0000000..4b387df
--- /dev/null
+++ b/gendarme/rules/Gendarme.Rules.BadPractice/DoNotDecreaseVisibilityRule.cs
@@ -0,0 +1,124 @@
+// 
+// Gendarme.Rules.BadPractice.DoNotDecreaseVisibilityRule
+//
+// Authors:
+//	Sebastien Pouliot <sebastien@ximian.com>
+//
+// Copyright (C) 2011 Novell, Inc (http://www.novell.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+using Mono.Cecil;
+
+using Gendarme.Framework;
+using Gendarme.Framework.Rocks;
+
+namespace Gendarme.Rules.BadPractice {
+
+	/// <summary>
+	/// The rule detect when a method visibility is decreased in an inherited type. 
+	/// Decreasing visibility does not prevent calling the base class method unless 
+	/// the type is <c>sealed</c>. Note that some language (but not C#) will allow 
+	/// you to seal, e.g. <c>final</c>, the method without an <c>override</c>.
+	/// </summary>
+	/// <example>
+	/// Bad example:
+	/// <code>
+	/// public class Base {
+	///	public void Public ()
+	///	{
+	///	}
+	/// }
+	/// 
+	/// public class BadInheritor : Base {
+	/// 	private new void Public ()
+	/// 	{
+	/// 	}
+	/// }
+	/// </code>
+	/// </example>
+	/// <example>
+	/// Good example (do not hide):
+	/// <code>
+	/// public class Inheritor : Base {
+	/// }
+	/// </code>
+	/// </example>
+	/// <example>
+	/// Good example (sealed type):
+	/// <code>
+	/// public sealed class Inheritor : Base {
+	/// 	private new void Public ()
+	/// 	{
+	/// 	}
+	/// }
+	/// </code>
+	/// </example>
+	[Problem ("A private method is hiding a visible method from a base type")]
+	[Solution ("Either seal the inherited type or rename/remove the private method.")]
+	[FxCopCompatibility ("Microsoft.Usage", "CA2222:DoNotDecreaseInheritedMemberVisibility")]
+	public class DoNotDecreaseVisibilityRule : Rule, IMethodRule {
+
+		static bool IsHiding (MethodDefinition method, TypeReference type)
+		{
+			if (type == null)
+				return false;
+
+			TypeDefinition td = type.Resolve ();
+			if ((td != null) && td.HasMethods) {
+				string name = method.Name;
+				foreach (MethodDefinition md in td.Methods) {
+					if (!md.IsPublic && !md.IsFamily)
+						continue;
+					if (name != md.Name)
+						continue;
+					if (method.CompareSignature (md))
+						return true;
+				}
+			}
+
+			return IsHiding (method, type.DeclaringType);
+		}
+
+		public RuleResult CheckMethod (MethodDefinition method)
+		{
+			if (!method.IsPrivate || method.IsFinal)
+				return RuleResult.DoesNotApply;
+
+			TypeDefinition type = method.DeclaringType;
+			if (type.IsSealed)
+				return RuleResult.DoesNotApply;
+
+			// we got a private, non-final, method in an unsealed type
+
+			// note: unlike CSC, MCS does not mark .cctor with hidebysig
+			// this also covers a private default ctor inheriting from System.Object
+			if (method.IsConstructor && !method.HasParameters)
+				return RuleResult.Success;
+
+			// are we're hiding something ?
+			if (method.IsHideBySig && !IsHiding (method, type.BaseType))
+				return RuleResult.Success;
+
+			Runner.Report (method, Severity.High, Confidence.Normal);
+			return RuleResult.Failure;
+		}
+	}
+}
+
diff --git a/gendarme/rules/Gendarme.Rules.BadPractice/DoNotForgetNotImplementedMethodsRule.cs b/gendarme/rules/Gendarme.Rules.BadPractice/DoNotForgetNotImplementedMethodsRule.cs
index d90a8b3..c4ce839 100644
--- a/gendarme/rules/Gendarme.Rules.BadPractice/DoNotForgetNotImplementedMethodsRule.cs
+++ b/gendarme/rules/Gendarme.Rules.BadPractice/DoNotForgetNotImplementedMethodsRule.cs
@@ -93,7 +93,7 @@ namespace Gendarme.Rules.BadPractice {
 				if (inst.OpCode.Code != Code.Newobj)
 					continue;
 				MethodReference ctor = (MethodReference) inst.Operand;
-				if ("System.NotImplementedException" != ctor.DeclaringType.FullName)
+				if (!ctor.DeclaringType.IsNamed ("System", "NotImplementedException"))
 					continue;
 				if (inst.Next.OpCode.Code != Code.Throw)
 					continue;
diff --git a/gendarme/rules/Gendarme.Rules.BadPractice/DoNotUseEnumIsAssignableFromRule.cs b/gendarme/rules/Gendarme.Rules.BadPractice/DoNotUseEnumIsAssignableFromRule.cs
index dd6280e..5fd5d90 100644
--- a/gendarme/rules/Gendarme.Rules.BadPractice/DoNotUseEnumIsAssignableFromRule.cs
+++ b/gendarme/rules/Gendarme.Rules.BadPractice/DoNotUseEnumIsAssignableFromRule.cs
@@ -99,7 +99,7 @@ namespace Gendarme.Rules.BadPractice {
 			if (type == null)
 				return false;
 
-			return type.FullName == "System.Enum";
+			return type.IsNamed ("System", "Enum");
 		}
 
 		static bool IsCallToTypeIsAssignableFrom (Instruction instruction)
@@ -124,10 +124,7 @@ namespace Gendarme.Rules.BadPractice {
 			if (operand.Name != name)
 				return false;
 
-			if (operand.DeclaringType.FullName != "System.Type")
-				return false;
-
-			return true;
+			return operand.DeclaringType.IsNamed ("System", "Type");
 		}
 
 		static bool IsCall (OpCode opcode)
diff --git a/gendarme/rules/Gendarme.Rules.BadPractice/DoNotUseGetInterfaceToCheckAssignabilityRule.cs b/gendarme/rules/Gendarme.Rules.BadPractice/DoNotUseGetInterfaceToCheckAssignabilityRule.cs
index 05edf49..a94bf42 100644
--- a/gendarme/rules/Gendarme.Rules.BadPractice/DoNotUseGetInterfaceToCheckAssignabilityRule.cs
+++ b/gendarme/rules/Gendarme.Rules.BadPractice/DoNotUseGetInterfaceToCheckAssignabilityRule.cs
@@ -86,7 +86,7 @@ namespace Gendarme.Rules.BadPractice {
 				MethodReference call = (ins.Operand as MethodReference);
 				if (call.Name != "GetInterface")
 					continue;
-				if (!call.DeclaringType.Inherits ("System.Type")) // not a sealed type
+				if (!call.DeclaringType.Inherits ("System", "Type")) // not a sealed type
 					continue;
 
 				// check for a null compare
diff --git a/gendarme/rules/Gendarme.Rules.BadPractice/Gendarme.Rules.BadPractice.csproj b/gendarme/rules/Gendarme.Rules.BadPractice/Gendarme.Rules.BadPractice.csproj
index 0b595dc..2841537 100755
--- a/gendarme/rules/Gendarme.Rules.BadPractice/Gendarme.Rules.BadPractice.csproj
+++ b/gendarme/rules/Gendarme.Rules.BadPractice/Gendarme.Rules.BadPractice.csproj
@@ -1,5 +1,5 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
     <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
@@ -10,8 +10,28 @@
     <AppDesignerFolder>Properties</AppDesignerFolder>
     <RootNamespace>Gendarme.Rules.BadPractice</RootNamespace>
     <AssemblyName>Gendarme.Rules.BadPractice</AssemblyName>
-    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
     <FileAlignment>512</FileAlignment>
+    <FileUpgradeFlags>
+    </FileUpgradeFlags>
+    <OldToolsVersion>3.5</OldToolsVersion>
+    <UpgradeBackupLocation />
+    <PublishUrl>publish\</PublishUrl>
+    <Install>true</Install>
+    <InstallFrom>Disk</InstallFrom>
+    <UpdateEnabled>false</UpdateEnabled>
+    <UpdateMode>Foreground</UpdateMode>
+    <UpdateInterval>7</UpdateInterval>
+    <UpdateIntervalUnits>Days</UpdateIntervalUnits>
+    <UpdatePeriodically>false</UpdatePeriodically>
+    <UpdateRequired>false</UpdateRequired>
+    <MapFileExtensions>true</MapFileExtensions>
+    <ApplicationRevision>0</ApplicationRevision>
+    <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
+    <IsWebBootstrapper>false</IsWebBootstrapper>
+    <UseApplicationTrust>false</UseApplicationTrust>
+    <BootstrapperEnabled>true</BootstrapperEnabled>
+    <TargetFrameworkProfile />
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
     <DebugSymbols>true</DebugSymbols>
@@ -24,6 +44,7 @@
     <DocumentationFile>..\..\console\bin\Debug\Gendarme.Rules.BadPractice.xml</DocumentationFile>
     <NoWarn>1591</NoWarn>
     <WarningsAsErrors>1570</WarningsAsErrors>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
     <DebugType>pdbonly</DebugType>
@@ -35,6 +56,7 @@
     <NoWarn>1591</NoWarn>
     <WarningsAsErrors>1570</WarningsAsErrors>
     <DocumentationFile>..\..\console\bin\Release\Gendarme.Rules.BadPractice.xml</DocumentationFile>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <ItemGroup>
     <Reference Include="System" />
@@ -80,6 +102,23 @@
       <Name>Gendarme.Framework</Name>
     </ProjectReference>
   </ItemGroup>
+  <ItemGroup>
+    <BootstrapperPackage Include="Microsoft.Net.Client.3.5">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1 Client Profile</ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Windows.Installer.3.1">
+      <Visible>False</Visible>
+      <ProductName>Windows Installer 3.1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+  </ItemGroup>
   <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
   <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
        Other similar extension points exist, see Microsoft.Common.targets.
diff --git a/gendarme/rules/Gendarme.Rules.BadPractice/GetEntryAssemblyMayReturnNullRule.cs b/gendarme/rules/Gendarme.Rules.BadPractice/GetEntryAssemblyMayReturnNullRule.cs
index 3719234..5dc1626 100644
--- a/gendarme/rules/Gendarme.Rules.BadPractice/GetEntryAssemblyMayReturnNullRule.cs
+++ b/gendarme/rules/Gendarme.Rules.BadPractice/GetEntryAssemblyMayReturnNullRule.cs
@@ -70,8 +70,6 @@ namespace Gendarme.Rules.BadPractice {
 	[EngineDependency (typeof (OpCodeEngine))]
 	public class GetEntryAssemblyMayReturnNullRule : Rule, IMethodRule {
 
-		private const string Assembly = "System.Reflection.Assembly";
-
 		public override void Initialize (IRunner runner)
 		{
 			base.Initialize (runner);
@@ -81,13 +79,20 @@ namespace Gendarme.Rules.BadPractice {
 					// GetEntryAssembly will work inside executables
 					e.CurrentAssembly.EntryPoint == null &&
 					
-					// if the module does not reference System.Reflection.Assembly 
-					// then no method inside it will be calling GetEntryAssembly
+					// if the module does not reference System.Reflection.Assembly.GetEntryAssembly
+					// then there's no point in enabling the rule
 					(e.CurrentAssembly.Name.Name == "mscorlib" ||
-					e.CurrentModule.HasTypeReference (Assembly));
+					e.CurrentModule.AnyMemberReference ((MemberReference mr) => {
+						return IsGetEntryAssembly (mr);
+					}));
 			};
 		}
 
+		static bool IsGetEntryAssembly (MemberReference method)
+		{
+			return method.IsNamed ("System.Reflection", "Assembly", "GetEntryAssembly");
+		}
+
 		public RuleResult CheckMethod (MethodDefinition method)
 		{
 			// rule doesn't not apply to methods without code (e.g. p/invokes)
@@ -108,11 +113,8 @@ namespace Gendarme.Rules.BadPractice {
 				switch (current.OpCode.Code) {
 				case Code.Call:
 				case Code.Callvirt:
-					MethodReference mr = (current.Operand as MethodReference);
-					if ((mr != null) && (mr.Name == "GetEntryAssembly")
-						&& (mr.DeclaringType.FullName == Assembly)) {
-						Runner.Report (method, current, Severity.Medium, Confidence.Total, String.Empty);
-					}
+					if (IsGetEntryAssembly (current.Operand as MethodReference))
+						Runner.Report (method, current, Severity.Medium, Confidence.Total);
 					break;
 				}
 			}
diff --git a/gendarme/rules/Gendarme.Rules.BadPractice/Makefile.am b/gendarme/rules/Gendarme.Rules.BadPractice/Makefile.am
index 5dc3f47..5237708 100644
--- a/gendarme/rules/Gendarme.Rules.BadPractice/Makefile.am
+++ b/gendarme/rules/Gendarme.Rules.BadPractice/Makefile.am
@@ -3,12 +3,14 @@ include ../common.make
 rules_sources =  \
 	AvoidAssemblyVersionMismatchRule.cs \
 	AvoidCallingProblematicMethodsRule.cs \
+	AvoidNullCheckWithAsOperatorRule.cs \
 	AvoidVisibleConstantFieldRule.cs \
 	CheckNewExceptionWithoutThrowingRule.cs \
 	CheckNewThreadWithoutStartRule.cs \
 	CloneMethodShouldNotReturnNullRule.cs \
 	ConstructorShouldNotCallVirtualMethodsRule.cs \
 	DisableDebuggingCodeRule.cs \
+	DoNotDecreaseVisibilityRule.cs \
 	DoNotForgetNotImplementedMethodsRule.cs \
 	DoNotUseEnumIsAssignableFromRule.cs \
 	DoNotUseGetInterfaceToCheckAssignabilityRule.cs \
@@ -27,12 +29,14 @@ rules_sources =  \
 
 tests_sources = \
 	AvoidAssemblyVersionMismatchTest.cs \
-	AvoidVisibleConstantFieldTest.cs \
 	AvoidCallingProblematicMethodsTest.cs \
+	AvoidNullCheckWithAsOperatorTest.cs \
+	AvoidVisibleConstantFieldTest.cs \
 	CheckNewExceptionWithoutThrowingTest.cs \
 	CheckNewThreadWithoutStartTest.cs \
 	CloneMethodShouldNotReturnNullTest.cs \
 	ConstructorShouldNotCallVirtualMethodsTest.cs \
+	DoNotDecreaseVisibilityTest.cs \
 	DoNotForgetNotImplementedMethodsTest.cs \
 	DoNotUseEnumIsAssignableFromTest.cs \
 	DoNotUseGetInterfaceToCheckAssignabilityTest.cs \
diff --git a/gendarme/rules/Gendarme.Rules.BadPractice/ObsoleteMessagesShouldNotBeEmptyRule.cs b/gendarme/rules/Gendarme.Rules.BadPractice/ObsoleteMessagesShouldNotBeEmptyRule.cs
index da0fdd5..33e5802 100644
--- a/gendarme/rules/Gendarme.Rules.BadPractice/ObsoleteMessagesShouldNotBeEmptyRule.cs
+++ b/gendarme/rules/Gendarme.Rules.BadPractice/ObsoleteMessagesShouldNotBeEmptyRule.cs
@@ -70,8 +70,6 @@ namespace Gendarme.Rules.BadPractice {
 	[FxCopCompatibility ("Microsoft.Design", "CA1041:ProvideObsoleteAttributeMessage")]
 	public class ObsoleteMessagesShouldNotBeEmptyRule : Rule, ITypeRule {
 
-		private const string ObsoleteAttribute = "System.ObsoleteAttribute";
-
 		public override void Initialize (IRunner runner)
 		{
 			base.Initialize (runner);
@@ -79,8 +77,10 @@ namespace Gendarme.Rules.BadPractice {
 			// if the module does not have a reference to System.ObsoleteAttribute 
 			// then nothing will be marked as obsolete inside it
 			Runner.AnalyzeModule += delegate (object o, RunnerEventArgs e) {
-				Active = (e.CurrentAssembly.Name.Name == "mscorlib") ||
-					e.CurrentModule.HasTypeReference (ObsoleteAttribute);
+				Active = (e.CurrentAssembly.Name.Name == "mscorlib" ||
+					e.CurrentModule.AnyTypeReference ((TypeReference tr) => {
+						return tr.IsNamed ("System", "ObsoleteAttribute");
+					}));
 			};
 		}
 
@@ -92,7 +92,7 @@ namespace Gendarme.Rules.BadPractice {
 			foreach (CustomAttribute ca in cap.CustomAttributes) {
 				// ObsoleteAttribute has a three (3) ctors, including a default (parameter-less) ctor
 				// http://msdn.microsoft.com/en-us/library/68k270ch.aspx
-				if (ca.AttributeType.FullName != ObsoleteAttribute)
+				if (!ca.AttributeType.IsNamed ("System", "ObsoleteAttribute"))
 					continue;
 
 				// note: we don't have to check fields since they cannot be used
diff --git a/gendarme/rules/Gendarme.Rules.BadPractice/OnlyUseDisposeForIDisposableTypesRule.cs b/gendarme/rules/Gendarme.Rules.BadPractice/OnlyUseDisposeForIDisposableTypesRule.cs
index 0425323..9647199 100644
--- a/gendarme/rules/Gendarme.Rules.BadPractice/OnlyUseDisposeForIDisposableTypesRule.cs
+++ b/gendarme/rules/Gendarme.Rules.BadPractice/OnlyUseDisposeForIDisposableTypesRule.cs
@@ -94,9 +94,9 @@ namespace Gendarme.Rules.BadPractice {
 
 			Log.WriteLine (this);
 			Log.WriteLine (this, "----------------------------------");
-			Log.WriteLine (this, type.FullName);
+			Log.WriteLine (this, type);
 			
-			if (!type.Implements ("System.IDisposable")) {
+			if (!type.Implements ("System", "IDisposable")) {
 				Log.WriteLine (this, "type does not implement IDisposable");
 
 				foreach (MethodDefinition method in type.Methods.Where (m => m.Name == "Dispose"))
diff --git a/gendarme/rules/Gendarme.Rules.BadPractice/PreferEmptyInstanceOverNullRule.cs b/gendarme/rules/Gendarme.Rules.BadPractice/PreferEmptyInstanceOverNullRule.cs
index 5c16da9..c6cbebc 100644
--- a/gendarme/rules/Gendarme.Rules.BadPractice/PreferEmptyInstanceOverNullRule.cs
+++ b/gendarme/rules/Gendarme.Rules.BadPractice/PreferEmptyInstanceOverNullRule.cs
@@ -25,6 +25,7 @@
 // THE SOFTWARE.
 
 using System;
+using System.Globalization;
 
 using Mono.Cecil;
 using Mono.Cecil.Cil;
@@ -146,9 +147,9 @@ namespace Gendarme.Rules.BadPractice {
 
 			//only apply to methods returning string, array, or IEnumerable-impl
 			return_type = method.ReturnType;
-			string_return_type = (return_type.FullName == "System.String");
+			string_return_type = return_type.IsNamed ("System", "String");
 			array_return_type = return_type.IsArray;
-			ienumerable_return_type = return_type.Implements ("System.Collections.IEnumerable");
+			ienumerable_return_type = return_type.Implements ("System.Collections", "IEnumerable");
 
 			if (!string_return_type && !array_return_type && !ienumerable_return_type)
 				return RuleResult.DoesNotApply;
@@ -158,7 +159,7 @@ namespace Gendarme.Rules.BadPractice {
 
 		protected override void Report (MethodDefinition method, Instruction ins)
 		{
-			string msg = string.Format ("Replace null with {0}.", SuggestReturnType ());
+			string msg = String.Format (CultureInfo.InvariantCulture, "Replace null with {0}.", SuggestReturnType ());
 			Runner.Report (method, ins, method.IsVisible () ? Severity.Medium : Severity.Low, Confidence.Normal, msg);
 		}
 
@@ -167,7 +168,7 @@ namespace Gendarme.Rules.BadPractice {
 			if (string_return_type)
 				return "string.Empty";
 			else if (array_return_type)
-				return string.Format ("an empty {0} array", return_type.Name);
+				return String.Format (CultureInfo.InvariantCulture, "an empty {0} array", return_type.Name);
 			else if (ienumerable_return_type)
 				return "yield break (or equivalent)";
 			return "an empty collection";
diff --git a/gendarme/rules/Gendarme.Rules.BadPractice/PreferParamsArrayForVariableArgumentsRule.cs b/gendarme/rules/Gendarme.Rules.BadPractice/PreferParamsArrayForVariableArgumentsRule.cs
index 10751fd..c048420 100644
--- a/gendarme/rules/Gendarme.Rules.BadPractice/PreferParamsArrayForVariableArgumentsRule.cs
+++ b/gendarme/rules/Gendarme.Rules.BadPractice/PreferParamsArrayForVariableArgumentsRule.cs
@@ -83,7 +83,9 @@ namespace Gendarme.Rules.BadPractice {
 
 			Runner.AnalyzeModule += (object o, RunnerEventArgs e) => {
 				Active = (e.CurrentAssembly.Name.Name == "mscorlib" ||
-				e.CurrentModule.HasTypeReference ("System.ArgIterator"));
+					e.CurrentModule.AnyTypeReference ((TypeReference tr) => {
+						return tr.IsNamed ("System", "ArgIterator");
+					}));
 			};
 		}
 
diff --git a/gendarme/rules/Gendarme.Rules.BadPractice/PreferSafeHandleRule.cs b/gendarme/rules/Gendarme.Rules.BadPractice/PreferSafeHandleRule.cs
index f87ac97..6d93dcc 100644
--- a/gendarme/rules/Gendarme.Rules.BadPractice/PreferSafeHandleRule.cs
+++ b/gendarme/rules/Gendarme.Rules.BadPractice/PreferSafeHandleRule.cs
@@ -186,9 +186,12 @@ namespace Gendarme.Rules.BadPractice {
 		static FieldDefinition FindIntPtr (TypeDefinition type)
 		{
 			foreach (FieldDefinition field in type.Fields) {
-				string name = field.FieldType.FullName;
-				if (name == "System.IntPtr" || name == "System.UIntPtr")
-					return field;
+				TypeReference ftype = field.FieldType;
+				if (ftype.Namespace == "System") {
+					string name = ftype.Name;
+					if ((name == "IntPtr") || (name == "UIntPtr"))
+						return field;
+				}
 			}
 			
 			return null;
@@ -212,7 +215,7 @@ namespace Gendarme.Rules.BadPractice {
 
 			Log.WriteLine (this);
 			Log.WriteLine (this, "----------------------------------");
-			Log.WriteLine (this, type.FullName);
+			Log.WriteLine (this, type);
 						
 			FieldDefinition field = FindIntPtr (type);
 			if (field != null) {
@@ -222,7 +225,7 @@ namespace Gendarme.Rules.BadPractice {
 				if (finalizer != null) 
 					confidence = (Confidence) ((int) confidence - 1);	// lower numbers have higher confidence
 
-				if (type.Implements ("System.IDisposable"))
+				if (type.Implements ("System", "IDisposable"))
 					confidence = (Confidence) ((int) confidence - 1);
 
 				Log.WriteLine (this, "'{0}' is an IntPtr.", field.Name);
diff --git a/gendarme/rules/Gendarme.Rules.BadPractice/PreferTryParseRule.cs b/gendarme/rules/Gendarme.Rules.BadPractice/PreferTryParseRule.cs
index 432c9ba..7856cdb 100644
--- a/gendarme/rules/Gendarme.Rules.BadPractice/PreferTryParseRule.cs
+++ b/gendarme/rules/Gendarme.Rules.BadPractice/PreferTryParseRule.cs
@@ -118,6 +118,7 @@ namespace Gendarme.Rules.BadPractice {
 		static bool HasTryParseMethod (TypeDefinition type)
 		{
 			bool present = false;
+
 			if (!has_try_parse.TryGetValue (type, out present)) {
 				foreach (MethodReference method in type.Methods) {
 					if (MethodSignatures.TryParse.Matches (method)) {
@@ -162,7 +163,8 @@ namespace Gendarme.Rules.BadPractice {
 				if (!MethodSignatures.Parse.Matches (mr))
 					continue;
 
-				if (!HasTryParseMethod (mr.DeclaringType.Resolve ()))
+				TypeDefinition declaringType = mr.DeclaringType.Resolve();
+				if (declaringType != null && !HasTryParseMethod(declaringType))
 					continue;
 				
 				// if inside a try (catch/finally) block then...
diff --git a/gendarme/rules/Gendarme.Rules.BadPractice/README.md b/gendarme/rules/Gendarme.Rules.BadPractice/README.md
new file mode 100644
index 0000000..dc0fb44
--- /dev/null
+++ b/gendarme/rules/Gendarme.Rules.BadPractice/README.md
@@ -0,0 +1,9 @@
+# Gendarme.Rules.BadPractice Rules
+
+You can access the latest rules documentation from our [[wiki|https://github.com/spouliot/gendarme/wiki/Gendarme.Rules.BadPractice(git)]] pages.
+
+
+## Feedback
+
+Please report any documentation errors, typos or suggestions to the [[Gendarme Mailing List|https://groups.google.com/forum/?fromgroups#!forum/gendarme]]. Thanks!
+
diff --git a/gendarme/rules/Gendarme.Rules.BadPractice/Test/AvoidNullCheckWithAsOperatorTest.cs b/gendarme/rules/Gendarme.Rules.BadPractice/Test/AvoidNullCheckWithAsOperatorTest.cs
new file mode 100644
index 0000000..65f9d50
--- /dev/null
+++ b/gendarme/rules/Gendarme.Rules.BadPractice/Test/AvoidNullCheckWithAsOperatorTest.cs
@@ -0,0 +1,142 @@
+//
+// Unit Tests for AvoidNullCheckWithAsOperatorRule
+//
+// Authors:
+//	Sebastien Pouliot <sebastien@ximian.com>
+//
+// Copyright (C) 2011 Novell, Inc (http://www.novell.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using Gendarme.Rules.BadPractice;
+
+using NUnit.Framework;
+using Test.Rules.Definitions;
+using Test.Rules.Fixtures;
+
+namespace Test.Rules.BadPractice {
+
+	[TestFixture]
+	public class AvoidNullCheckWithAsOperatorTest : MethodRuleTestFixture<AvoidNullCheckWithAsOperatorRule> {
+
+		string AsString_Bad1a (object obj)
+		{
+			return obj == null ? null : obj as string;
+		}
+
+		string AsString_Bad1b (object obj)
+		{
+			if (obj != null)
+				return obj as string;
+			return null;
+		}
+
+		string AsString_Bad2a (object obj)
+		{
+			return obj != null ? obj as string : null;
+		}
+
+		string AsString_Bad2b (object obj)
+		{
+			if (obj == null)
+				return null;
+			return obj as string;
+		}
+
+		string AsString_Good (object obj)
+		{
+			return obj as string;
+		}
+
+		string AsString_Good2 (string message, object obj)
+		{
+			if (message == null)
+				throw new ArgumentNullException ("message");
+			Console.WriteLine (message);
+			return obj as string;
+		}
+
+		string AsString_Good3 (string message, object obj)
+		{
+			if (message == null)
+				return null;
+			Console.WriteLine (message);
+			return obj as string;
+		}
+
+		void LocalsBad1a ()
+		{
+			object o = null;
+			string a = o == null ? null : o as string;
+			Console.WriteLine (a);
+		}
+
+		void LocalsBad2a ()
+		{
+			object o = null;
+			string a = o != null ? o as string : null;
+			Console.WriteLine (a);
+		}
+
+		// extracted from: moon/class/System.Windows/Mono.Xaml/XamlPropertySetter.cs
+		// no 'as' has been harmed by this test
+		object ConvertValue (object value)
+		{
+			if (value == null)
+				return null;
+
+			if (value is Type || value is SimpleMethods)
+				return value;
+
+			return value.ToString ();
+		}
+
+		[Test]
+		public void DoesNotApply ()
+		{
+			AssertRuleDoesNotApply (SimpleMethods.ExternalMethod);
+			AssertRuleDoesNotApply (SimpleMethods.EmptyMethod);
+			// no ldnull instruction
+			AssertRuleDoesNotApply<AvoidNullCheckWithAsOperatorTest> ("AsString_Good");
+			AssertRuleDoesNotApply<AvoidNullCheckWithAsOperatorTest> ("AsString_Good2");
+		}
+
+		[Test]
+		public void Success ()
+		{
+			AssertRuleSuccess<AvoidNullCheckWithAsOperatorTest> ("AsString_Good3");
+			AssertRuleSuccess<AvoidNullCheckWithAsOperatorTest> ("ConvertValue");
+		}
+
+		[Test]
+		public void Failure ()
+		{
+			AssertRuleFailure<AvoidNullCheckWithAsOperatorTest> ("AsString_Bad1a");
+			AssertRuleFailure<AvoidNullCheckWithAsOperatorTest> ("AsString_Bad1b");
+			AssertRuleFailure<AvoidNullCheckWithAsOperatorTest> ("AsString_Bad2a");
+			AssertRuleFailure<AvoidNullCheckWithAsOperatorTest> ("AsString_Bad2b");
+
+			AssertRuleFailure<AvoidNullCheckWithAsOperatorTest> ("LocalsBad1a");
+			AssertRuleFailure<AvoidNullCheckWithAsOperatorTest> ("LocalsBad2a");
+		}
+	}
+}
diff --git a/gendarme/rules/Gendarme.Rules.BadPractice/Test/DoNotDecreaseVisibilityTest.cs b/gendarme/rules/Gendarme.Rules.BadPractice/Test/DoNotDecreaseVisibilityTest.cs
new file mode 100644
index 0000000..9bafda7
--- /dev/null
+++ b/gendarme/rules/Gendarme.Rules.BadPractice/Test/DoNotDecreaseVisibilityTest.cs
@@ -0,0 +1,210 @@
+// 
+// Tests.Rules.BadPractice.DoNotDecreaseVisibilityTest
+//
+// Authors:
+//	Sebastien Pouliot <sebastien@ximian.com>
+//
+// Copyright (C) 2011 Novell, Inc (http://www.novell.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+using System;
+
+using Mono.Cecil;
+using Gendarme.Rules.BadPractice ;
+
+using NUnit.Framework;
+using Test.Rules.Fixtures;
+using Test.Rules.Helpers;
+using Test.Rules.Definitions;
+
+namespace Test.Rules.BadPractice {
+
+	[TestFixture]
+	public class DoNotDecreaseVisibilityTest : MethodRuleTestFixture<DoNotDecreaseVisibilityRule> {
+
+		public class TestCase {
+
+			public class Base {
+				public void Public ()
+				{
+				}
+
+				protected bool Protected (int x)
+				{
+					return x == 0;
+				}
+
+				internal int Internal ()
+				{
+					return -1;
+				}
+
+				private float Private (float f)
+				{
+					return f;
+				}
+			}
+
+			public class BadInheritor : Base {
+				private new void Public ()
+				{
+				}
+
+				private new bool Protected (int x)
+				{
+					return x == 1;
+				}
+
+				private new int Internal ()
+				{
+					return -1;
+				}
+
+				private new float Private (float f)
+				{
+					return -f;
+				}
+			}
+
+			public class NoInheritance {
+				private new void Public ()
+				{
+				}
+
+				private new bool Protected (int x)
+				{
+					return x == 1;
+				}
+
+				private new int Internal ()
+				{
+					return -1;
+				}
+
+				private new float Private (float f)
+				{
+					return -f;
+				}
+			}
+
+			// c# cannot seal the method without making it an override
+			// and an override cannot change visibility
+#if false
+			public class FinalInheritor : Base {
+				private new sealed void Public ()
+				{
+				}
+
+				private new sealed bool Protected (int x)
+				{
+					return x == 1;
+				}
+
+				private new sealed int Internal ()
+				{
+					return -1;
+				}
+
+				private new float Private (float f)
+				{
+					return -f;
+				}
+			}
+#endif
+			public sealed class Sealed : Base {
+				private new void Public ()
+				{
+				}
+
+				private new bool Protected (int x)
+				{
+					return x == 1;
+				}
+
+				private new int Internal ()
+				{
+					return -1;
+				}
+
+				private new float Private (float f)
+				{
+					return -f;
+				}
+			}
+
+			public class StaticCtor {
+				static StaticCtor ()
+				{
+				}
+			}
+
+			public class StaticCtorInheritor : StaticCtor {
+				static StaticCtorInheritor ()
+				{
+				}
+			}
+		}
+
+		[Test]
+		public void DoesNotApply ()
+		{
+			// not private
+			AssertRuleDoesNotApply<TestCase.Base> ("Public");
+			AssertRuleDoesNotApply<TestCase.Base> ("Protected");
+			AssertRuleDoesNotApply<TestCase.Base> ("Internal");
+#if false
+			// method is sealed (final)
+			AssertRuleDoesNotApply<TestCase.FinalInheritor> ("Public");
+			AssertRuleDoesNotApply<TestCase.FinalInheritor> ("Protected");
+			AssertRuleDoesNotApply<TestCase.FinalInheritor> ("Internal");
+			AssertRuleDoesNotApply<TestCase.FinalInheritor> ("Private");
+#endif
+			// type is sealed
+			AssertRuleDoesNotApply<TestCase.Sealed> ("Public");
+			AssertRuleDoesNotApply<TestCase.Sealed> ("Protected");
+			AssertRuleDoesNotApply<TestCase.Sealed> ("Internal");
+			AssertRuleDoesNotApply<TestCase.Sealed> ("Private");
+		}
+
+		[Test]
+		public void Good ()
+		{
+			AssertRuleSuccess<TestCase.Base> ("Private");
+
+			AssertRuleSuccess<TestCase.NoInheritance> ("Public");
+			AssertRuleSuccess<TestCase.NoInheritance> ("Protected");
+			AssertRuleSuccess<TestCase.NoInheritance> ("Internal");
+			AssertRuleSuccess<TestCase.NoInheritance> ("Private");
+
+			AssertRuleSuccess<TestCase.BadInheritor> ("Internal");
+			AssertRuleSuccess<TestCase.BadInheritor> ("Private");
+
+			AssertRuleSuccess<TestCase.StaticCtor> (".cctor");
+			AssertRuleSuccess<TestCase.StaticCtorInheritor> (".cctor");
+		}
+
+		[Test]
+		public void Bad ()
+		{
+			AssertRuleFailure<TestCase.BadInheritor> ("Public");
+			AssertRuleFailure<TestCase.BadInheritor> ("Protected");
+		}
+	}
+}
diff --git a/gendarme/rules/Gendarme.Rules.BadPractice/Test/Tests.Rules.BadPractice.csproj b/gendarme/rules/Gendarme.Rules.BadPractice/Test/Tests.Rules.BadPractice.csproj
index 0693fa8..ec4cf33 100755
--- a/gendarme/rules/Gendarme.Rules.BadPractice/Test/Tests.Rules.BadPractice.csproj
+++ b/gendarme/rules/Gendarme.Rules.BadPractice/Test/Tests.Rules.BadPractice.csproj
@@ -1,5 +1,5 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
     <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
@@ -10,8 +10,28 @@
     <AppDesignerFolder>Properties</AppDesignerFolder>
     <RootNamespace>Tests.Rules.BadPractice</RootNamespace>
     <AssemblyName>Tests.Rules.BadPractice</AssemblyName>
-    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
     <FileAlignment>512</FileAlignment>
+    <FileUpgradeFlags>
+    </FileUpgradeFlags>
+    <OldToolsVersion>3.5</OldToolsVersion>
+    <UpgradeBackupLocation />
+    <PublishUrl>publish\</PublishUrl>
+    <Install>true</Install>
+    <InstallFrom>Disk</InstallFrom>
+    <UpdateEnabled>false</UpdateEnabled>
+    <UpdateMode>Foreground</UpdateMode>
+    <UpdateInterval>7</UpdateInterval>
+    <UpdateIntervalUnits>Days</UpdateIntervalUnits>
+    <UpdatePeriodically>false</UpdatePeriodically>
+    <UpdateRequired>false</UpdateRequired>
+    <MapFileExtensions>true</MapFileExtensions>
+    <ApplicationRevision>0</ApplicationRevision>
+    <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
+    <IsWebBootstrapper>false</IsWebBootstrapper>
+    <UseApplicationTrust>false</UseApplicationTrust>
+    <BootstrapperEnabled>true</BootstrapperEnabled>
+    <TargetFrameworkProfile />
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
     <DebugSymbols>true</DebugSymbols>
@@ -21,6 +41,7 @@
     <DefineConstants>DEBUG;TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
     <DebugType>pdbonly</DebugType>
@@ -29,6 +50,7 @@
     <DefineConstants>TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <ItemGroup>
     <Reference Include="nunit.framework, Version=2.4.8.0, Culture=neutral, PublicKeyToken=96d09a1eb7f44a77, processorArchitecture=MSIL">
@@ -85,6 +107,23 @@
   <ItemGroup>
     <Folder Include="Properties\" />
   </ItemGroup>
+  <ItemGroup>
+    <BootstrapperPackage Include="Microsoft.Net.Client.3.5">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1 Client Profile</ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Windows.Installer.3.1">
+      <Visible>False</Visible>
+      <ProductName>Windows Installer 3.1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+  </ItemGroup>
   <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
   <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
        Other similar extension points exist, see Microsoft.Common.targets.
diff --git a/gendarme/rules/Gendarme.Rules.BadPractice/UseFileOpenOnlyWithFileAccessRule.cs b/gendarme/rules/Gendarme.Rules.BadPractice/UseFileOpenOnlyWithFileAccessRule.cs
index 655298f..2c8be6f 100644
--- a/gendarme/rules/Gendarme.Rules.BadPractice/UseFileOpenOnlyWithFileAccessRule.cs
+++ b/gendarme/rules/Gendarme.Rules.BadPractice/UseFileOpenOnlyWithFileAccessRule.cs
@@ -26,6 +26,7 @@
 
 using System;
 using System.Collections.Generic;
+using System.Globalization;
 
 using Mono.Cecil;
 using Mono.Cecil.Cil;
@@ -68,9 +69,19 @@ namespace Gendarme.Rules.BadPractice {
 	[EngineDependency (typeof (OpCodeEngine))]
 	public class UseFileOpenOnlyWithFileAccessRule : Rule, IMethodRule {
 
-		const string fileMode = "System.IO.FileMode";
-		const string fileAccess = "System.IO.FileAccess";
-		const string fileSystemRights = "System.Security.AccessControl.FileSystemRights";
+		public override void Initialize (IRunner runner)
+		{
+			base.Initialize (runner);
+
+			// if the module does not reference System.IO.FileMode
+			// then no code inside the module will be using it
+			Runner.AnalyzeModule += delegate (object o, RunnerEventArgs e) {
+				Active = (e.CurrentAssembly.Name.Name == "mscorlib" ||
+					e.CurrentModule.AnyTypeReference ((TypeReference tr) => {
+						return tr.IsNamed ("System.IO", "FileMode");
+					}));
+			};
+		}
 
 		// System.IO.File::Open
 		// System.IO.FileInfo::Open
@@ -115,16 +126,17 @@ namespace Gendarme.Rules.BadPractice {
 				bool foundFileMode = false;
 				bool foundFileAccess = false;
 				foreach (ParameterDefinition parameter in m.Parameters) {
-					string ptname = parameter.ParameterType.FullName;
-					if (!foundFileMode && ptname == fileMode)
+					TypeReference ptype = parameter.ParameterType;
+					if (!foundFileMode && ptype.IsNamed ("System.IO", "FileMode"))
 						foundFileMode = true;
-					if (!foundFileAccess && (ptname == fileAccess || ptname == fileSystemRights))
+					if (!foundFileAccess && (ptype.IsNamed ("System.IO", "FileAccess") || ptype.IsNamed ("System.Security.AccessControl", "FileSystemRights")))
 						foundFileAccess = true;
 				}
 				if (foundFileMode && !foundFileAccess) {
-					Runner.Report (method, instruction, Severity.Medium, Confidence.Normal,
-						String.Format("{0}::{1} being called with FileMode parameter but without FileAccess.",
-							m.DeclaringType.FullName, m.Name));
+					string msg = String.Format (CultureInfo.InvariantCulture, 
+						"{0}::{1} being called with FileMode parameter but without FileAccess.",
+						m.DeclaringType.GetFullName (), m.Name);
+					Runner.Report (method, instruction, Severity.Medium, Confidence.Normal, msg);
 				}
 			}
 			return Runner.CurrentRuleResult;
diff --git a/gendarme/rules/Gendarme.Rules.Concurrency/DecorateThreadsRule.cs b/gendarme/rules/Gendarme.Rules.Concurrency/DecorateThreadsRule.cs
index feead4a..c7b243a 100644
--- a/gendarme/rules/Gendarme.Rules.Concurrency/DecorateThreadsRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Concurrency/DecorateThreadsRule.cs
@@ -37,6 +37,7 @@ using System.Collections;
 using System.Collections.Generic;
 using System.Collections.ObjectModel;
 using System.Diagnostics;
+using System.Globalization;
 using System.Linq;
 
 namespace Gendarme.Rules.Concurrency {
@@ -268,7 +269,8 @@ namespace Gendarme.Rules.Concurrency {
 				if (delegateType != null && !ThreadRocks.ThreadedNamespace (delegateType.Namespace)) {
 					ThreadModel delegateModel = delegateType.ThreadingModel ();
 					if (model != delegateModel && !delegateModel.AllowsEveryCaller ()) {
-						string mesg = string.Format ("{0} event must match {1} delegate.", model, delegateModel);
+						string mesg = String.Format (CultureInfo.InvariantCulture, 
+							"{0} event must match {1} delegate.", model, delegateModel);
 						ReportDefect (method, Severity.High, Confidence.High, mesg);
 					}
 				}
@@ -281,15 +283,17 @@ namespace Gendarme.Rules.Concurrency {
 				bool new_slot = method.IsNewSlot;
 				superTypes = from s in superTypes where (s.IsInterface == new_slot) select s;
 				string [] parameters = pdc != null
-					? (from p in pdc.Cast<ParameterDefinition> () select p.ParameterType.FullName).ToArray ()
+					? (from p in pdc.Cast<ParameterDefinition> () select p.ParameterType.GetFullName ()).ToArray ()
 					: null;
 
+				string return_type_name = method.ReturnType.GetFullName ();
 				foreach (TypeDefinition type in superTypes) {
-					MethodDefinition superMethod = type.GetMethod (name, method.ReturnType.FullName, parameters);
+					MethodDefinition superMethod = type.GetMethod (name, return_type_name, parameters);
 					if (superMethod != null && !ThreadRocks.ThreadedNamespace (superMethod.DeclaringType.Namespace)) {
 						ThreadModel superModel = superMethod.ThreadingModel ();
 						if (model != superModel) {
-							string mesg = string.Format ("{0} {1} must match {2} {3} method.", model, name, superModel,
+							string mesg = String.Format (CultureInfo.InvariantCulture, 
+								"{0} {1} must match {2} {3} method.", model, name, superModel,
 								new_slot ? "interface" : "base");
 							ReportDefect (method, Severity.High, Confidence.High, mesg);
 						}
@@ -299,7 +303,7 @@ namespace Gendarme.Rules.Concurrency {
 			
 			// Serializable cannot be applied to static methods, but can be applied to
 			// operators because they're just sugar for normal calls.
-			if (method.IsStatic && model.Is (ThreadModel.Serializable) && !name.StartsWith ("op_")) {
+			if (method.IsStatic && model.Is (ThreadModel.Serializable) && !name.StartsWith ("op_", StringComparison.Ordinal)) {
 				string mesg = "Static members cannot be decorated with Serializable.";
 				ReportDefect (method, Severity.High, Confidence.High, mesg);
 			}
@@ -315,21 +319,23 @@ namespace Gendarme.Rules.Concurrency {
 			foreach (MethodDefinition caller in anonymous_entry_points) {
 				foreach (Instruction ins in caller.Body.Instructions) {
 					switch (ins.OpCode.Code) {
-						case Code.Call:
-						case Code.Callvirt:
-							MethodDefinition target = ((MethodReference) ins.Operand).Resolve ();
-							if (target != null) {
-								ThreadModel targetModel = target.ThreadingModel ();
-								if (targetModel == ThreadModel.MainThread) {
-									string mesg = string.Format ("An anonymous thread entry point cannot call MainThread {0}.", target.Name);
-									
-									++DefectCount;
-									Log.WriteLine (this, "Defect: {0}", mesg);
-									Defect defect = new Defect (this, caller, caller, ins, Severity.High, Confidence.High, mesg);
-									Runner.Report (defect);
-								}
+					case Code.Call:
+					case Code.Callvirt:
+						MethodDefinition target = ((MethodReference) ins.Operand).Resolve ();
+						if (target != null) {
+							ThreadModel targetModel = target.ThreadingModel ();
+							if (targetModel == ThreadModel.MainThread) {
+								string mesg = String.Format (CultureInfo.InvariantCulture, 
+									"An anonymous thread entry point cannot call MainThread {0}.", 
+									target.Name);
+								
+								++DefectCount;
+								Log.WriteLine (this, "Defect: {0}", mesg);
+								Defect defect = new Defect (this, caller, caller, ins, Severity.High, Confidence.High, mesg);
+								Runner.Report (defect);
 							}
-							break;
+						}
+						break;
 					}
 				}
 			}
@@ -385,8 +391,9 @@ namespace Gendarme.Rules.Concurrency {
 									if (!target.IsGeneratedCode () || target.IsProperty ()) {
 										ThreadModel targetModel = target.ThreadingModel ();
 										if (!IsValidCall (callerModel, targetModel)) {
-											string mesg = string.Format ("{0} delegate cannot be bound to {1} {2} method.", callerModel, targetModel, target.Name);
-											
+											string mesg = String.Format (CultureInfo.InvariantCulture,
+												"{0} delegate cannot be bound to {1} {2} method.", 
+												callerModel, targetModel, target.Name);
 											++DefectCount;
 											Log.WriteLine (this, "Defect: {0}", mesg);
 											Defect defect = new Defect (this, method, method, ins, Severity.High, Confidence.High, mesg);
@@ -431,7 +438,7 @@ namespace Gendarme.Rules.Concurrency {
 							methods.AddIfNew ((MethodReference) ins.Previous.Previous.Operand);
 						
 						// Misc threaded events.
-						} else if (call_type.FullName == "System.ComponentModel.BackgroundWorker") {
+						} else if (call_type.IsNamed ("System.ComponentModel", "BackgroundWorker")) {
 							if (call.Name == "add_DoWork") {
 								candidate = (MethodReference) ins.Previous.Previous.Operand;
 							}
@@ -465,7 +472,9 @@ namespace Gendarme.Rules.Concurrency {
 						if (target != null) {
 							ThreadModel targetModel = target.ThreadingModel ();
 							if (!IsValidCall (method_model.Value, targetModel)) {
-								string mesg = string.Format ("{0} {1} cannot be bound to {2} {3} method.", method_model, entry.Key, targetModel, target.Name);
+								string mesg = String.Format (CultureInfo.InvariantCulture, 
+									"{0} {1} cannot be bound to {2} {3} method.", 
+									method_model, entry.Key, targetModel, target.Name);
 								ReportDefect (method, Severity.High, Confidence.High, mesg);
 							}
 						}
@@ -490,9 +499,8 @@ namespace Gendarme.Rules.Concurrency {
 			// but mono doesn't.
 			case "add_ErrorDataReceived":
 			case "add_OutputDataReceived":
-				TypeReference type = method.DeclaringType;
-				if (type.Name == "Process")
-					return (type.Namespace == "System.Diagnostics");
+				if (method.DeclaringType.IsNamed ("System.Diagnostics", "Process"))
+					return true;
 				break;
 			}
 			return false;
@@ -523,7 +531,8 @@ namespace Gendarme.Rules.Concurrency {
 						anonymous_entry_points.Add (method);
 					
 					} else if (model == ThreadModel.MainThread) {
-						string mesg = string.Format ("{0} is a thread entry point and so cannot be MainThread.", method.Name);
+						string mesg = String.Format (CultureInfo.InvariantCulture, 
+							"{0} is a thread entry point and so cannot be MainThread.", method.Name);
 						ReportDefect (method, Severity.High, Confidence.High, mesg);
 					}
 				}
@@ -537,7 +546,8 @@ namespace Gendarme.Rules.Concurrency {
 				ThreadModel callerModel = caller.ThreadingModel ();
 				ThreadModel targetModel = target.ThreadingModel ();
 				if (!IsValidCall (callerModel, targetModel)) {
-					string mesg = string.Format ("{0} {1} cannot call {2} {3}.", callerModel, caller.Name, targetModel, target.Name);
+					string mesg = String.Format (CultureInfo.InvariantCulture, "{0} {1} cannot call {2} {3}.", 
+						callerModel, caller.Name, targetModel, target.Name);
 					
 					++DefectCount;
 					Log.WriteLine (this, "Defect: {0}", mesg);
diff --git a/gendarme/rules/Gendarme.Rules.Concurrency/DoNotLockOnThisOrTypesRule.cs b/gendarme/rules/Gendarme.Rules.Concurrency/DoNotLockOnThisOrTypesRule.cs
index 2ddb7ac..7c91ad5 100644
--- a/gendarme/rules/Gendarme.Rules.Concurrency/DoNotLockOnThisOrTypesRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Concurrency/DoNotLockOnThisOrTypesRule.cs
@@ -27,6 +27,7 @@
 //
 
 using System;
+using System.Globalization;
 
 using Mono.Cecil;
 using Mono.Cecil.Cil;
@@ -108,23 +109,26 @@ namespace Gendarme.Rules.Concurrency {
 
 			switch (ins.OpCode.Code) {
 			case Code.Ldarg_0:
-				msg = LockThis;
+				if (!method.IsStatic)
+					msg = LockThis;
 				break;
 			case Code.Ldarg:
 			case Code.Ldarg_S:
-				ParameterDefinition pd = (ins.Operand as ParameterDefinition);
-				if ((pd == null) || (pd.GetSequence () != 0))
-					msg = LockThis;
+				if (!method.IsStatic) {
+					ParameterDefinition pd = (ins.Operand as ParameterDefinition);
+					if ((pd == null) || (pd.Index == 0))
+						msg = LockThis;
+				}
 				break;
 			case Code.Call:
 			case Code.Callvirt:
 				MethodReference mr = (ins.Operand as MethodReference);
-				if (mr.ReturnType.FullName != "System.Type")
+				if (!mr.ReturnType.IsNamed ("System", "Type"))
 					return String.Empty;
 
 				if ((mr.Name == "GetTypeFromHandle") && (mr.DeclaringType.Name == "Type")) {
 					// ldtoken
-					msg = String.Format (LockType, (ins.Previous.Operand as TypeReference).Name);
+					msg = String.Format (CultureInfo.InvariantCulture, LockType, (ins.Previous.Operand as TypeReference).Name);
 				} else {
 					msg = mr.ToString ();
 				}
diff --git a/gendarme/rules/Gendarme.Rules.Concurrency/DoNotLockOnWeakIdentityObjectsRule.cs b/gendarme/rules/Gendarme.Rules.Concurrency/DoNotLockOnWeakIdentityObjectsRule.cs
index fe730aa..57c3b84 100644
--- a/gendarme/rules/Gendarme.Rules.Concurrency/DoNotLockOnWeakIdentityObjectsRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Concurrency/DoNotLockOnWeakIdentityObjectsRule.cs
@@ -27,6 +27,7 @@
 //
 
 using System;
+using System.Globalization;
 
 using Mono.Cecil;
 using Mono.Cecil.Cil;
@@ -99,12 +100,26 @@ namespace Gendarme.Rules.Concurrency {
 	[FxCopCompatibility ("Microsoft.Reliability", "CA2002:DoNotLockOnObjectsWithWeakIdentity")]
 	public class DoNotLockOnWeakIdentityObjectsRule : LockAnalyzerRule {
 
-		private static string [] unsealed_types = new string[] {
-			"System.MarshalByRefObject",
-			"System.OutOfMemoryException",
-			"System.Reflection.MemberInfo",
-			"System.Reflection.ParameterInfo"
-		};
+		static bool IsWeakSealedType (TypeReference type)
+		{
+			switch (type.Namespace) {
+			case "System":
+				string name = type.Name;
+				return ((name == "String") || (name == "ExecutionEngineException") || (name == "StackOverflowException"));
+			case "System.Threading":
+				return (type.Name == "Thread");
+			default:
+				return false;
+			}
+		}
+
+		static string InheritFromWeakType (TypeReference type, string nameSpace, string name)
+		{
+			if (!type.Inherits (nameSpace, name))
+				return String.Empty;
+			return String.Format (CultureInfo.InvariantCulture, "'{0}' inherits from '{1}.{2}'.", 
+				type.GetFullName (), nameSpace, name);
+		}
 
 		public override void Analyze (MethodDefinition method, MethodReference enter, Instruction ins)
 		{
@@ -119,7 +134,7 @@ namespace Gendarme.Rules.Concurrency {
 			if (first.OpCode.Code == Code.Dup)
 				first = first.Previous;
 			type = first.GetOperandType (method);
-			if (type.FullName == "System.Object") {
+			if (type.IsNamed ("System", "Object")) {
 				// newer GMCS use a temporary local that hides the real type
 				Instruction prev = first.Previous;
 				if (first.IsLoadLocal () && prev.IsStoreLocal ()) {
@@ -131,24 +146,28 @@ namespace Gendarme.Rules.Concurrency {
 			if (type == null)
 				return;
 
-			// fast check for sealed types
-			string full_name = type.FullName;
-			switch (full_name) {
-			case "System.ExecutionEngineException":
-			case "System.StackOverflowException":
-			case "System.String":
-			case "System.Threading.Thread":
-				Runner.Report (method, call, Severity.High, Confidence.Normal, full_name);
-				break;
-			default:
-				foreach (string unsealed in unsealed_types) {
-					if (!type.Inherits (unsealed))
-						continue;
-
-					string msg = String.Format ("'{0}' inherits from '{1}'.", full_name, unsealed);
+			if (IsWeakSealedType (type)) {
+				Runner.Report (method, call, Severity.High, Confidence.Normal, type.GetFullName ());
+			} else {
+				string msg = InheritFromWeakType (type, "System", "MarshalByRefObject");
+				if (msg.Length > 0) {
+					Runner.Report (method, call, Severity.High, Confidence.Normal, msg);
+					return;
+				}
+				msg = InheritFromWeakType (type, "System", "OutOfMemoryException");
+				if (msg.Length > 0) {
+					Runner.Report (method, call, Severity.High, Confidence.Normal, msg);
+					return;
+				}
+				msg = InheritFromWeakType (type, "System.Reflection", "MemberInfo");
+				if (msg.Length > 0) {
+					Runner.Report (method, call, Severity.High, Confidence.Normal, msg);
+					return;
+				}
+				msg = InheritFromWeakType (type, "System.Reflection", "ParameterInfo");
+				if (msg.Length > 0) {
 					Runner.Report (method, call, Severity.High, Confidence.Normal, msg);
 				}
-				break;
 			}
 		}
 	}
diff --git a/gendarme/rules/Gendarme.Rules.Concurrency/DoNotUseThreadStaticWithInstanceFieldsRule.cs b/gendarme/rules/Gendarme.Rules.Concurrency/DoNotUseThreadStaticWithInstanceFieldsRule.cs
index af1beeb..c949329 100644
--- a/gendarme/rules/Gendarme.Rules.Concurrency/DoNotUseThreadStaticWithInstanceFieldsRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Concurrency/DoNotUseThreadStaticWithInstanceFieldsRule.cs
@@ -84,15 +84,13 @@ namespace Gendarme.Rules.Concurrency {
 	[Solution ("ThreadStaticAttribute will only make static fields thread safe. To make an instance field thread safe you need to use techniques like locking or System.Threading.Thread.Thread::AllocateNamedDataSlot.")]
 	public sealed class DoNotUseThreadStaticWithInstanceFieldsRule : Rule, ITypeRule {
 
-		private const string ThreadStaticAttribute = "System.ThreadStaticAttribute";
-
 		public RuleResult CheckType (TypeDefinition type)
 		{
 			if (!type.HasFields || type.IsEnum)
 				return RuleResult.DoesNotApply;
 			
 			foreach (FieldDefinition field in type.Fields) {
-				if (!field.IsStatic && field.CustomAttributes.ContainsType (ThreadStaticAttribute)) {
+				if (!field.IsStatic && field.HasAttribute ("System", "ThreadStaticAttribute")) {
 					Runner.Report (field, Severity.Critical, Confidence.Total);
 				}
 			}
diff --git a/gendarme/rules/Gendarme.Rules.Concurrency/DontUseLockedRegionOutsideMethodRule.cs b/gendarme/rules/Gendarme.Rules.Concurrency/DontUseLockedRegionOutsideMethodRule.cs
index 9b2a53b..4cc40d6 100644
--- a/gendarme/rules/Gendarme.Rules.Concurrency/DontUseLockedRegionOutsideMethodRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Concurrency/DontUseLockedRegionOutsideMethodRule.cs
@@ -100,7 +100,8 @@ namespace Gendarme.Rules.Concurrency {
 	///		Monitor.Enter (mutex);
 	/// 		try {
 	///			producer++;
-	/// 		} finally {
+	/// 		}
+	///		finally {
 	///			Monitor.Exit (mutex);
 	/// 		}
 	///	}
@@ -131,8 +132,10 @@ namespace Gendarme.Rules.Concurrency {
 			// if not then this rule does not need to be executed for the module
 			// note: mscorlib.dll is an exception since it defines, not refer, System.Threading.Monitor
 			Runner.AnalyzeModule += delegate (object o, RunnerEventArgs e) {
-				Active = (e.CurrentAssembly.Name.Name == "mscorlib") ||
-					e.CurrentModule.HasTypeReference ("System.Threading.Monitor");
+				Active = (e.CurrentAssembly.Name.Name == "mscorlib" ||
+					e.CurrentModule.AnyTypeReference ((TypeReference tr) => {
+						return tr.IsNamed ("System.Threading", "Monitor");
+					}));
 			};
 		}
 		
@@ -157,9 +160,9 @@ namespace Gendarme.Rules.Concurrency {
 				if (m == null)
 					continue;
 
-				if (IsMonitorMethod (m, "Enter")) {
+				if (m.IsNamed ("System.Threading", "Monitor", "Enter")) {
 					enter++;
-				} else if (IsMonitorMethod (m, "Exit")) {
+				} else if (m.IsNamed ("System.Threading", "Monitor", "Exit")) {
 					exit++;
 				}
 			}
@@ -170,13 +173,5 @@ namespace Gendarme.Rules.Concurrency {
 			Runner.Report (method, Severity.High, Confidence.Normal);
 			return RuleResult.Failure;
 		}
-		
-		//FIXME: copied from DoubleCheckLockingRule, we need to share this
-		private static bool IsMonitorMethod (MemberReference method, string methodName)
-		{
-			if (method.Name != methodName)
-				return false;
-			return (method.DeclaringType.FullName == "System.Threading.Monitor");
-		}
 	}
 }
diff --git a/gendarme/rules/Gendarme.Rules.Concurrency/DoubleCheckLockingRule.cs b/gendarme/rules/Gendarme.Rules.Concurrency/DoubleCheckLockingRule.cs
index 8595046..d1227a2 100644
--- a/gendarme/rules/Gendarme.Rules.Concurrency/DoubleCheckLockingRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Concurrency/DoubleCheckLockingRule.cs
@@ -154,7 +154,9 @@ namespace Gendarme.Rules.Concurrency {
 					// if not then this rule does not need to be executed for the module
 					// note: mscorlib.dll is an exception since it defines, not refer, System.Threading.Monitor
 					(e.CurrentAssembly.Name.Name == "mscorlib" ||
-					e.CurrentModule.HasTypeReference ("System.Threading.Monitor"));
+					e.CurrentModule.AnyTypeReference ((TypeReference tr) => {
+						return tr.IsNamed ("System.Threading", "Monitor");
+					}));
 			};
 		}
 
@@ -213,7 +215,7 @@ namespace Gendarme.Rules.Concurrency {
 		{
 			if (method.Name != methodName)
 				return false;
-			if (method.DeclaringType.FullName != "System.Threading.Monitor")
+			if (!method.DeclaringType.IsNamed ("System.Threading", "Monitor"))
 				return false;
 			// exclude Monitor.Enter(object, ref bool) since the comparison would be made
 			// againt the 'lockTaken' parameter and would report failures for every cases.
diff --git a/gendarme/rules/Gendarme.Rules.Concurrency/Gendarme.Rules.Concurrency.csproj b/gendarme/rules/Gendarme.Rules.Concurrency/Gendarme.Rules.Concurrency.csproj
index 8224fee..e9f89be 100644
--- a/gendarme/rules/Gendarme.Rules.Concurrency/Gendarme.Rules.Concurrency.csproj
+++ b/gendarme/rules/Gendarme.Rules.Concurrency/Gendarme.Rules.Concurrency.csproj
@@ -1,5 +1,5 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
-<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="3.5">
+<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="4.0">
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
     <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
@@ -12,9 +12,11 @@
     <AssemblyName>Gendarme.Rules.Concurrency</AssemblyName>
     <FileUpgradeFlags>
     </FileUpgradeFlags>
-    <OldToolsVersion>2.0</OldToolsVersion>
+    <OldToolsVersion>3.5</OldToolsVersion>
     <UpgradeBackupLocation>
     </UpgradeBackupLocation>
+    <IsWebBootstrapper>true</IsWebBootstrapper>
+    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
     <PublishUrl>http://localhost/Gendarme.Rules.Concurrency/</PublishUrl>
     <Install>true</Install>
     <InstallFrom>Web</InstallFrom>
@@ -27,10 +29,9 @@
     <MapFileExtensions>true</MapFileExtensions>
     <ApplicationRevision>0</ApplicationRevision>
     <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
-    <IsWebBootstrapper>true</IsWebBootstrapper>
     <UseApplicationTrust>false</UseApplicationTrust>
     <BootstrapperEnabled>true</BootstrapperEnabled>
-    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <TargetFrameworkProfile />
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
     <DebugSymbols>true</DebugSymbols>
@@ -43,6 +44,7 @@
     <NoWarn>1591</NoWarn>
     <WarningsAsErrors>1570</WarningsAsErrors>
     <DocumentationFile>..\..\console\bin\Debug\Gendarme.Rules.Concurrency.xml</DocumentationFile>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
     <DebugType>pdbonly</DebugType>
@@ -54,6 +56,7 @@
     <NoWarn>1591</NoWarn>
     <WarningsAsErrors>1570</WarningsAsErrors>
     <DocumentationFile>..\..\console\bin\Release\Gendarme.Rules.Concurrency.xml</DocumentationFile>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <ItemGroup>
     <Reference Include="System" />
@@ -93,14 +96,33 @@
     <None Include="ChangeLog" />
   </ItemGroup>
   <ItemGroup>
+    <BootstrapperPackage Include="Microsoft.Net.Client.3.5">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1 Client Profile</ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
     <BootstrapperPackage Include="Microsoft.Net.Framework.2.0">
       <Visible>False</Visible>
+      <ProductName>
+      </ProductName>
+      <Install>false</Install>
     </BootstrapperPackage>
     <BootstrapperPackage Include="Microsoft.Net.Framework.3.0">
       <Visible>False</Visible>
+      <ProductName>
+      </ProductName>
+      <Install>false</Install>
     </BootstrapperPackage>
     <BootstrapperPackage Include="Microsoft.Net.Framework.3.5">
       <Visible>False</Visible>
+      <ProductName>
+      </ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1</ProductName>
+      <Install>false</Install>
     </BootstrapperPackage>
   </ItemGroup>
   <Import Project="$(MSBuildBinPath)\Microsoft.CSharp.targets" />
diff --git a/gendarme/rules/Gendarme.Rules.Concurrency/LockAnalyzerRule.cs b/gendarme/rules/Gendarme.Rules.Concurrency/LockAnalyzerRule.cs
index 04424af..fd7bc61 100644
--- a/gendarme/rules/Gendarme.Rules.Concurrency/LockAnalyzerRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Concurrency/LockAnalyzerRule.cs
@@ -49,8 +49,10 @@ namespace Gendarme.Rules.Concurrency {
 			// if not then this rule does not need to be executed for the module
 			// note: mscorlib.dll is an exception since it defines, not refer, System.Threading.Monitor
 			Runner.AnalyzeModule += delegate (object o, RunnerEventArgs e) {
-				Active = (e.CurrentAssembly.Name.Name == "mscorlib") ||
-					e.CurrentModule.HasTypeReference ("System.Threading.Monitor");
+				Active = (e.CurrentAssembly.Name.Name == "mscorlib" ||
+					e.CurrentModule.AnyTypeReference ((TypeReference tr) => {
+						return tr.IsNamed ("System.Threading", "Monitor");
+					}));
 			};
 		}
 
@@ -68,14 +70,8 @@ namespace Gendarme.Rules.Concurrency {
 
 			foreach (Instruction ins in method.Body.Instructions) {
 				MethodReference mr = ins.GetMethod ();
-				if (mr == null)
-					continue;
-				if (mr.DeclaringType.FullName != "System.Threading.Monitor")
-					continue;
-				if (mr.Name != "Enter")
-					continue;
-
-				Analyze (method, mr, ins);
+				if (mr.IsNamed ("System.Threading", "Monitor", "Enter"))
+					Analyze (method, mr, ins);
 			}
 			return Runner.CurrentRuleResult;
 		}
diff --git a/gendarme/rules/Gendarme.Rules.Concurrency/ProtectCallToEventDelegatesRule.cs b/gendarme/rules/Gendarme.Rules.Concurrency/ProtectCallToEventDelegatesRule.cs
index e614973..843c9b8 100644
--- a/gendarme/rules/Gendarme.Rules.Concurrency/ProtectCallToEventDelegatesRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Concurrency/ProtectCallToEventDelegatesRule.cs
@@ -27,6 +27,7 @@
 //
 
 using System;
+using System.Globalization;
 
 using Mono.Cecil;
 using Mono.Cecil.Cil;
@@ -164,13 +165,13 @@ namespace Gendarme.Rules.Concurrency {
 				Instruction caller = ins.TraceBack (method);
 				FieldDefinition field = caller.GetField ();
 				if (field != null) {
-					string msg = String.Format ("Possible race condition since field '{0}' is accessed directly.", field.Name);
+					string msg = String.Format (CultureInfo.InvariantCulture, "Possible race condition since field '{0}' is accessed directly.", field.Name);
 					Runner.Report (method, ins, Severity.High, Confidence.High, msg);
 				} else {
 					// look for the variable, if it's not then stop analysis
 					VariableDefinition load = caller.GetVariable (method);
 					if ((load != null) && !CheckVariable (method, caller, load)) {
-						string msg = String.Format ("Variable '{0}' does not seems to be checked against null.", load.Name);
+						string msg = String.Format (CultureInfo.InvariantCulture, "Variable '{0}' does not seems to be checked against null.", load.Name);
 						Runner.Report (method, ins, Severity.High, Confidence.Normal, msg);
 					}
 				}
diff --git a/gendarme/rules/Gendarme.Rules.Concurrency/README.md b/gendarme/rules/Gendarme.Rules.Concurrency/README.md
new file mode 100644
index 0000000..3da4dc8
--- /dev/null
+++ b/gendarme/rules/Gendarme.Rules.Concurrency/README.md
@@ -0,0 +1,9 @@
+# Gendarme.Rules.Concurrency Rules
+
+You can access the latest rules documentation from our [[wiki|https://github.com/spouliot/gendarme/wiki/Gendarme.Rules.Concurrency(git)]] pages.
+
+
+## Feedback
+
+Please report any documentation errors, typos or suggestions to the [[Gendarme Mailing List|https://groups.google.com/forum/?fromgroups#!forum/gendarme]]. Thanks!
+
diff --git a/gendarme/rules/Gendarme.Rules.Concurrency/ReviewLockUsedOnlyForOperationsOnVariablesRule.cs b/gendarme/rules/Gendarme.Rules.Concurrency/ReviewLockUsedOnlyForOperationsOnVariablesRule.cs
index af249bd..621e362 100644
--- a/gendarme/rules/Gendarme.Rules.Concurrency/ReviewLockUsedOnlyForOperationsOnVariablesRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Concurrency/ReviewLockUsedOnlyForOperationsOnVariablesRule.cs
@@ -93,8 +93,10 @@ namespace Gendarme.Rules.Concurrency {
 			// if not then this rule does not need to be executed for the module
 			// note: mscorlib.dll is an exception since it defines, not refer, System.Threading.Monitor
 			Runner.AnalyzeModule += delegate (object o, RunnerEventArgs e) {
-				Active = (e.CurrentAssembly.Name.Name == "mscorlib") ||
-					e.CurrentModule.HasTypeReference ("System.Threading.Monitor");
+				Active = (e.CurrentAssembly.Name.Name == "mscorlib" ||
+					e.CurrentModule.AnyTypeReference ((TypeReference tr) => {
+						return tr.IsNamed ("System.Threading", "Monitor");
+					}));
 			};
 		}
 
@@ -154,9 +156,7 @@ namespace Gendarme.Rules.Concurrency {
 				return false;
 
 			MethodReference method = (ins.Operand as MethodReference);
-			if (method == null)
-				return false;
-			if ((method.Name != "Enter") || (method.DeclaringType.FullName != "System.Threading.Monitor"))
+			if (!method.IsNamed ("System.Threading", "Monitor", "Enter"))
 				return false;
 			return (parametersCount == method.Parameters.Count);
 		}
diff --git a/gendarme/rules/Gendarme.Rules.Concurrency/Test/DoNotLockOnThisOrTypesTest.cs b/gendarme/rules/Gendarme.Rules.Concurrency/Test/DoNotLockOnThisOrTypesTest.cs
index 707a537..4db0096 100644
--- a/gendarme/rules/Gendarme.Rules.Concurrency/Test/DoNotLockOnThisOrTypesTest.cs
+++ b/gendarme/rules/Gendarme.Rules.Concurrency/Test/DoNotLockOnThisOrTypesTest.cs
@@ -103,11 +103,20 @@ namespace Test.Rules.Concurrency {
 			}
 		}
 
+		static bool TryEnter (object obj)
+		{
+			lock (obj) {
+				Console.WriteLine ();
+			}
+			return true;
+		}
+
 		[Test]
 		public void StaticType ()
 		{
 			AssertRuleFailure<DoNotLockOnThisOrTypesTest> ("StaticLockType", 1);
 			AssertRuleFailure<DoNotLockOnThisOrTypesTest> ("StaticLockTypes", 2);
+			AssertRuleSuccess<DoNotLockOnThisOrTypesTest> ("TryEnter");
 		}
 
 		object instance_locker = new object ();
diff --git a/gendarme/rules/Gendarme.Rules.Concurrency/Test/Tests.Rules.Concurrency.csproj b/gendarme/rules/Gendarme.Rules.Concurrency/Test/Tests.Rules.Concurrency.csproj
index e272dcc..292cdd3 100755
--- a/gendarme/rules/Gendarme.Rules.Concurrency/Test/Tests.Rules.Concurrency.csproj
+++ b/gendarme/rules/Gendarme.Rules.Concurrency/Test/Tests.Rules.Concurrency.csproj
@@ -1,5 +1,5 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
-<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="3.5">
+<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="4.0">
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
     <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
@@ -12,9 +12,11 @@
     <AssemblyName>Tests.Rules.Concurrency</AssemblyName>
     <FileUpgradeFlags>
     </FileUpgradeFlags>
-    <OldToolsVersion>2.0</OldToolsVersion>
+    <OldToolsVersion>3.5</OldToolsVersion>
     <UpgradeBackupLocation>
     </UpgradeBackupLocation>
+    <IsWebBootstrapper>true</IsWebBootstrapper>
+    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
     <PublishUrl>http://localhost/Tests.Rules.Concurrency/</PublishUrl>
     <Install>true</Install>
     <InstallFrom>Web</InstallFrom>
@@ -27,10 +29,9 @@
     <MapFileExtensions>true</MapFileExtensions>
     <ApplicationRevision>0</ApplicationRevision>
     <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
-    <IsWebBootstrapper>true</IsWebBootstrapper>
     <UseApplicationTrust>false</UseApplicationTrust>
     <BootstrapperEnabled>true</BootstrapperEnabled>
-    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <TargetFrameworkProfile />
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
     <DebugSymbols>true</DebugSymbols>
@@ -40,6 +41,7 @@
     <DefineConstants>DEBUG;TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
     <DebugType>pdbonly</DebugType>
@@ -48,6 +50,7 @@
     <DefineConstants>TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <ItemGroup>
     <Reference Include="nunit.framework, Version=2.4.8.0, Culture=neutral, PublicKeyToken=96d09a1eb7f44a77, processorArchitecture=MSIL">
@@ -93,14 +96,33 @@
     </ProjectReference>
   </ItemGroup>
   <ItemGroup>
+    <BootstrapperPackage Include="Microsoft.Net.Client.3.5">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1 Client Profile</ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
     <BootstrapperPackage Include="Microsoft.Net.Framework.2.0">
       <Visible>False</Visible>
+      <ProductName>
+      </ProductName>
+      <Install>false</Install>
     </BootstrapperPackage>
     <BootstrapperPackage Include="Microsoft.Net.Framework.3.0">
       <Visible>False</Visible>
+      <ProductName>
+      </ProductName>
+      <Install>false</Install>
     </BootstrapperPackage>
     <BootstrapperPackage Include="Microsoft.Net.Framework.3.5">
       <Visible>False</Visible>
+      <ProductName>
+      </ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1</ProductName>
+      <Install>false</Install>
     </BootstrapperPackage>
   </ItemGroup>
   <Import Project="$(MSBuildBinPath)\Microsoft.CSharp.targets" />
diff --git a/gendarme/rules/Gendarme.Rules.Concurrency/ThreadRocks.cs b/gendarme/rules/Gendarme.Rules.Concurrency/ThreadRocks.cs
index e89969b..95fb166 100644
--- a/gendarme/rules/Gendarme.Rules.Concurrency/ThreadRocks.cs
+++ b/gendarme/rules/Gendarme.Rules.Concurrency/ThreadRocks.cs
@@ -119,7 +119,7 @@ namespace Gendarme.Rules.Concurrency {
 				}
 				
 			} else if (method.IsStatic) {
-				if (model == ThreadModel.Serializable && !method.Name.StartsWith ("op_")) {
+				if (model == ThreadModel.Serializable && !method.Name.StartsWith ("op_", StringComparison.Ordinal)) {
 					return ThreadModel.MainThread;
 				}
 			}
diff --git a/gendarme/rules/Gendarme.Rules.Concurrency/WriteStaticFieldFromInstanceMethodRule.cs b/gendarme/rules/Gendarme.Rules.Concurrency/WriteStaticFieldFromInstanceMethodRule.cs
index 686855d..9fa400f 100644
--- a/gendarme/rules/Gendarme.Rules.Concurrency/WriteStaticFieldFromInstanceMethodRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Concurrency/WriteStaticFieldFromInstanceMethodRule.cs
@@ -27,6 +27,7 @@
 //
 
 using System;
+using System.Globalization;
 
 using Mono.Cecil;
 using Mono.Cecil.Cil;
@@ -76,8 +77,6 @@ namespace Gendarme.Rules.Concurrency {
 	[EngineDependency (typeof (OpCodeEngine))]
 	public class WriteStaticFieldFromInstanceMethodRule : Rule, IMethodRule {
 
-		private const string ThreadStaticAttribute = "System.ThreadStaticAttribute";
-
 		static bool CheckField (FieldReference field)
 		{
 			// skip instance fields and generated static field (likely by the compiler)
@@ -92,7 +91,7 @@ namespace Gendarme.Rules.Concurrency {
 			// skip fields decorated with [ThreadStatic] (the runtime will use
 			// thread local storage for these so they are thread safe)
 			if (fd.HasCustomAttributes) {
-				if (fd.CustomAttributes.ContainsType (ThreadStaticAttribute))
+				if (fd.HasAttribute ("System", "ThreadStaticAttribute"))
 					return false;
 			}
 			return true;
@@ -118,7 +117,9 @@ namespace Gendarme.Rules.Concurrency {
 				if (ins.OpCode.Code == Code.Stsfld) {
 					FieldReference fr = (ins.Operand as FieldReference);
 					if (CheckField (fr)) {
-						string text = String.Format ("The static field '{0}', of type '{1}'. is being set in an instance method.", fr.Name, fr.FieldType);
+						string text = String.Format (CultureInfo.InvariantCulture,
+							"The static field '{0}', of type '{1}'. is being set in an instance method.", 
+							fr.Name, fr.FieldType);
 						Runner.Report (method, ins, Severity.Medium, Confidence.High, text);
 					}
 				}
diff --git a/gendarme/rules/Gendarme.Rules.Correctness/AttributeStringLiteralsShouldParseCorrectlyRule.cs b/gendarme/rules/Gendarme.Rules.Correctness/AttributeStringLiteralsShouldParseCorrectlyRule.cs
index d13758b..d75246e 100644
--- a/gendarme/rules/Gendarme.Rules.Correctness/AttributeStringLiteralsShouldParseCorrectlyRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Correctness/AttributeStringLiteralsShouldParseCorrectlyRule.cs
@@ -29,6 +29,7 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
+using System.Globalization;
 
 using Gendarme.Framework;
 using Gendarme.Framework.Rocks;
@@ -80,42 +81,16 @@ namespace Gendarme.Rules.Correctness {
 			return original.IndexOf (value, 0, StringComparison.OrdinalIgnoreCase) != -1;
 		}
 		
-		// FIXME : FX4 Version.TryParse @ http://msdn.microsoft.com/en-us/library/system.version.tryparse.aspx
-		static bool TryParseVersion (string version)
-		{
-			try {
-				new Version (version);
-				return true;
-			}
-			catch (FormatException) {
-				return false;
-			}
-			catch (ArgumentException) {
-				return false;
-			}
-		}
-
-		// FIXME : FX4 Guid.TryParse @ http://msdn.microsoft.com/en-us/library/system.guid.tryparse.aspx
-		static bool TryParseGuid (string guid)
-		{
-			try {
-				new Guid (guid);
-				return true;
-			}
-			catch (FormatException) {
-				return false;
-			}
-		}
-
 		void CheckParametersAndValues (IMetadataTokenProvider provider, IMethodSignature constructor, IList<CustomAttributeArgument> arguments)
 		{
 			for (int index = 0; index < arguments.Count; index++) {
 				ParameterDefinition parameter = constructor.Parameters[index];
-				if (String.Compare (parameter.ParameterType.FullName, "System.String") == 0) {
+				if (parameter.ParameterType.IsNamed ("System", "String")) {
 					string value = (string) arguments [index].Value;
-					if (Contains (parameter.Name, "version")) { 
-						if (!TryParseVersion (value)) {
-							string msg = String.Format ("The value passed: {0} can't be parsed to a valid Version.", value);
+					if (Contains (parameter.Name, "version")) {
+						Version v = null;
+						if (!Version.TryParse (value, out v)) {
+							string msg = String.Format (CultureInfo.InvariantCulture, "The value passed: {0} can't be parsed to a valid Version.", value);
 							Runner.Report (provider, Severity.High, Confidence.High, msg);
 						}
 						continue;
@@ -125,14 +100,15 @@ namespace Gendarme.Rules.Correctness {
 						Contains (parameter.Name, "urn")) {
 						Uri parsed = null;
 						if (!Uri.TryCreate (value, UriKind.Absolute, out parsed)) {
-							string msg = String.Format ("The valued passed {0} can't be parsed to a valid Uri.", value);
+							string msg = String.Format (CultureInfo.InvariantCulture, "The valued passed {0} can't be parsed to a valid Uri.", value);
 							Runner.Report (provider, Severity.High, Confidence.High, msg);
 						}
 						continue;
 					}
 					if (Contains (parameter.Name, "guid")) {
-						if (!TryParseGuid (value)) {
-							string msg = String.Format ("The valued passed {0} can't be parsed to a valid Guid.", value);
+						Guid g;
+						if (!Guid.TryParse (value, out g)) {
+							string msg = String.Format (CultureInfo.InvariantCulture, "The valued passed {0} can't be parsed to a valid Guid.", value);
 							Runner.Report (provider, Severity.High, Confidence.High, msg);
 						}
 						continue;
@@ -203,3 +179,4 @@ namespace Gendarme.Rules.Correctness {
 		}
 	}
 }
+
diff --git a/gendarme/rules/Gendarme.Rules.Correctness/AvoidCodeWithSideEffectsInConditionalCodeRule.cs b/gendarme/rules/Gendarme.Rules.Correctness/AvoidCodeWithSideEffectsInConditionalCodeRule.cs
index 7a4a569..8d96766 100644
--- a/gendarme/rules/Gendarme.Rules.Correctness/AvoidCodeWithSideEffectsInConditionalCodeRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Correctness/AvoidCodeWithSideEffectsInConditionalCodeRule.cs
@@ -34,6 +34,7 @@ using Mono.Cecil;
 using Mono.Cecil.Cil;
 using System;
 using System.Collections.Generic;
+using System.Globalization;
 
 namespace Gendarme.Rules.Correctness {
 
@@ -114,7 +115,8 @@ namespace Gendarme.Rules.Correctness {
 						
 						string name = Mutates (method, ins);
 						if (name != null) {
-							string mesg = string.Format ("{0}::{1} is conditionally compiled on {2} but mutates {3}",
+							string mesg = String.Format (CultureInfo.InvariantCulture, 
+								"{0}::{1} is conditionally compiled on {2} but mutates {3}",
 								target.DeclaringType.Name, target.Name, define, name);
 							Log.WriteLine (this, mesg);
 							
diff --git a/gendarme/rules/Gendarme.Rules.Correctness/AvoidConstructorsInStaticTypesRule.cs b/gendarme/rules/Gendarme.Rules.Correctness/AvoidConstructorsInStaticTypesRule.cs
index a4eac8b..fe51ad6 100644
--- a/gendarme/rules/Gendarme.Rules.Correctness/AvoidConstructorsInStaticTypesRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Correctness/AvoidConstructorsInStaticTypesRule.cs
@@ -106,7 +106,7 @@ namespace Gendarme.Rules.Correctness {
 				}
 			}
 
-			if (type.BaseType.FullName == "System.Object")
+			if (type.BaseType.IsNamed ("System", "Object"))
 				return true;
 
 			return IsAllStatic (type.BaseType.Resolve ());
diff --git a/gendarme/rules/Gendarme.Rules.Correctness/AvoidFloatingPointEqualityRule.cs b/gendarme/rules/Gendarme.Rules.Correctness/AvoidFloatingPointEqualityRule.cs
index 4c41820..7877367 100644
--- a/gendarme/rules/Gendarme.Rules.Correctness/AvoidFloatingPointEqualityRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Correctness/AvoidFloatingPointEqualityRule.cs
@@ -179,7 +179,7 @@ namespace Gendarme.Rules.Correctness {
 				case Code.Call:
 				case Code.Callvirt:
 					MemberReference member = instruction.Operand as MemberReference;
-					if ((member != null) && member.Name.Equals ("Equals") && member.DeclaringType.IsFloatingPoint ()) {
+					if ((member != null) && (member.Name == "Equals") && member.DeclaringType.IsFloatingPoint ()) {
 						Runner.Report (method, instruction, Severity.High, Confidence.Total, EqualsMessage);
 					}
 					break;
diff --git a/gendarme/rules/Gendarme.Rules.Correctness/AvoidMethodsWithSideEffectsInConditionalCodeRule.cs b/gendarme/rules/Gendarme.Rules.Correctness/AvoidMethodsWithSideEffectsInConditionalCodeRule.cs
index 264d8ff..8e84621 100644
--- a/gendarme/rules/Gendarme.Rules.Correctness/AvoidMethodsWithSideEffectsInConditionalCodeRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Correctness/AvoidMethodsWithSideEffectsInConditionalCodeRule.cs
@@ -34,6 +34,7 @@ using Mono.Cecil;
 using Mono.Cecil.Cil;
 using System;
 using System.Collections.Generic;
+using System.Globalization;
 
 namespace Gendarme.Rules.Correctness {
 
@@ -157,7 +158,8 @@ namespace Gendarme.Rules.Correctness {
 						
 						MethodReference impure = FindImpurity (method, ins);
 						if (impure != null) {
-							string mesg = string.Format ("{0}::{1} is conditionally compiled on {2} but uses the impure {3}::{4}",
+							string mesg = String.Format (CultureInfo.InvariantCulture, 
+								"{0}::{1} is conditionally compiled on {2} but uses the impure {3}::{4}",
 								target.DeclaringType.Name, target.Name, define, impure.DeclaringType.Name, impure.Name);
 							Log.WriteLine (this, mesg);
 							
@@ -207,7 +209,7 @@ namespace Gendarme.Rules.Correctness {
 				if (!attr.HasConstructorArguments)
 					continue;
 				if (StringConstructor.Matches (attr.Constructor)) {
-					if (attr.AttributeType.FullName == "System.Diagnostics.ConditionalAttribute") {
+					if (attr.AttributeType.IsNamed ("System.Diagnostics", "ConditionalAttribute")) {
 						return (string) attr.ConstructorArguments [0].Value;
 					}
 				}
@@ -258,7 +260,7 @@ namespace Gendarme.Rules.Correctness {
 			
 			if (method != null) {
 				TypeDefinition type = method.DeclaringType;
-				string type_name = type.FullName;
+				string type_name = type.GetFullName ();
 				string method_name = method.Name;
 
 				// getters
@@ -274,7 +276,7 @@ namespace Gendarme.Rules.Correctness {
 					return true;
 				
 				// operators
-				if (method_name.StartsWith ("op_") && method_name != "op_Implicit" && method_name != "op_Explicit")
+				if (method_name.StartsWith ("op_", StringComparison.Ordinal) && method_name != "op_Implicit" && method_name != "op_Explicit")
 					return true;
 					
 				// Contract methods (skip namespace)
@@ -282,10 +284,10 @@ namespace Gendarme.Rules.Correctness {
 					return true;
 					
 				// System.Predicate<T> and System.Comparison<T>
-				if (type_name.StartsWith ("System.Predicate`1"))
+				if (type_name.StartsWith ("System.Predicate`1", StringComparison.Ordinal))
 					return true;
 					
-				if (type_name.StartsWith ("System.Comparison`1"))
+				if (type_name.StartsWith ("System.Comparison`1", StringComparison.Ordinal))
 					return true;
 					
 				// delegate invocation
@@ -317,7 +319,7 @@ namespace Gendarme.Rules.Correctness {
 		static bool HasPureAttribute (IList<CustomAttribute> attrs)
 		{
 			foreach (CustomAttribute attr in attrs) {
-				if (attr.AttributeType.FullName.Contains ("PureAttribute")) {
+				if (attr.AttributeType.Name == "PureAttribute") {
 					return true;
 				}
 			}
diff --git a/gendarme/rules/Gendarme.Rules.Correctness/BadRecursiveInvocationRule.cs b/gendarme/rules/Gendarme.Rules.Correctness/BadRecursiveInvocationRule.cs
index 6593f04..356d11a 100644
--- a/gendarme/rules/Gendarme.Rules.Correctness/BadRecursiveInvocationRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Correctness/BadRecursiveInvocationRule.cs
@@ -99,10 +99,9 @@ namespace Gendarme.Rules.Correctness {
 			if (!explicit_interface && (t2r != null) && !t2r.IsInterface)
 				return true;
 
-			string t2name = t2.FullName;
 			// we're calling into an interface and this could be us!
 			foreach (MethodReference mr in method1.Resolve ().Overrides) {
-				if (t2name == mr.DeclaringType.FullName)
+				if (mr.DeclaringType.IsNamed (t2.Namespace, t2.Name))
 					return true;
 			}
 			return false;
@@ -134,7 +133,7 @@ namespace Gendarme.Rules.Correctness {
 					ParameterDefinition param = (ParameterDefinition) insn.Operand;
 					if (method.IsStatic)
 						paramNum++;
-					return (param.GetSequence () == paramNum);
+					return (param.Index == paramNum - 1);
 				case Code.Ldarg_0:
 				case Code.Ldarg_1:
 				case Code.Ldarg_2:
diff --git a/gendarme/rules/Gendarme.Rules.Correctness/CheckParametersNullityInVisibleMethodsRule.cs b/gendarme/rules/Gendarme.Rules.Correctness/CheckParametersNullityInVisibleMethodsRule.cs
index c5e0e64..506a9c0 100644
--- a/gendarme/rules/Gendarme.Rules.Correctness/CheckParametersNullityInVisibleMethodsRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Correctness/CheckParametersNullityInVisibleMethodsRule.cs
@@ -106,9 +106,9 @@ namespace Gendarme.Rules.Correctness {
 			if (parameter.IsOut)
 				return;
 
-			int sequence = parameter.GetSequence ();
+			int sequence = parameter.Index;
 			// ldarg this - 'this' cannot be null
-			if (sequence == 0)
+			if (sequence == -1)
 				return;
 
 			// was there a null check done before ?	
@@ -146,7 +146,7 @@ namespace Gendarme.Rules.Correctness {
 				return;
 
 			// avoid checking parameters where a null check was already found
-			if (has_null_check.Get (parameter.GetSequence ()))
+			if (has_null_check.Get (parameter.Index))
 				return;
 
 			Instruction next = ins.Next;
@@ -158,21 +158,21 @@ namespace Gendarme.Rules.Correctness {
 				nc = next.OpCode.Code;
 				break;
 			case Code.Isinst:
-				has_null_check.Set (parameter.GetSequence ());
+				has_null_check.Set (parameter.Index);
 				return;
 			}
 
 			if (null_compare.Get (nc)) {
-				has_null_check.Set (parameter.GetSequence ());
+				has_null_check.Set (parameter.Index);
 			} else {
 				// compare with null (next or previous to current instruction)
 				// followed by a CEQ instruction
 				if (nc == Code.Ldnull) {
 					if (next.Next.OpCode.Code == Code.Ceq)
-						has_null_check.Set (parameter.GetSequence ());
+						has_null_check.Set (parameter.Index);
 				} else if (nc == Code.Ceq) {
 					if (ins.Previous.OpCode.Code == Code.Ldnull)
-						has_null_check.Set (parameter.GetSequence ());
+						has_null_check.Set (parameter.Index);
 				}
 			}
 		}
@@ -204,7 +204,7 @@ namespace Gendarme.Rules.Correctness {
 					pi = pi.Previous;
 				ParameterDefinition p = pi.GetParameter (method);
 				if (p != null)
-					has_null_check.Set (p.GetSequence ());
+					has_null_check.Set (p.Index);
 			}
 		}
 
diff --git a/gendarme/rules/Gendarme.Rules.Correctness/DeclareEventsExplicitlyRule.cs b/gendarme/rules/Gendarme.Rules.Correctness/DeclareEventsExplicitlyRule.cs
new file mode 100644
index 0000000..442572e
--- /dev/null
+++ b/gendarme/rules/Gendarme.Rules.Correctness/DeclareEventsExplicitlyRule.cs
@@ -0,0 +1,96 @@
+//
+// Gendarme.Rules.Correctness.DeclareEventsExplicitlyRule
+//
+// Authors:
+//	Sebastien Pouliot <sebastien@ximian.com>
+//
+// Copyright (C) 2011 Novell, Inc (http://www.novell.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using Mono.Cecil;
+
+using Gendarme.Framework;
+
+namespace Gendarme.Rules.Correctness {
+
+	/// <summary>
+	/// This rule detect is an event handler was declared without the <c>event</c>
+	/// keyword, making the declaration a simple field in its type. Such occurances
+	/// are likely a typo and should be fixed.
+	/// </summary>
+	/// <example>
+	/// Bad example:
+	/// <code>
+	/// public class EventLess {
+	///	public static EventHandler&lt;EventArgs&gt; MyEvent;
+	/// }
+	/// </code>
+	/// </example>
+	/// <example>
+	/// Good example:
+	/// <code>
+	/// public class Event {
+	///	public static event EventHandler&lt;EventArgs&gt; MyEvent;
+	/// }
+	/// </code>
+	/// </example>
+	// suggested in https://bugzilla.novell.com/show_bug.cgi?id=669192
+	[Problem ("An event handler was declared without the 'event' keyword")]
+	[Solution ("Add the missing 'event' keyword to your event handler declaration")]
+	public class DeclareEventsExplicitlyRule : Rule, ITypeRule {
+
+		static bool LookForEvent (MemberReference field, TypeDefinition type)
+		{
+			string fname = field.Name;
+			foreach (EventDefinition evnt in type.Events) {
+				if (fname == evnt.Name)
+					return true;
+			}
+			return false;
+		}
+
+		public RuleResult CheckType (TypeDefinition type)
+		{
+			if (!type.HasFields || type.IsEnum)
+				return RuleResult.DoesNotApply;
+
+			// allow to short-circuit LookForEvent if the type has no event
+			bool has_events = type.HasEvents;
+			foreach (FieldDefinition field in type.Fields) {
+				TypeReference ftype = field.FieldType;
+				if (ftype.Namespace != "System")
+					continue;
+
+				switch (ftype.Name) {
+				case "EventHandler":
+				case "EventHandler`1":
+					// is there (any?) event matching the field name ?
+					if (!has_events || !LookForEvent (field, type))
+						Runner.Report (field, Severity.High, Confidence.High);
+					break;
+				}
+			}
+
+			return Runner.CurrentRuleResult;
+		}
+	}
+}
diff --git a/gendarme/rules/Gendarme.Rules.Correctness/DisposableFieldsShouldBeDisposedRule.cs b/gendarme/rules/Gendarme.Rules.Correctness/DisposableFieldsShouldBeDisposedRule.cs
index 576fff2..7152176 100644
--- a/gendarme/rules/Gendarme.Rules.Correctness/DisposableFieldsShouldBeDisposedRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Correctness/DisposableFieldsShouldBeDisposedRule.cs
@@ -30,6 +30,7 @@
 
 using System;
 using System.Collections.Generic;
+using System.Globalization;
 
 using Mono.Cecil;
 using Mono.Cecil.Cil;
@@ -116,7 +117,7 @@ namespace Gendarme.Rules.Correctness {
 
 			// note: other rule will complain if there are disposable or native fields
 			// in a type that doesn't implement IDisposable, so we don't bother here
-			if (!type.Implements ("System.IDisposable"))
+			if (!type.Implements ("System", "IDisposable"))
 				return RuleResult.DoesNotApply;
 
 			MethodDefinition implicitDisposeMethod = GetNonAbstractMethod (type, MethodSignatures.Dispose);
@@ -148,7 +149,7 @@ namespace Gendarme.Rules.Correctness {
 				TypeDefinition fieldType = field.FieldType.Resolve ();
 				if (fieldType == null)
 					continue;
-				if (fieldType.Implements ("System.IDisposable"))
+				if (fieldType.Implements ("System", "IDisposable"))
 					disposeableFields.Add (field);
 			}
 
@@ -177,10 +178,10 @@ namespace Gendarme.Rules.Correctness {
 		private void CheckBaseDispose (TypeDefinition type, MethodDefinition implicitDisposeMethod, MethodDefinition explicitDisposeMethod)
 		{
 			TypeDefinition baseType = type;
-			while (baseType.BaseType.FullName != "System.Object") {
+			while (!baseType.BaseType.IsNamed ("System", "Object")) {
 				baseType = baseType.BaseType.Resolve ();
 				// also checks parents, so no need to search further
-				if ((baseType == null) || !baseType.Implements ("System.IDisposable"))
+				if ((baseType == null) || !baseType.Implements ("System", "IDisposable"))
 					break;
 
 				//we just check for Dispose() here
@@ -196,7 +197,7 @@ namespace Gendarme.Rules.Correctness {
 			}
 		}
 
-		private void CheckIfBaseDisposeIsCalled (MethodDefinition method, MethodDefinition baseMethod)
+		private void CheckIfBaseDisposeIsCalled (MethodDefinition method, MemberReference baseMethod)
 		{
 			bool found = false;
 
@@ -215,7 +216,7 @@ namespace Gendarme.Rules.Correctness {
 						if (call.OpCode.Code != Code.Call && call.OpCode.Code != Code.Callvirt)
 							continue;
 						MethodReference calledMethod = (MethodReference) call.Operand;
-						if (calledMethod.ToString () != baseMethod.ToString ())
+						if (calledMethod.GetFullName () != baseMethod.GetFullName ())
 							continue;
 						found = true;
 					}
@@ -223,7 +224,7 @@ namespace Gendarme.Rules.Correctness {
 			}
 
 			if (!found) {
-				string s = String.Format ("{0} should call base.Dispose().", method.ToString ());
+				string s = String.Format (CultureInfo.InvariantCulture, "{0} should call base.Dispose().", method.GetFullName ());
 				Runner.Report (method, Severity.Medium, Confidence.High, s);
 			}
 		}
@@ -256,7 +257,8 @@ namespace Gendarme.Rules.Correctness {
 				return;
 
 			foreach (FieldDefinition field in fields) {
-				string s = string.Format ("Since {0} is Disposable {1}() should call {0}.Dispose()", field.Name, method.Name);
+				string s = String.Format (CultureInfo.InvariantCulture, 
+					"Since {0} is Disposable {1}() should call {0}.Dispose()", field.Name, method.Name);
 				Runner.Report (field, Severity.High, Confidence.High, s);
 			}
 		}
diff --git a/gendarme/rules/Gendarme.Rules.Correctness/DoNotRoundIntegersRule.cs b/gendarme/rules/Gendarme.Rules.Correctness/DoNotRoundIntegersRule.cs
index a788d00..64172e6 100644
--- a/gendarme/rules/Gendarme.Rules.Correctness/DoNotRoundIntegersRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Correctness/DoNotRoundIntegersRule.cs
@@ -27,11 +27,14 @@
 //
 
 using System;
+using System.Globalization;
 
 using Mono.Cecil;
 using Mono.Cecil.Cil;
 
 using Gendarme.Framework;
+using Gendarme.Framework.Engines;
+using Gendarme.Framework.Helpers;
 using Gendarme.Framework.Rocks;
 
 namespace Gendarme.Rules.Correctness {
@@ -41,8 +44,8 @@ namespace Gendarme.Rules.Correctness {
 	// ICAST: int value cast to float and then passed to Math.round (ICAST_INT_CAST_TO_FLOAT_PASSED_TO_ROUND)
 
 	/// <summary>
-	/// This rule check for attempts to call <c>Round</c>, <c>Ceiling</c>, <c>Floor</c> or
-	/// <c>Truncate</c> on an integral type. This often indicate a typo in the source code
+	/// This rule check for attempts to call <c>System.Math.Round</c>, <c>System.Math.Ceiling</c>, <c>System.Math.Floor</c> or
+	/// <c>System.Math.Truncate</c> on an integral type. This often indicate a typo in the source code
 	/// (e.g. wrong variable) or an unnecessary operation.
 	/// </summary>
 	/// <example>
@@ -63,10 +66,10 @@ namespace Gendarme.Rules.Correctness {
 	/// }
 	/// </code>
 	/// </example>
-	/// <remarks>This rule is available since Gendarme 2.0</remarks>
 
 	[Problem ("This method calls round/ceil/floor/truncate with an integer value.")]
 	[Solution ("Verify the code logic. This could be a typo (wrong variable) or an unnecessary operation.")]
+	[EngineDependency (typeof (OpCodeEngine))]
 	public class DoNotRoundIntegersRule : Rule, IMethodRule {
 
 		static TypeReference GetType (Instruction ins, MethodDefinition method)
@@ -105,8 +108,8 @@ namespace Gendarme.Rules.Correctness {
 				if (rv.IsFloatingPoint ())
 					return null;
 				// but convertion into decimals are not...
-				if (rv.FullName == "System.Decimal") {
-					if (mr.DeclaringType.FullName != "System.Decimal")
+				if (rv.IsNamed ("System", "Decimal")) {
+					if (!mr.DeclaringType.IsNamed ("System", "Decimal"))
 						return null;
 
 					// ... unless it's a convertion from a FP value
@@ -137,9 +140,13 @@ namespace Gendarme.Rules.Correctness {
 			if (!method.HasBody)
 				return RuleResult.DoesNotApply;
 
+			// exclude methods that don't have calls
+			if (!OpCodeBitmask.Calls.Intersect (OpCodeEngine.GetBitmask (method)))
+				return RuleResult.DoesNotApply;
+
 			foreach (Instruction ins in method.Body.Instructions) {
 				MethodReference mr = ins.GetMethod ();
-				if ((mr == null) || (mr.DeclaringType.FullName != "System.Math"))
+				if ((mr == null) || !mr.DeclaringType.IsNamed ("System", "Math"))
 					continue;
 
 				Instruction value = null;
@@ -171,7 +178,8 @@ namespace Gendarme.Rules.Correctness {
 				if (type == null)
 					continue;
 
-				string msg = string.Format ("Math.{0} called on a {1}.", name, type.FullName);
+				string msg = String.Format (CultureInfo.InvariantCulture, "Math.{0} called on a {1}.", 
+					name, type.GetFullName ());
 				Runner.Report (method, ins, Severity.Medium, Confidence.Normal, msg);
 			}
 			return Runner.CurrentRuleResult;
diff --git a/gendarme/rules/Gendarme.Rules.Correctness/DontCompareWithNaNRule.cs b/gendarme/rules/Gendarme.Rules.Correctness/DontCompareWithNaNRule.cs
index ffa5a6b..0de96ec 100644
--- a/gendarme/rules/Gendarme.Rules.Correctness/DontCompareWithNaNRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Correctness/DontCompareWithNaNRule.cs
@@ -74,21 +74,6 @@ namespace Gendarme.Rules.Correctness {
 		private const string EqualityMessage = "A floating point value is compared (== or !=) with [Single|Double].NaN.";
 		private const string EqualsMessage = "[Single|Double].Equals is called using NaN.";
 
-		private static string[] FloatingPointTypes = { "System.Single", "System.Double" };
-
-		public override void Initialize (IRunner runner)
-		{
-			base.Initialize (runner);
-
-			// we want to avoid checking all methods if the module doesn't refer to either
-			// System.Single or System.Double (big performance difference)
-			// note: mscorlib.dll is an exception since it defines, not refer, System.Single and Double
-			Runner.AnalyzeModule += delegate (object o, RunnerEventArgs e) {
-				Active = (e.CurrentAssembly.Name.Name == "mscorlib") ||
-					e.CurrentModule.HasAnyTypeReference (FloatingPointTypes);
-			};
-		}
-
 		private static bool CheckPrevious (IList<Instruction> il, int index)
 		{
 			for (int i = index; i >= 0; i--) {
@@ -143,7 +128,7 @@ namespace Gendarme.Rules.Correctness {
 				case Code.Call:
 				case Code.Callvirt:
 					MemberReference callee = ins.Operand as MemberReference;
-					if ((callee != null) && callee.Name.Equals ("Equals") && callee.DeclaringType.IsFloatingPoint ()) {
+					if ((callee != null) && (callee.Name == "Equals") && callee.DeclaringType.IsFloatingPoint ()) {
 						if (!CheckPrevious (il, i - 1)) {
 							Runner.Report (method, ins, Severity.Critical, Confidence.Total, EqualsMessage);
 						}
diff --git a/gendarme/rules/Gendarme.Rules.Correctness/EnsureLocalDisposalRule.cs b/gendarme/rules/Gendarme.Rules.Correctness/EnsureLocalDisposalRule.cs
index 14c0c33..6d1c73d 100644
--- a/gendarme/rules/Gendarme.Rules.Correctness/EnsureLocalDisposalRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Correctness/EnsureLocalDisposalRule.cs
@@ -3,8 +3,10 @@
 //
 // Authors:
 //	Cedric Vivier <cedricv@neonux.com>
+//	Sebastien Pouliot <sebastien@ximian.com>
 //
 // Copyright (C) 2008 Cedric Vivier
+// Copyright (C) 2011 Novell, Inc (http://www.novell.com)
 //
 // Permission is hereby granted, free of charge, to any person obtaining a copy
 // of this software and associated documentation files (the "Software"), to deal
@@ -26,6 +28,7 @@
 
 using System;
 using System.Collections.Generic;
+using System.Globalization;
 
 using Mono.Cecil;
 using Mono.Cecil.Cil;
@@ -115,7 +118,7 @@ namespace Gendarme.Rules.Correctness {
 	public sealed class EnsureLocalDisposalRule : Rule, IMethodRule {
 
 		OpCodeBitmask callsAndNewobjBitmask = BuildCallsAndNewobjOpCodeBitmask ();
-		HashSet<Instruction> suspectLocals = new HashSet<Instruction> ();
+		Bitmask<ulong> locals = new Bitmask<ulong> ();
 
 		static bool IsDispose (MethodReference call)
 		{
@@ -134,57 +137,109 @@ namespace Gendarme.Rules.Correctness {
 			if (method.IsConstructor) {
 				if (method.DeclaringType.IsGeneratedCode ())
 					return false; //eg. generators
-				return method.DeclaringType.Implements ("System.IDisposable");
+				return method.DeclaringType.Implements ("System", "IDisposable");
 			}
 
-			return method.ReturnType.Implements ("System.IDisposable");
+			return method.ReturnType.Implements ("System", "IDisposable");
 		}
 
-		static bool AreBothInstructionsInSameTryFinallyBlock (MethodBody body, Instruction a, Instruction b)
+		static bool IsSetter (MethodReference m)
 		{
+			if (m == null)
+				return false;
+			MethodDefinition md = m.Resolve ();
+			if (md == null)
+				return m.Name.StartsWith ("set_", StringComparison.Ordinal);
+			return md.IsSetter;
+		}
+
+		static bool IsInsideFinallyBlock (MethodDefinition method, Instruction ins)
+		{
+			MethodBody body = method.Body;
+			if (!body.HasExceptionHandlers)
+				return false;
+
 			foreach (ExceptionHandler eh in body.ExceptionHandlers) {
 				if (eh.HandlerType != ExceptionHandlerType.Finally)
 					continue;
-				if (eh.TryStart.Offset <= a.Next.Offset && eh.TryEnd.Offset >= a.Offset
-					&& eh.HandlerStart.Offset <= b.Offset && eh.HandlerEnd.Offset >= b.Offset)
+				if (ins.Offset >= eh.HandlerStart.Offset || ins.Offset < eh.HandlerEnd.Offset)
 					return true;
 			}
 			return false;
 		}
 
-		static Instruction LocalTraceBack (IMethodSignature method, Instruction ins)
+		void Clear (MethodDefinition method, Instruction ins)
 		{
-			ins = ins.TraceBack (method);
-			while (ins != null) {
-				if (ins.IsLoadLocal () || ins.IsStoreLocal ())
-					return ins;
-				ins = ins.TraceBack (method);
+			VariableDefinition v = ins.GetVariable (method);
+			if (v != null)
+				locals.Clear ((ulong) v.Index);
+		}
+
+		void CheckForReturn (MethodDefinition method, Instruction ins)
+		{
+			if (ins.IsLoadLocal ())
+				Clear (method, ins);
+		}
+
+		void CheckForOutParameters (MethodDefinition method, Instruction ins)
+		{
+			Instruction iref = ins.TraceBack (method);
+			if (iref == null)
+				return;
+			ParameterDefinition p = iref.GetParameter (method);
+			if ((p != null) && p.IsOut) {
+				ins = ins.Previous;
+				if (ins.IsLoadLocal ())
+					Clear (method, ins);
 			}
-			return null;
 		}
 
-		Instruction FindRelatedSuspectLocal (MethodDefinition method, Instruction ins)
+		void CheckDisposeCalls (MethodDefinition method, Instruction ins)
 		{
-			ins = LocalTraceBack (method, ins);
-			if (null == ins)
-				return null;
-
-			int index = ins.GetVariable (method).Index;
-			foreach (var local in suspectLocals) {
-				if (local.GetVariable (method).Index == index)
-					return local;
+			Instruction instance = ins.TraceBack (method);
+			if (instance == null)
+				return;
+
+			VariableDefinition v = instance.GetVariable (method);
+			ulong index = v == null ? UInt64.MaxValue : (ulong) v.Index;
+			if (v != null && locals.Get (index)) {
+				if (!IsInsideFinallyBlock (method, ins)) {
+					string msg = String.Format (CultureInfo.InvariantCulture,
+						"Local {0}is not guaranteed to be disposed of.",
+						GetFriendlyNameOrEmpty (v));
+					Runner.Report (method, Severity.Medium, Confidence.Normal, msg);
+				}
+				locals.Clear (index);
 			}
-			return null;
 		}
 
-		static bool IsSetter (MethodReference m)
+		bool CheckCallsToOtherInstances (MethodDefinition method, Instruction ins, MethodReference call)
 		{
-			if (m == null)
+			Instruction p = ins.TraceBack (method, 0);
+			if (p.Is (Code.Ldarg_0))
 				return false;
-			MethodDefinition md = m.Resolve ();
-			if (md == null)
-				return m.Name.StartsWith ("set_", StringComparison.Ordinal);
-			return md.IsSetter;
+
+			if (call.HasParameters) {
+				for (int i = 1; i <= call.Parameters.Count; i++) {
+					p = ins.TraceBack (method, -i);
+					Clear (method, p);
+				}
+			}
+			return true;
+		}
+
+		void CheckReassignment (MethodDefinition method, Instruction ins)
+		{
+			VariableDefinition v = ins.GetVariable (method);
+			ulong index = (ulong) v.Index;
+			if (locals.Get (index)) {
+				string msg = String.Format (CultureInfo.InvariantCulture,
+					"Local {0}is not disposed before being re-assigned.",
+					GetFriendlyNameOrEmpty (v));
+				Runner.Report (method, ins, Severity.High, Confidence.Normal, msg);
+			} else {
+				locals.Set (index);
+			}
 		}
 
 		public RuleResult CheckMethod (MethodDefinition method)
@@ -193,36 +248,42 @@ namespace Gendarme.Rules.Correctness {
 				return RuleResult.DoesNotApply;
 
 			//is there any potential IDisposable-getting opcode in the method?
-			OpCodeBitmask methodBitmask = OpCodeEngine.GetBitmask (method);
-			if (!callsAndNewobjBitmask.Intersect (methodBitmask))
+			if (!callsAndNewobjBitmask.Intersect (OpCodeEngine.GetBitmask (method)))
 				return RuleResult.DoesNotApply;
 
-			//we ignore methods/constructors that returns IDisposable themselves
-			//where local(s) are most likely used for disposable object construction
-			if (DoesReturnDisposable (method))
-				return RuleResult.DoesNotApply;
+			// we will not report IDiposable locals that are returned from a method
+			bool return_idisposable = DoesReturnDisposable (method);
 
-			suspectLocals.Clear ();
+			locals.ClearAll ();
 
-			MethodBody body = method.Body;
-			foreach (Instruction ins in body.Instructions) {
-				if (!callsAndNewobjBitmask.Get (ins.OpCode.Code))
+			foreach (Instruction ins in method.Body.Instructions) {
+				Code code = ins.OpCode.Code;
+				switch (code) {
+				case Code.Ret:
+					if (return_idisposable)
+						CheckForReturn (method, ins.Previous);
 					continue;
+				case Code.Stind_Ref:
+					CheckForOutParameters (method, ins);
+					continue;
+				default:
+					if (!callsAndNewobjBitmask.Get (code))
+						continue;
+					break;
+				}
 
 				MethodReference call = (MethodReference) ins.Operand;
 
 				if (IsDispose (call)) {
-					Instruction local = FindRelatedSuspectLocal (method, ins);
-					if (local != null) {
-						if (!AreBothInstructionsInSameTryFinallyBlock (body, local, ins)) {
-							string msg = string.Format ("Local {0}is not guaranteed to be disposed of.", GetFriendlyNameOrEmpty (local.GetVariable (method)));
-							Runner.Report (method, local, Severity.Medium, Confidence.Normal, msg);
-						}
-						suspectLocals.Remove (local);
-					}
+					CheckDisposeCalls (method, ins);
 					continue;
 				}
 
+				if (call.HasThis && (code != Code.Newobj)) {
+					if (!CheckCallsToOtherInstances (method, ins, call))
+						continue;
+				}
+
 				if (!DoesReturnDisposable (call))
 					continue;
 
@@ -233,40 +294,47 @@ namespace Gendarme.Rules.Correctness {
 				Code nextCode = nextInstruction.OpCode.Code;
 				if (nextCode == Code.Pop || OpCodeBitmask.Calls.Get (nextCode)) {
 					// We ignore setter because it is an obvious share of the IDisposable
-					if (IsSetter (nextInstruction.Operand as MethodReference))
-						continue;
-
-					ReportCall (method, ins, call);
-					continue;
+					if (!IsSetter (nextInstruction.Operand as MethodReference))
+						ReportCall (method, ins, call);
+				} else if (nextInstruction.IsStoreLocal ()) {
+					// make sure we're not re-assigning over a non-disposed IDisposable
+					CheckReassignment (method, nextInstruction);
 				}
-				
-				//even if an IDisposable, it isn't stored in a local
-				if (nextInstruction.IsStoreLocal ())
-					suspectLocals.Add (nextInstruction);
 			}
 
-			foreach (var local in suspectLocals) {
-				string msg = string.Format ("Local {0}is not disposed of (at least not locally).", GetFriendlyNameOrEmpty (local.GetVariable (method)));
-				Runner.Report (method, local, Severity.High, Confidence.Normal, msg);
-			}
+			ReportNonDisposedLocals (method);
 
 			return Runner.CurrentRuleResult;
 		}
 
+		void ReportNonDisposedLocals (MethodDefinition method)
+		{
+			for (ulong i = 0; i < 64; i++) {
+				if (!locals.Get (i))
+					continue;
+				string msg = String.Format (CultureInfo.InvariantCulture,
+					"Local {0}is not disposed of (at least not locally).",
+					GetFriendlyNameOrEmpty (method.Body.Variables [(int) i]));
+				Runner.Report (method, Severity.High, Confidence.Normal, msg);
+			}
+		}
+
 		static bool IsFluentLike (MethodReference method)
 		{
-			string rtype = method.ReturnType.FullName;
+			TypeReference rtype = method.ReturnType;
+			string nspace = rtype.Namespace;
+			string name = rtype.Name;
 			// StringBuilder StringBuilder.Append (...)
-			if (rtype == method.DeclaringType.FullName)
+			if (method.DeclaringType.IsNamed (nspace, name))
 				return true;
-			return (method.HasParameters && rtype == method.Parameters [0].ParameterType.FullName);
+			return (method.HasParameters && method.Parameters [0].ParameterType.IsNamed (nspace, name));
 		}
 
 		void ReportCall (MethodDefinition method, Instruction ins, MethodReference call)
 		{
 			TypeReference type = ins.Is (Code.Newobj) ? call.DeclaringType : call.ReturnType;
 			bool fluent = IsFluentLike (call);
-			string msg = string.Format ("Local of type '{0}' is not disposed of ({1}).",
+			string msg = String.Format (CultureInfo.InvariantCulture, "Local of type '{0}' is not disposed of ({1}).",
 				type.Name, fluent ? "is this a fluent-like API ?" : "at least not locally");
 			Runner.Report (method, ins, Severity.High, fluent ? Confidence.Normal : Confidence.High, msg);
 		}
@@ -275,8 +343,8 @@ namespace Gendarme.Rules.Correctness {
 		{
 			string tname = variable.VariableType.Name;
 			if (variable.IsGeneratedName ())
-				return string.Format ("of type '{0}' ", tname);
-			return string.Format ("'{0}' of type '{1}' ", variable.Name, tname);
+				return String.Format (CultureInfo.InvariantCulture, "of type '{0}' ", tname);
+			return String.Format (CultureInfo.InvariantCulture, "'{0}' of type '{1}' ", variable.Name, tname);
 		}
 
 		static OpCodeBitmask BuildCallsAndNewobjOpCodeBitmask ()
diff --git a/gendarme/rules/Gendarme.Rules.Correctness/FloatComparisonRule.cs b/gendarme/rules/Gendarme.Rules.Correctness/FloatComparisonRule.cs
index 39f8fe7..51d5806 100644
--- a/gendarme/rules/Gendarme.Rules.Correctness/FloatComparisonRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Correctness/FloatComparisonRule.cs
@@ -41,8 +41,6 @@ namespace Gendarme.Rules.Correctness {
 	[EngineDependency (typeof (OpCodeEngine))]
 	abstract public class FloatingComparisonRule : Rule {
 
-		private static string[] FloatingPointTypes = { "System.Single", "System.Double" };
-
 		public override void Initialize (IRunner runner)
 		{
 			base.Initialize (runner);
@@ -52,7 +50,9 @@ namespace Gendarme.Rules.Correctness {
 			// note: mscorlib.dll is an exception since it defines, not refer, System.Single and Double
 			Runner.AnalyzeModule += delegate (object o, RunnerEventArgs e) {
 				Active = (e.CurrentAssembly.Name.Name == "mscorlib") ||
-					e.CurrentModule.HasAnyTypeReference (FloatingPointTypes);
+					e.CurrentModule.AnyTypeReference ((TypeReference tr) => {
+						return tr.IsFloatingPoint ();
+					});
 			};
 		}
 
diff --git a/gendarme/rules/Gendarme.Rules.Correctness/Gendarme.Rules.Correctness.csproj b/gendarme/rules/Gendarme.Rules.Correctness/Gendarme.Rules.Correctness.csproj
index 505ef8f..4258d86 100755
--- a/gendarme/rules/Gendarme.Rules.Correctness/Gendarme.Rules.Correctness.csproj
+++ b/gendarme/rules/Gendarme.Rules.Correctness/Gendarme.Rules.Correctness.csproj
@@ -1,5 +1,5 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
-<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="3.5">
+<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="4.0">
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
     <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
@@ -12,9 +12,11 @@
     <AssemblyName>Gendarme.Rules.Correctness</AssemblyName>
     <FileUpgradeFlags>
     </FileUpgradeFlags>
-    <OldToolsVersion>2.0</OldToolsVersion>
+    <OldToolsVersion>3.5</OldToolsVersion>
     <UpgradeBackupLocation>
     </UpgradeBackupLocation>
+    <IsWebBootstrapper>true</IsWebBootstrapper>
+    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
     <PublishUrl>http://localhost/Gendarme.Rules.Correctness/</PublishUrl>
     <Install>true</Install>
     <InstallFrom>Web</InstallFrom>
@@ -27,10 +29,9 @@
     <MapFileExtensions>true</MapFileExtensions>
     <ApplicationRevision>0</ApplicationRevision>
     <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
-    <IsWebBootstrapper>true</IsWebBootstrapper>
     <UseApplicationTrust>false</UseApplicationTrust>
     <BootstrapperEnabled>true</BootstrapperEnabled>
-    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <TargetFrameworkProfile />
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
     <DebugSymbols>true</DebugSymbols>
@@ -43,6 +44,7 @@
     <DocumentationFile>..\..\console\bin\Debug\Gendarme.Rules.Correctness.xml</DocumentationFile>
     <NoWarn>1591</NoWarn>
     <WarningsAsErrors>1570</WarningsAsErrors>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
     <DebugType>pdbonly</DebugType>
@@ -54,6 +56,7 @@
     <DocumentationFile>..\..\console\bin\Release\Gendarme.Rules.Correctness.xml</DocumentationFile>
     <NoWarn>1591</NoWarn>
     <WarningsAsErrors>1570</WarningsAsErrors>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <ItemGroup>
     <Reference Include="System" />
@@ -107,6 +110,9 @@
     <Compile Include="ReviewUseOfInt64BitsToDoubleRule.cs" />
     <Compile Include="ReviewUselessControlFlowRule.cs" />
     <Compile Include="ReviewUseOfModuloOneOnIntegersRule.cs" />
+    <Compile Include="TypesShouldBeDisposableBaseRule.cs" />
+    <Compile Include="TypesWithDisposableFieldsShouldBeDisposableRule.cs" />
+    <Compile Include="TypesWithNativeFieldsShouldBeDisposableRule.cs" />
     <Compile Include="UseNoInliningWithGetCallingAssemblyRule.cs" />
     <Compile Include="UseValueInPropertySetterRule.cs" />
     <None Include="ChangeLog" />
@@ -129,14 +135,33 @@
     </ProjectReference>
   </ItemGroup>
   <ItemGroup>
+    <BootstrapperPackage Include="Microsoft.Net.Client.3.5">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1 Client Profile</ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
     <BootstrapperPackage Include="Microsoft.Net.Framework.2.0">
       <Visible>False</Visible>
+      <ProductName>
+      </ProductName>
+      <Install>false</Install>
     </BootstrapperPackage>
     <BootstrapperPackage Include="Microsoft.Net.Framework.3.0">
       <Visible>False</Visible>
+      <ProductName>
+      </ProductName>
+      <Install>false</Install>
     </BootstrapperPackage>
     <BootstrapperPackage Include="Microsoft.Net.Framework.3.5">
       <Visible>False</Visible>
+      <ProductName>
+      </ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1</ProductName>
+      <Install>false</Install>
     </BootstrapperPackage>
   </ItemGroup>
   <Import Project="$(MSBuildBinPath)\Microsoft.CSharp.targets" />
diff --git a/gendarme/rules/Gendarme.Rules.Correctness/Makefile.am b/gendarme/rules/Gendarme.Rules.Correctness/Makefile.am
index 9dabf5f..a338289 100644
--- a/gendarme/rules/Gendarme.Rules.Correctness/Makefile.am
+++ b/gendarme/rules/Gendarme.Rules.Correctness/Makefile.am
@@ -6,6 +6,7 @@ rules_sources =  \
 	AvoidConstructorsInStaticTypesRule.cs \
 	AvoidFloatingPointEqualityRule.cs \
 	AvoidMethodsWithSideEffectsInConditionalCodeRule.cs \
+	DeclareEventsExplicitlyRule.cs \
 	DoNotRecurseInEqualityRule.cs \
 	BadRecursiveInvocationRule.cs \
 	CallingEqualsWithNullArgRule.cs \
@@ -29,6 +30,9 @@ rules_sources =  \
 	ReviewUselessControlFlowRule.cs \
 	ReviewUseOfInt64BitsToDoubleRule.cs \
 	ReviewUseOfModuloOneOnIntegersRule.cs \
+	TypesShouldBeDisposableBaseRule.cs \
+	TypesWithDisposableFieldsShouldBeDisposableRule.cs \
+	TypesWithNativeFieldsShouldBeDisposableRule.cs \
 	UseNoInliningWithGetCallingAssemblyRule.cs \
 	UseValueInPropertySetterRule.cs
 
@@ -50,6 +54,7 @@ tests_sources = \
 	AvoidConstructorsInStaticTypesTest.cs \
 	AvoidFloatingPointEqualityTest.cs \
 	AvoidMethodsWithSideEffectsInConditionalCodeTest.cs \
+	DeclareEventsExplicitlyTest.cs \
 	DoNotRecurseInEqualityTest.cs \
 	BadRecursiveInvocationTest.cs \
 	CallingEqualsWithNullArgTest.cs \
@@ -73,5 +78,7 @@ tests_sources = \
 	ReviewUselessControlFlowTest.cs \
 	ReviewUseOfInt64BitsToDoubleTest.cs \
 	ReviewUseOfModuloOneOnIntegersTest.cs \
+	TypesWithDisposableFieldsShouldBeDisposableTest.cs \
+	TypesWithNativeFieldsShouldBeDisposableTest.cs \
 	UseNoInliningWithGetCallingAssemblyTest.cs \
 	UseValueInPropertySetterTest.cs
diff --git a/gendarme/rules/Gendarme.Rules.Correctness/MethodCanBeMadeStaticRule.cs b/gendarme/rules/Gendarme.Rules.Correctness/MethodCanBeMadeStaticRule.cs
index bab18df..b760958 100644
--- a/gendarme/rules/Gendarme.Rules.Correctness/MethodCanBeMadeStaticRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Correctness/MethodCanBeMadeStaticRule.cs
@@ -114,7 +114,7 @@ namespace Gendarme.Rules.Correctness {
 
 			// methods with [Conditional] can be empty (not using 'this') IL-wise but not source-wise, ignore them
 			if (method.HasCustomAttributes) {
-				if (method.CustomAttributes.ContainsType ("System.Diagnostics.ConditionalAttribute"))
+				if (method.HasAttribute ("System.Diagnostics", "ConditionalAttribute"))
 					return RuleResult.DoesNotApply;
 			}
 
@@ -130,7 +130,7 @@ namespace Gendarme.Rules.Correctness {
 			foreach (Instruction instr in method.Body.Instructions) {
 				if (instr.OpCode.Code == Code.Ldarg) {
 					ParameterDefinition pd = (instr.Operand as ParameterDefinition);
-					if (pd.GetSequence () == 0)
+					if (pd.Index == -1)
 						return RuleResult.Success;
 				}
 			}
diff --git a/gendarme/rules/Gendarme.Rules.Correctness/ProvideCorrectArgumentsToFormattingMethodsRule.cs b/gendarme/rules/Gendarme.Rules.Correctness/ProvideCorrectArgumentsToFormattingMethodsRule.cs
index f545495..92b5753 100644
--- a/gendarme/rules/Gendarme.Rules.Correctness/ProvideCorrectArgumentsToFormattingMethodsRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Correctness/ProvideCorrectArgumentsToFormattingMethodsRule.cs
@@ -28,10 +28,11 @@
 //
 
 using System;
-using System.IO;
-using System.Resources;
 using System.Collections;
 using System.Collections.Generic;
+using System.Globalization;
+using System.IO;
+using System.Resources;
 
 using Mono.Cecil;
 using Mono.Cecil.Cil;
@@ -115,7 +116,7 @@ namespace Gendarme.Rules.Correctness {
 		{
 			IList<Resource> resources = ad.MainModule.Resources;
 			foreach (EmbeddedResource resource in resources)
-				if (resourceClassName.Equals (resource.Name))
+				if (resourceClassName == resource.Name)
 					return resource;
 			return null;
 		}
@@ -131,7 +132,7 @@ namespace Gendarme.Rules.Correctness {
 				return null;
 
 			AssemblyDefinition ad = md.GetAssembly ();
-			string resourceClassName = md.DeclaringType.FullName + ".resources";
+			string resourceClassName = md.DeclaringType.GetFullName () + ".resources";
 			EmbeddedResource resource = GetEmbeddedResource (ad, resourceClassName);
 			if (resource == null)
 				return null;
@@ -242,13 +243,13 @@ namespace Gendarme.Rules.Correctness {
 			// String.Format (string, object, object, object) -> elementsPushed = 3
 			// String.Format (string, object[]) -> compute
 			// String.Format (IFormatProvider, string, object[]) -> compute
-			if (pdc [nbParameters - 1].ParameterType.FullName != "System.Object") {
+			if (!pdc [nbParameters - 1].ParameterType.IsNamed ("System", "Object")) {
 				// If we cannot determine the array size, we succeed (well we don't fail/report)
 				if (!TryComputeArraySize (call, method, nbParameters - 1, out elementsPushed))
 					return;
 
 				// String.Format (IFormatProvider, string, object[]) -> formatPosition = 1
-				if (pdc [0].ParameterType.FullName != "System.String")
+				if (!pdc [0].ParameterType.IsNamed ("System", "String"))
 					formatPosition = 1;
 			}
 
@@ -266,12 +267,19 @@ namespace Gendarme.Rules.Correctness {
 			}
 
 			if (expectedParameters < elementsPushed) {
-				Runner.Report (method, call, Severity.Medium, Confidence.Normal, String.Format ("Extra parameters are provided to String.Format, {0} provided but only {1} expected", elementsPushed, expectedParameters));
+				string msg = String.Format (CultureInfo.InvariantCulture, 
+					"Extra parameters are provided to String.Format, {0} provided but only {1} expected", 
+					elementsPushed, expectedParameters);
+				Runner.Report (method, call, Severity.Medium, Confidence.Normal, msg);
 				return;
 			}
 
-			if (elementsPushed < expectedParameters)
-				Runner.Report (method, call, Severity.Critical, Confidence.Normal, String.Format ("The String.Format method is expecting {0} parameters, but only {1} are found.", expectedParameters, elementsPushed));
+			if (elementsPushed < expectedParameters) {
+				string msg = String.Format (CultureInfo.InvariantCulture, 
+					"The String.Format method is expecting {0} parameters, but only {1} are found.", 
+					expectedParameters, elementsPushed);
+				Runner.Report (method, call, Severity.Critical, Confidence.Normal, msg);
+			}
 		}
 
 		public RuleResult CheckMethod (MethodDefinition method)
@@ -289,7 +297,7 @@ namespace Gendarme.Rules.Correctness {
 					continue;
 
 				MethodReference mr = (instruction.Operand as MethodReference);
-				if (formatSignature.Matches (mr) && (mr.DeclaringType.FullName == "System.String"))
+				if (formatSignature.Matches (mr) && mr.DeclaringType.IsNamed ("System", "String"))
 					CheckCallToFormatter (instruction, method);
 			}
 
diff --git a/gendarme/rules/Gendarme.Rules.Correctness/ProvideCorrectRegexPatternRule.cs b/gendarme/rules/Gendarme.Rules.Correctness/ProvideCorrectRegexPatternRule.cs
index 89eb1e8..ebaa25e 100644
--- a/gendarme/rules/Gendarme.Rules.Correctness/ProvideCorrectRegexPatternRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Correctness/ProvideCorrectRegexPatternRule.cs
@@ -27,6 +27,7 @@
 // THE SOFTWARE.
 
 using System;
+using System.Globalization;
 
 using Mono.Cecil;
 using Mono.Cecil.Cil;
@@ -91,20 +92,23 @@ namespace Gendarme.Rules.Correctness {
 
 		static OpCodeBitmask callsAndNewobjBitmask = BuildCallsAndNewobjOpCodeBitmask ();
 
-		const string RegexClass = "System.Text.RegularExpressions.Regex";
-		const string ValidatorClass = "System.Configuration.RegexStringValidator";
-
 		public override void Initialize (IRunner runner)
 		{
 			base.Initialize (runner);
 
 			Runner.AnalyzeModule += delegate (object o, RunnerEventArgs e) {
-				bool usingRegexClass = e.CurrentAssembly.Name.Name == "System"
-				                       || e.CurrentModule.HasTypeReference (RegexClass);
-				bool usingValidatorClass = e.CurrentModule.Runtime >= TargetRuntime.Net_2_0
-				                           && (e.CurrentAssembly.Name.Name == "System.Configuration"
-				                              || e.CurrentModule.HasTypeReference (ValidatorClass));
-				Active = usingRegexClass | usingValidatorClass;
+				string assembly_name = e.CurrentAssembly.Name.Name;
+				bool usingRegexClass = (assembly_name == "System");
+				bool usingValidatorClass = (e.CurrentModule.Runtime >= TargetRuntime.Net_2_0) && (assembly_name == "System.Configuration");
+				// if we're not analyzing System.dll or System.Configuration.dll then check if we're using them
+				if (!usingRegexClass && !usingValidatorClass) {
+					Active = e.CurrentModule.AnyTypeReference ((TypeReference tr) => {
+						return tr.IsNamed ("System.Text.RegularExpressions", "Regex") ||
+							tr.IsNamed ("System.Configuration", "RegexStringValidator");
+					});
+				} else {
+					Active = true;
+				}
 			};
 		}
 
@@ -127,7 +131,7 @@ namespace Gendarme.Rules.Correctness {
 				return CheckPattern (method, ins, (string) ld.Operand, confidence);
 			case Code.Ldsfld:
 				FieldReference f = (FieldReference) ld.Operand;
-				if (f.Name != "Empty" || f.DeclaringType.FullName != "System.String")
+				if (f.Name != "Empty" || !f.DeclaringType.IsNamed ("System", "String"))
 					return false;
 				return CheckPattern (method, ins, null, confidence);
 			case Code.Ldnull:
@@ -149,7 +153,8 @@ namespace Gendarme.Rules.Correctness {
 			} catch (Exception e) {
 				/* potential set of exceptions is not well documented and potentially changes with regarts to
 				   different runtime and/or runtime version. */
-				string msg = string.Format ("Pattern '{0}' is invalid. Reason: {1}", pattern, e.Message);
+				string msg = String.Format (CultureInfo.InvariantCulture, 
+					"Pattern '{0}' is invalid. Reason: {1}", pattern, e.Message);
 				Runner.Report (method, ins, Severity.High, confidence, msg);
 				return false;
 			}
@@ -161,8 +166,9 @@ namespace Gendarme.Rules.Correctness {
 				return;
 			if (!call.HasParameters)
 				return;
-			string tname = call.DeclaringType.FullName;
-			if (tname != RegexClass && tname != ValidatorClass)
+
+			TypeReference type = call.DeclaringType;
+			if (!type.IsNamed ("System.Text.RegularExpressions", "Regex") && !type.IsNamed ("System.Configuration", "RegexStringValidator"))
 				return;
 
 			MethodDefinition mdef = call.Resolve ();
@@ -174,8 +180,8 @@ namespace Gendarme.Rules.Correctness {
 
 			foreach (ParameterDefinition p in mdef.Parameters) {
 				string pname = p.Name;
-				if ((pname == "pattern" || pname == "regex") && p.ParameterType.FullName == "System.String") {
-					Instruction ld = ins.TraceBack (method, -(call.HasThis ? 0 : -1 + p.GetSequence ()));
+				if ((pname == "pattern" || pname == "regex") && p.ParameterType.IsNamed ("System", "String")) {
+					Instruction ld = ins.TraceBack (method, -(call.HasThis ? 0 : p.Index));
 					if (ld != null)
 						CheckArguments (method, ins, ld);
 					return;
diff --git a/gendarme/rules/Gendarme.Rules.Correctness/ProvideValidXPathExpressionRule.cs b/gendarme/rules/Gendarme.Rules.Correctness/ProvideValidXPathExpressionRule.cs
index 68d4cb4..770e78d 100644
--- a/gendarme/rules/Gendarme.Rules.Correctness/ProvideValidXPathExpressionRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Correctness/ProvideValidXPathExpressionRule.cs
@@ -25,6 +25,7 @@
 // THE SOFTWARE.
 
 using System;
+using System.Globalization;
 using System.Xml;
 using System.Xml.XPath;
 
@@ -74,10 +75,6 @@ namespace Gendarme.Rules.Correctness {
 	[EngineDependency (typeof (OpCodeEngine))]
 	public sealed class ProvideValidXPathExpressionRule : Rule, IMethodRule {
 
-		const string XmlNodeClass = "System.Xml.XmlNode";
-		const string XPathNavigatorClass = "System.Xml.XPath.XPathNavigator";
-		const string XPathExpressionClass = "System.Xml.XPath.XPathExpression";
-
 		public override void Initialize (IRunner runner)
 		{
 			base.Initialize (runner);
@@ -105,7 +102,7 @@ namespace Gendarme.Rules.Correctness {
 				break;
 			case Code.Ldsfld:
 				FieldReference f = (FieldReference) ld.Operand;
-				if (f.Name == "Empty" && f.DeclaringType.FullName == "System.String")
+				if (f.Name == "Empty" && f.DeclaringType.IsNamed ("System", "String"))
 					CheckString (method, ins, null);
 				break;
 			case Code.Ldnull:
@@ -124,7 +121,8 @@ namespace Gendarme.Rules.Correctness {
 			try {
 				XPathExpression.Compile (expression);
 			} catch (XPathException e) {
-				string msg = string.Format ("Expression '{0}' is invalid. Details: {1}", expression, e.Message);
+				string msg = String.Format (CultureInfo.InvariantCulture, 
+					"Expression '{0}' is invalid. Details: {1}", expression, e.Message);
 				Runner.Report (method, ins, Severity.High, Confidence.High, msg);
 			}
 		}
@@ -137,11 +135,11 @@ namespace Gendarme.Rules.Correctness {
 			switch (mref.Name) {
 			case "Compile":
 				TypeReference tr = mref.DeclaringType;
-				if (tr.FullName == XPathExpressionClass || tr.Inherits (XPathNavigatorClass))
+				if (tr.IsNamed ("System.Xml.XPath", "XPathExpression") || tr.Inherits ("System.Xml.XPath", "XPathNavigator"))
 					CheckString (method, ins, GetFirstArgumentOffset (mref));
 				break;
 			case "SelectNodes":
-				if (mref.DeclaringType.FullName == XmlNodeClass)
+				if (mref.DeclaringType.IsNamed ("System.Xml", "XmlNode"))
 					CheckString (method, ins, -1);
 				break;
 			case "Evaluate":
@@ -150,7 +148,7 @@ namespace Gendarme.Rules.Correctness {
 				break;
 			case "SelectSingleNode":
 				CheckXPathNavigatorString (method, ins, mref);
-				if (mref.DeclaringType.FullName == XmlNodeClass)
+				if (mref.DeclaringType.IsNamed ("System.Xml", "XmlNode"))
 					CheckString (method, ins, -1);
 				break;
 			}
@@ -158,8 +156,8 @@ namespace Gendarme.Rules.Correctness {
 
 		void CheckXPathNavigatorString (MethodDefinition method, Instruction ins, MethodReference mref)
 		{
-			if (mref.Parameters [0].ParameterType.FullName == "System.String") {
-				if (mref.DeclaringType.Inherits (XPathNavigatorClass))
+			if (mref.Parameters [0].ParameterType.IsNamed ("System", "String")) {
+				if (mref.DeclaringType.Inherits ("System.Xml.XPath", "XPathNavigator"))
 					CheckString (method, ins, -1);
 			}
 		}
diff --git a/gendarme/rules/Gendarme.Rules.Correctness/ProvideValidXmlStringRule.cs b/gendarme/rules/Gendarme.Rules.Correctness/ProvideValidXmlStringRule.cs
index 921e71a..36e7c64 100644
--- a/gendarme/rules/Gendarme.Rules.Correctness/ProvideValidXmlStringRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Correctness/ProvideValidXmlStringRule.cs
@@ -26,6 +26,7 @@
 
 using System;
 using System.Collections.Generic;
+using System.Globalization;
 using System.Xml;
 using System.Xml.XPath;
 
@@ -77,10 +78,6 @@ namespace Gendarme.Rules.Correctness {
 	[EngineDependency (typeof (OpCodeEngine))]
 	public sealed class ProvideValidXmlStringRule : Rule, IMethodRule {
 
-		const string XmlDocumentClass = "System.Xml.XmlDocument";
-		const string XmlNodeClass = "System.Xml.XmlNode";
-		const string XPathNavigatorClass = "System.Xml.XPath.XPathNavigator";
-
 		public override void Initialize (IRunner runner)
 		{
 			base.Initialize (runner);
@@ -108,7 +105,7 @@ namespace Gendarme.Rules.Correctness {
 				break;
 			case Code.Ldsfld:
 				FieldReference f = (FieldReference) ld.Operand;
-				if (f.Name == "Empty" && f.DeclaringType.FullName == "System.String")
+				if (f.Name == "Empty" && f.DeclaringType.IsNamed ("System", "String"))
 					CheckString (method, ins, null);
 				break;
 			case Code.Ldnull:
@@ -127,7 +124,8 @@ namespace Gendarme.Rules.Correctness {
 			try {
 				(new XmlDocument ()).LoadXml (xml);
 			} catch (XmlException e) {
-				string msg = string.Format ("XML string '{0}' is invalid. Details: {1}", xml, e.Message);
+				string msg = String.Format (CultureInfo.InvariantCulture, 
+					"XML string '{0}' is invalid. Details: {1}", xml, e.Message);
 				Runner.Report (method, ins, Severity.High, Confidence.High, msg);
 			}
 		}
@@ -139,13 +137,13 @@ namespace Gendarme.Rules.Correctness {
 
 			switch (mref.Name) {
 			case "LoadXml":
-				if (mref.DeclaringType.FullName == XmlDocumentClass)
+				if (mref.DeclaringType.IsNamed ("System.Xml", "XmlDocument"))
 					CheckString (method, ins, -1);
 				break;
 			case "set_InnerXml":
 			case "set_OuterXml":
 				TypeReference tr = mref.DeclaringType;
-				if (tr.Inherits (XmlNodeClass) || tr.Inherits (XPathNavigatorClass))
+				if (tr.Inherits ("System.Xml", "XmlNode") || tr.Inherits ("System.Xml.XPath", "XPathNavigator"))
 					CheckString (method, ins, -1);
 				break;
 			case "AppendChild":
@@ -154,8 +152,8 @@ namespace Gendarme.Rules.Correctness {
 			case "InsertBefore":
 				IList<ParameterDefinition> pdc = mref.Parameters;
 				if (pdc.Count == 1
-					&& pdc [0].ParameterType.FullName == "System.String"
-					&& mref.DeclaringType.Inherits (XPathNavigatorClass))
+					&& pdc [0].ParameterType.IsNamed ("System", "String")
+					&& mref.DeclaringType.Inherits ("System.Xml.XPath", "XPathNavigator"))
 					CheckString (method, ins, -1);
 				break;
 			}
diff --git a/gendarme/rules/Gendarme.Rules.Correctness/README.md b/gendarme/rules/Gendarme.Rules.Correctness/README.md
new file mode 100644
index 0000000..b7a8fc5
--- /dev/null
+++ b/gendarme/rules/Gendarme.Rules.Correctness/README.md
@@ -0,0 +1,9 @@
+# Gendarme.Rules.Correctness Rules
+
+You can access the latest rules documentation from our [[wiki|https://github.com/spouliot/gendarme/wiki/Gendarme.Rules.Correctness(git)]] pages.
+
+
+## Feedback
+
+Please report any documentation errors, typos or suggestions to the [[Gendarme Mailing List|https://groups.google.com/forum/?fromgroups#!forum/gendarme]]. Thanks!
+
diff --git a/gendarme/rules/Gendarme.Rules.Correctness/ReviewDoubleAssignmentRule.cs b/gendarme/rules/Gendarme.Rules.Correctness/ReviewDoubleAssignmentRule.cs
index 79b290b..272f86e 100644
--- a/gendarme/rules/Gendarme.Rules.Correctness/ReviewDoubleAssignmentRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Correctness/ReviewDoubleAssignmentRule.cs
@@ -27,6 +27,7 @@
 //
 
 using System;
+using System.Globalization;
 
 using Mono.Cecil;
 using Mono.Cecil.Cil;
@@ -113,7 +114,7 @@ namespace Gendarme.Rules.Correctness {
 			if (stfld.TraceBack (method).GetOperand (method) != next.TraceBack (method).GetOperand (method))
 				return String.Empty;
 
-			return String.Format ("Instance field '{0}' on same variable '{1}'.", fd1.Name, vd1.Name);
+			return String.Format (CultureInfo.InvariantCulture, "Instance field '{0}' on same variable '{1}'.", fd1.Name, vd1.Name);
 		}
 
 		static string CheckDoubleAssignement (MethodDefinition method, Instruction ins, Instruction next)
@@ -130,7 +131,7 @@ namespace Gendarme.Rules.Correctness {
 				if (fd1.MetadataToken.RID != fd2.MetadataToken.RID)
 					return String.Empty;
 
-				return String.Format ("Static field '{0}'.", fd1.Name);
+				return String.Format (CultureInfo.InvariantCulture, "Static field '{0}'.", fd1.Name);
 			} else if (ins.IsStoreLocal ()) {
 				// for a local variable the pattern is
 				// DUP, STLOC, STLOC
@@ -141,7 +142,7 @@ namespace Gendarme.Rules.Correctness {
 					if (vd1.Index != vd2.Index)
 						return String.Empty;
 
-					return String.Format ("Local variable '{0}'.", vd1.Name);
+					return String.Format (CultureInfo.InvariantCulture, "Local variable '{0}'.", vd1.Name);
 				} else if (next.OpCode.Code == Code.Stfld) {
 					// instance fields are a bit more complex...
 					return CheckDoubleAssignementOnInstanceFields (method, ins, next);
diff --git a/gendarme/rules/Gendarme.Rules.Correctness/ReviewInconsistentIdentityRule.cs b/gendarme/rules/Gendarme.Rules.Correctness/ReviewInconsistentIdentityRule.cs
index a79b354..67b4fc6 100644
--- a/gendarme/rules/Gendarme.Rules.Correctness/ReviewInconsistentIdentityRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Correctness/ReviewInconsistentIdentityRule.cs
@@ -125,7 +125,7 @@ namespace Gendarme.Rules.Correctness {
 		
 		private void GetMethods (TypeReference type)	
 		{
-			string full_name = type.FullName;
+			string full_name = type.GetFullName ();
 			args1 [0] = full_name;
 			AddMethod (type.GetMethod (MethodSignatures.Equals));
 			AddMethod (type.GetMethod ("Equals", "System.Boolean", args1));
@@ -349,7 +349,7 @@ namespace Gendarme.Rules.Correctness {
 			
 			Log.WriteLine (this);
 			Log.WriteLine (this, "------------------------------------");
-			Log.WriteLine (this, type.FullName);
+			Log.WriteLine (this, type);
 			
 			GetMethods (type);
 			if (methods.Count > 0) {
diff --git a/gendarme/rules/Gendarme.Rules.Correctness/ReviewSelfAssignmentRule.cs b/gendarme/rules/Gendarme.Rules.Correctness/ReviewSelfAssignmentRule.cs
index 5d359cc..127d7c7 100644
--- a/gendarme/rules/Gendarme.Rules.Correctness/ReviewSelfAssignmentRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Correctness/ReviewSelfAssignmentRule.cs
@@ -27,6 +27,7 @@
 //
 
 using System;
+using System.Globalization;
 
 using Mono.Cecil;
 using Mono.Cecil.Cil;
@@ -122,8 +123,8 @@ namespace Gendarme.Rules.Correctness {
 			if ((field != null) && (field == next.GetField ())) {
 				// instance fields need extra comparison using method
 				if (isStatic || Compare (next, ins, method)) {
-					string msg = String.Format ("{0} field '{1}' of type '{2}'.",
-						isStatic ? "Static" : "Instance", field.Name, field.FieldType.FullName);
+					string msg = String.Format (CultureInfo.InvariantCulture, "{0} field '{1}' of type '{2}'.",
+						isStatic ? "Static" : "Instance", field.Name, field.FieldType.GetFullName ());
 					Runner.Report (method, ins, Severity.Medium, Confidence.Normal, msg);
 				}
 			}
@@ -158,14 +159,15 @@ namespace Gendarme.Rules.Correctness {
 					if (variable == ins.GetVariable (method)) {
 						// the compiler often introduce it's own variable
 						if (!variable.Name.StartsWith ("V_"))
-							msg = String.Format ("Variable '{0}' of type '{1}'.", variable.Name, variable.VariableType.FullName);
+							msg = String.Format ("Variable '{0}' of type '{1}'.", variable.Name, variable.VariableType.GetFullName ());
 					}
 #endif
 				} else if (ins.IsLoadArgument () && next.IsStoreArgument ()) {
 					ParameterDefinition parameter = next.GetParameter (method);
 					if (parameter == ins.GetParameter (method)) {
-						string msg = String.Format ("Parameter '{0}' of type '{1}'.", 
-							parameter.Name, parameter.ParameterType.FullName);
+						string msg = String.Format (CultureInfo.InvariantCulture, 
+							"Parameter '{0}' of type '{1}'.", 
+							parameter.Name, parameter.ParameterType.GetFullName ());
 						Runner.Report (method, ins, Severity.Medium, Confidence.Normal, msg);
 					}
 				}
diff --git a/gendarme/rules/Gendarme.Rules.Correctness/ReviewUseOfInt64BitsToDoubleRule.cs b/gendarme/rules/Gendarme.Rules.Correctness/ReviewUseOfInt64BitsToDoubleRule.cs
index 18dbae1..11656ca 100644
--- a/gendarme/rules/Gendarme.Rules.Correctness/ReviewUseOfInt64BitsToDoubleRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Correctness/ReviewUseOfInt64BitsToDoubleRule.cs
@@ -75,20 +75,26 @@ namespace Gendarme.Rules.Correctness {
 		// Conv_I8, Conv_U8, Conv_Ovf_I8, Conv_Ovf_I8_Un, Conv_Ovf_U8, Conv_Ovf_U8_Un
 		private static OpCodeBitmask Convert8 = new OpCodeBitmask (0x0, 0x220000000000, 0x60000000044, 0x0);
 		
-		private const string BitConverter = "System.BitConverter";
-
 		public override void Initialize (IRunner runner)
 		{
 			base.Initialize (runner);
 
-			// if the module does not reference System.BitConverter then no
-			// method inside it will be calling any BitConverter.Int64BitsToDouble method
 			Runner.AnalyzeModule += delegate (object o, RunnerEventArgs e) {
-				Active = (e.CurrentAssembly.Name.Name == "mscorlib") ||
-					e.CurrentModule.HasTypeReference (BitConverter);
+				// if the module does not reference System.BitConverter.Int64BitsToDouble then no
+				// then there's no point in enabling the rule
+				Active = (e.CurrentAssembly.Name.Name == "mscorlib" ||
+					e.CurrentModule.AnyMemberReference ((MemberReference mr) => {
+						return IsInt64BitsToDouble (mr);
+					})
+				);
 			};
 		}
 
+		static bool IsInt64BitsToDouble (MemberReference method)
+		{
+			return method.IsNamed ("System", "BitConverter", "Int64BitsToDouble");
+		}
+
 		public RuleResult CheckMethod (MethodDefinition method)
 		{
 			if (!method.HasBody)
@@ -106,10 +112,7 @@ namespace Gendarme.Rules.Correctness {
 				if (ins.OpCode.FlowControl != FlowControl.Call)
 					continue;
 
-				MethodReference mr = (ins.Operand as MethodReference);
-				if (mr.Name != "Int64BitsToDouble")
-					continue;
-				if (mr.DeclaringType.FullName != BitConverter)
+				if (!IsInt64BitsToDouble (ins.Operand as MethodReference))
 					continue;
 
 				// if the previous call convert a value into a long (int64)
diff --git a/gendarme/rules/Gendarme.Rules.Correctness/Test/BadRecursiveInvocationTest.cs b/gendarme/rules/Gendarme.Rules.Correctness/Test/BadRecursiveInvocationTest.cs
index 74cd0c4..e7fcd69 100644
--- a/gendarme/rules/Gendarme.Rules.Correctness/Test/BadRecursiveInvocationTest.cs
+++ b/gendarme/rules/Gendarme.Rules.Correctness/Test/BadRecursiveInvocationTest.cs
@@ -374,5 +374,24 @@ namespace Test.Rules.Correctness {
 		{
 			AssertRuleSuccess<BadRec> ("StaticGoodOverload", new Type [] { typeof (object) });
 		}
+
+		class Array {
+
+			public virtual void SetProperty (string name, object value)
+			{
+				Console.WriteLine ("{0}: {1}", name, value);
+			}
+
+			internal virtual void SetProperty (string name, object [] args)
+			{
+				SetProperty (name, args [0]);
+			}
+		}
+
+		[Test]
+		public void ArrayOverload ()
+		{
+			AssertRuleSuccess<Array> ("SetProperty", new Type [] { typeof (string), typeof (object[]) });
+		}
 	}
 }
diff --git a/gendarme/rules/Gendarme.Rules.Correctness/Test/DeclareEventsExplicitlyTest.cs b/gendarme/rules/Gendarme.Rules.Correctness/Test/DeclareEventsExplicitlyTest.cs
new file mode 100644
index 0000000..8de18ab
--- /dev/null
+++ b/gendarme/rules/Gendarme.Rules.Correctness/Test/DeclareEventsExplicitlyTest.cs
@@ -0,0 +1,82 @@
+//
+// Unit tests for DeclareEventsExplicitlyRule
+//
+// Authors:
+//	Sebastien Pouliot <sebastien@ximian.com>
+//
+// Copyright (C) 2011 Novell, Inc (http://www.novell.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+
+using Gendarme.Rules.Correctness;
+using NUnit.Framework;
+
+using Test.Rules.Definitions;
+using Test.Rules.Fixtures;
+
+namespace Tests.Rules.Correctness {
+
+	[TestFixture]
+	public class DeclareEventsExplicitlyTest : TypeRuleTestFixture<DeclareEventsExplicitlyRule> {
+
+		struct StructInstanceCorrect {
+			public event EventHandler<EventArgs> MyEvent;
+		}
+
+		struct StructInstanceIncorrect {
+			public EventHandler<EventArgs> MyEvent;
+		}
+
+		class GenericClassStaticCorrect {
+			public static event EventHandler<EventArgs> MyEvent;
+		}
+
+		class GenericClassStaticIncorect {
+			public static EventHandler<EventArgs> MyEvent;
+			public event EventHandler<EventArgs> MyEvent2;
+		}
+
+		[Test]
+		public void DoesNotApply ()
+		{
+			AssertRuleDoesNotApply (SimpleTypes.Class);
+			AssertRuleDoesNotApply (SimpleTypes.Enum);
+			// interface cannot define fields
+			AssertRuleDoesNotApply (SimpleTypes.Interface);
+		}
+
+		[Test]
+		public void Success ()
+		{
+			AssertRuleSuccess<StructInstanceCorrect> ();
+			AssertRuleSuccess<GenericClassStaticCorrect> ();
+		}
+
+		[Test]
+		public void Failure ()
+		{
+			AssertRuleFailure<StructInstanceIncorrect> (1);
+			AssertRuleFailure<GenericClassStaticIncorect> (1);
+		}
+	}
+}
diff --git a/gendarme/rules/Gendarme.Rules.Correctness/Test/EnsureLocalDisposalTest.cs b/gendarme/rules/Gendarme.Rules.Correctness/Test/EnsureLocalDisposalTest.cs
index ebb9a01..e375d1d 100644
--- a/gendarme/rules/Gendarme.Rules.Correctness/Test/EnsureLocalDisposalTest.cs
+++ b/gendarme/rules/Gendarme.Rules.Correctness/Test/EnsureLocalDisposalTest.cs
@@ -45,15 +45,12 @@ namespace Test.Rules.Correctness {
 
 		StreamReader StreamReader { get; set; }
 
-		string DoesNotApply1 () { //no call/newobj/stloc
+		string DoesNotApply1 ()
+		{
+			//no call/newobj/stloc
 			return foo;
 		}
 
-		StreamReader DoesNotApply2 () { //returns IDisposable
-			var sr = new StreamReader ("bar.xml");
-			return sr;
-		}
-
 		string Success0 () {
 			var o = new object ();
 			return o.ToString ();
@@ -214,12 +211,6 @@ namespace Test.Rules.Correctness {
 		}
 
 		[Test]
-		public void DoesNotApply2 ()
-		{
-			AssertRuleDoesNotApply<DisposalCases> ("DoesNotApply2");
-		}
-
-		[Test]
 		public void Success0 ()
 		{
 			AssertRuleSuccess<DisposalCases> ("Success0");
@@ -300,7 +291,7 @@ namespace Test.Rules.Correctness {
 		[Test]
 		public void Failure3 ()
 		{
-			AssertRuleFailure<DisposalCases> ("Failure3", 2);
+			AssertRuleFailure<DisposalCases> ("Failure3", 1);
 		}
 
 		[Test]
@@ -382,11 +373,71 @@ namespace Test.Rules.Correctness {
 		[Test]
 		public void FluentApi ()
 		{
-			AssertRuleFailure<EnsureLocalDisposalTest> ("FluentTestCase", 3);
-			// confidence is lower (normal instead of high) for fluent-like API
-			Assert.AreEqual (Confidence.Normal, Runner.Defects [0].Confidence, "0");
-			Assert.AreEqual (Confidence.Normal, Runner.Defects [1].Confidence, "1");
-			Assert.AreEqual (Confidence.Normal, Runner.Defects [2].Confidence, "2");
+			AssertRuleSuccess<EnsureLocalDisposalTest> ("FluentTestCase");
+		}
+
+		// adapted (without locals variants) from https://bugzilla.novell.com/show_bug.cgi?id=666403
+
+		void OutParameter1 (out StreamReader stream)
+		{
+			var new_stream = new StreamReader ("baz.xml"); //out param
+			stream = new_stream;
+		}
+
+		bool OutParameter2 (out StreamReader stream)
+		{
+			stream = new StreamReader ("baz.xml"); //out param, no locals
+			return true;
+		}
+
+		[Test]
+		public void OutParameters ()
+		{
+			AssertRuleSuccess<EnsureLocalDisposalTest> ("OutParameter1");
+			AssertRuleSuccess<EnsureLocalDisposalTest> ("OutParameter2");
+		}
+
+		class SomeClassThatContainsADisposableProperty {
+			public StreamReader Reader { get; set; }
+		}
+
+		void OtherInstanceProperty1 (SomeClassThatContainsADisposableProperty someObj)
+		{
+			var reader = new StreamReader ("foobaz.xml");
+			someObj.Reader = reader; //property in param
+		}
+
+		void OtherInstanceProperty2 (SomeClassThatContainsADisposableProperty someObj)
+		{
+			someObj.Reader = new StreamReader ("foobaz.xml"); //property in param, no locals
+		}
+
+		[Test]
+		public void OtherInstance ()
+		{
+			AssertRuleSuccess<EnsureLocalDisposalTest> ("OtherInstanceProperty1");
+			AssertRuleSuccess<EnsureLocalDisposalTest> ("OtherInstanceProperty2");
+		}
+
+		StreamReader ReturnIDisposable1 ()
+		{
+			var ret = new StreamReader ("baz.xml"); //return value
+			return ret;
+		}
+
+		StreamReader ReturnIDisposable2 ()
+		{
+			return new StreamReader ("baz.xml"); //return value, no locals
+		}
+
+		[Test]
+		public void ReturnValue ()
+		{
+			// csc 10 (without /o optimize) will fail this as it introduce extra compiler generated locals
+#if __MonoCS__
+			AssertRuleSuccess<EnsureLocalDisposalTest> ("ReturnIDisposable1");
+#endif
+			AssertRuleSuccess<EnsureLocalDisposalTest> ("ReturnIDisposable2");
 		}
 	}
 }
diff --git a/gendarme/rules/Gendarme.Rules.Correctness/Test/Resource.Designer.cs b/gendarme/rules/Gendarme.Rules.Correctness/Test/Resource.Designer.cs
index ec1d9e5..e55ddeb 100644
--- a/gendarme/rules/Gendarme.Rules.Correctness/Test/Resource.Designer.cs
+++ b/gendarme/rules/Gendarme.Rules.Correctness/Test/Resource.Designer.cs
@@ -1,7 +1,7 @@
-﻿//------------------------------------------------------------------------------
+//------------------------------------------------------------------------------
 // <auto-generated>
 //     This code was generated by a tool.
-//     Runtime Version:2.0.50727.4927
+//     Runtime Version:4.0.30319.1
 //
 //     Changes to this file may cause incorrect behavior and will be lost if
 //     the code is regenerated.
@@ -19,7 +19,7 @@ namespace Tests.Rules.Correctness {
     // class via a tool like ResGen or Visual Studio.
     // To add or remove a member, edit your .ResX file then rerun ResGen
     // with the /str option, or rebuild your VS project.
-    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "2.0.0.0")]
+    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
     [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
     [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
     internal class Resource {
diff --git a/gendarme/rules/Gendarme.Rules.Correctness/Test/Tests.Rules.Correctness.csproj b/gendarme/rules/Gendarme.Rules.Correctness/Test/Tests.Rules.Correctness.csproj
index d5e9ea2..d3e97ec 100755
--- a/gendarme/rules/Gendarme.Rules.Correctness/Test/Tests.Rules.Correctness.csproj
+++ b/gendarme/rules/Gendarme.Rules.Correctness/Test/Tests.Rules.Correctness.csproj
@@ -1,5 +1,5 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
-<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="3.5">
+<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="4.0">
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
     <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
@@ -12,9 +12,11 @@
     <AssemblyName>Tests.Rules.Correctness</AssemblyName>
     <FileUpgradeFlags>
     </FileUpgradeFlags>
-    <OldToolsVersion>2.0</OldToolsVersion>
+    <OldToolsVersion>3.5</OldToolsVersion>
     <UpgradeBackupLocation>
     </UpgradeBackupLocation>
+    <IsWebBootstrapper>true</IsWebBootstrapper>
+    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
     <PublishUrl>http://localhost/Tests.Rules.Correctness/</PublishUrl>
     <Install>true</Install>
     <InstallFrom>Web</InstallFrom>
@@ -27,10 +29,9 @@
     <MapFileExtensions>true</MapFileExtensions>
     <ApplicationRevision>0</ApplicationRevision>
     <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
-    <IsWebBootstrapper>true</IsWebBootstrapper>
     <UseApplicationTrust>false</UseApplicationTrust>
     <BootstrapperEnabled>true</BootstrapperEnabled>
-    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <TargetFrameworkProfile />
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
     <DebugSymbols>true</DebugSymbols>
@@ -40,6 +41,7 @@
     <DefineConstants>DEBUG;TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
     <DebugType>pdbonly</DebugType>
@@ -48,6 +50,7 @@
     <DefineConstants>TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <ItemGroup>
     <Reference Include="nunit.framework, Version=2.4.8.0, Culture=neutral, PublicKeyToken=96d09a1eb7f44a77, processorArchitecture=MSIL">
@@ -97,6 +100,8 @@
     <Compile Include="ReviewUselessControlFlowTest.cs" />
     <Compile Include="ReviewUseOfInt64BitsToDoubleTest.cs" />
     <Compile Include="ReviewUseOfModuloOneOnIntegersTest.cs" />
+    <Compile Include="TypesWithDisposableFieldsShouldBeDisposableTest.cs" />
+    <Compile Include="TypesWithNativeFieldsShouldBeDisposableTest.cs" />
     <Compile Include="UseNoInliningWithGetCallingAssemblyTest.cs" />
     <Compile Include="UseValueInPropertySetterTest.cs" />
   </ItemGroup>
@@ -119,14 +124,33 @@
     </ProjectReference>
   </ItemGroup>
   <ItemGroup>
+    <BootstrapperPackage Include="Microsoft.Net.Client.3.5">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1 Client Profile</ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
     <BootstrapperPackage Include="Microsoft.Net.Framework.2.0">
       <Visible>False</Visible>
+      <ProductName>
+      </ProductName>
+      <Install>false</Install>
     </BootstrapperPackage>
     <BootstrapperPackage Include="Microsoft.Net.Framework.3.0">
       <Visible>False</Visible>
+      <ProductName>
+      </ProductName>
+      <Install>false</Install>
     </BootstrapperPackage>
     <BootstrapperPackage Include="Microsoft.Net.Framework.3.5">
       <Visible>False</Visible>
+      <ProductName>
+      </ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1</ProductName>
+      <Install>false</Install>
     </BootstrapperPackage>
   </ItemGroup>
   <ItemGroup>
diff --git a/gendarme/rules/Gendarme.Rules.Correctness/Test/TypesWithDisposableFieldsShouldBeDisposableTest.cs b/gendarme/rules/Gendarme.Rules.Correctness/Test/TypesWithDisposableFieldsShouldBeDisposableTest.cs
new file mode 100644
index 0000000..077889c
--- /dev/null
+++ b/gendarme/rules/Gendarme.Rules.Correctness/Test/TypesWithDisposableFieldsShouldBeDisposableTest.cs
@@ -0,0 +1,322 @@
+//
+// Unit tests for TypesWithDisposableFieldsShouldBeDisposableRule
+//
+// Authors:
+//	Andreas Noever <andreas.noever@gmail.com>
+//	Sebastien Pouliot  <sebastien@ximian.com>
+//
+//  (C) 2008 Andreas Noever
+// Copyright (C) 2008, 2011 Novell, Inc (http://www.novell.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+
+using Gendarme.Rules.Correctness;
+
+using NUnit.Framework;
+using Test.Rules.Definitions;
+using Test.Rules.Fixtures;
+
+namespace Test.Rules.Correctness {
+
+	class Disposable : IDisposable {
+		public void Dispose ()
+		{
+			throw new NotImplementedException ();
+		}
+	}
+
+	class NoDisposeableFields {
+		int A;
+		object b;
+	}
+
+	class DisposeableFieldsImplementsIDisposeable : IDisposable {
+		object A;
+		Disposable B;
+
+		public DisposeableFieldsImplementsIDisposeable ()
+		{
+			B = new Disposable ();
+		}
+
+		public void Dispose ()
+		{
+			throw new NotImplementedException ();
+		}
+	}
+
+	class DisposeableFieldsImplementsIDisposeableCorrectly : IDisposable {
+		object A;
+		Disposable B;
+
+		public DisposeableFieldsImplementsIDisposeableCorrectly ()
+		{
+			B = new Disposable ();
+		}
+
+		public void Dispose ()
+		{
+			B.Dispose (); // not really correct but Dispose is called :)
+		}
+	}
+
+	class DisposeableFieldsExplicit : IDisposable {
+		object A;
+		Disposable B;
+
+		void IDisposable.Dispose ()
+		{
+			throw new NotImplementedException ();
+		}
+	}
+
+	abstract class DisposeableFieldsImplementsIDisposeableAbstract : IDisposable {
+		object A;
+		Disposable B;
+		public void Dispose (object asd) { B.Dispose (); }
+		public abstract void Dispose ();
+	}
+
+	abstract class DisposeableFieldsImplementsIDisposeableAbstractAssigned : IDisposable {
+		object A;
+		Disposable B;
+
+		protected DisposeableFieldsImplementsIDisposeableAbstractAssigned ()
+		{
+			B = new Disposable ();
+		}
+
+		public abstract void Dispose ();
+	}
+
+	public class DisposeableFieldsNeverAssigned : ICloneable {
+		object A;
+		Disposable B;
+
+		public object Clone ()
+		{
+			throw new NotImplementedException ();
+		}
+	}
+
+	public class DisposeableFieldsNullAssigned : ICloneable {
+		object A;
+		Disposable B;
+
+		public DisposeableFieldsNullAssigned ()
+		{
+			A = null;
+			B = null;
+		}
+
+		public object Clone ()
+		{
+			throw new NotImplementedException ();
+		}
+	}
+
+	public class DisposeableFieldsAssigned : ICloneable {
+		object A;
+		Disposable B;
+
+		public DisposeableFieldsAssigned ()
+		{
+			A = null;
+			B = new Disposable ();
+		}
+
+		public object Clone ()
+		{
+			throw new NotImplementedException ();
+		}
+	}
+
+	class DisposeableFieldsReferenced : ICloneable {
+		object A;
+		Disposable B;
+
+		public DisposeableFieldsReferenced (Disposable instance)
+		{
+			A = null;
+			B = instance;
+		}
+
+		public object Clone ()
+		{
+			throw new NotImplementedException ();
+		}
+	}
+
+	class DisposeableFieldsArray : ICloneable {
+		object A;
+		Disposable [] B;
+
+		public object Clone ()
+		{
+			throw new NotImplementedException ();
+		}
+	}
+
+	class DisposeableFieldsArrayAssigned : ICloneable {
+		object A;
+		Disposable [] B;
+
+		public object Clone ()
+		{
+			// the array itself is not not IDisposable
+			B = new Disposable [10];
+			A = B;
+			return A;
+		}
+	}
+
+	class DisposeableFieldsArrayMembers : ICloneable {
+		object A;
+		Disposable [] B;
+
+		public object Clone ()
+		{
+			B = new Disposable [1];
+			// assignation (newobj+stfld) does not need to to be inside ctor
+			// note: fxcop does not catch this one
+			B [0] = new Disposable ();
+			A = B;
+			return A;
+		}
+	}
+
+	struct StructWithDisposeableFields {
+		Disposable a;
+		object b;
+
+		public StructWithDisposeableFields (object obj)
+		{
+			b = obj;
+			a = new Disposable ();
+		}
+	}
+
+	class DisposeableStaticFieldsArray {
+		object A;
+		static Disposable [] B;
+
+		static DisposeableStaticFieldsArray ()
+		{
+			B = new Disposable [1];
+			B [0] = new Disposable ();
+		}
+	}
+
+	// test case from https://bugzilla.novell.com/show_bug.cgi?id=671029
+
+	interface ISession : IDisposable {
+		void Query (string s);
+	}
+
+	class SomeRepository {
+		ISession session;
+		public SomeRepository (ISession session)
+		{
+			this.session = session;
+		}
+		public void DoSomeQuery ()
+		{
+			session.Query ("whatever");
+		}
+	}
+
+
+	[TestFixture]
+	public class TypesWithDisposableFieldsShouldBeDisposableTest : TypeRuleTestFixture<TypesWithDisposableFieldsShouldBeDisposableRule> {
+
+		[Test]
+		public void DoesNotApply ()
+		{
+			AssertRuleDoesNotApply (SimpleTypes.Delegate);
+			AssertRuleDoesNotApply (SimpleTypes.Enum);
+			AssertRuleDoesNotApply (SimpleTypes.Interface);
+			AssertRuleDoesNotApply (SimpleTypes.Structure);
+		}
+
+		[Test]
+		public void TestNoDisposeableFields ()
+		{
+			AssertRuleSuccess<NoDisposeableFields> ();
+		}
+
+		[Test]
+		public void TestDisposeableFieldsImplementsIDisposeable ()
+		{
+			AssertRuleSuccess<DisposeableFieldsImplementsIDisposeable> ();
+			AssertRuleSuccess<DisposeableFieldsImplementsIDisposeableCorrectly> ();
+		}
+
+		[Test]
+		public void TestDisposeableFieldsExplicit ()
+		{
+			AssertRuleSuccess<DisposeableFieldsExplicit> ();
+		}
+
+		[Test]
+		public void TestDisposeableFieldsImplementsIDisposeableAbstract ()
+		{
+			AssertRuleFailure<DisposeableFieldsImplementsIDisposeableAbstract> (1);
+			AssertRuleFailure<DisposeableFieldsImplementsIDisposeableAbstractAssigned> (2);
+		}
+
+		[Test]
+		public void TestDisposeableFields ()
+		{
+			AssertRuleSuccess<DisposeableFieldsNeverAssigned> ();
+			AssertRuleSuccess<DisposeableFieldsNullAssigned> ();
+			AssertRuleSuccess<DisposeableFieldsReferenced> ();
+			AssertRuleFailure<DisposeableFieldsAssigned> (1);
+		}
+
+		[Test]
+		public void TestDisposeableFieldsArray ()
+		{
+			AssertRuleSuccess<DisposeableFieldsArray> ();
+			AssertRuleSuccess<DisposeableFieldsArrayAssigned> ();
+			AssertRuleFailure<DisposeableFieldsArrayMembers> (1);
+		}
+
+		[Test]
+		public void TestStructWithDisposeableFields ()
+		{
+			AssertRuleDoesNotApply<StructWithDisposeableFields> ();
+		}
+
+		[Test]
+		public void TestDisposeableStaticFieldsArray ()
+		{
+			AssertRuleSuccess<DisposeableStaticFieldsArray> ();
+		}
+
+		[Test]
+		public void Bug671029 ()
+		{
+			AssertRuleSuccess<SomeRepository> ();
+		}
+	}
+}
diff --git a/gendarme/rules/Gendarme.Rules.Correctness/Test/TypesWithNativeFieldsShouldBeDisposableTest.cs b/gendarme/rules/Gendarme.Rules.Correctness/Test/TypesWithNativeFieldsShouldBeDisposableTest.cs
new file mode 100644
index 0000000..b66fcbf
--- /dev/null
+++ b/gendarme/rules/Gendarme.Rules.Correctness/Test/TypesWithNativeFieldsShouldBeDisposableTest.cs
@@ -0,0 +1,324 @@
+//
+// Unit tests for TypesWithNativeFieldsShouldBeDisposableRule
+//
+// Authors:
+//	Andreas Noever <andreas.noever@gmail.com>
+//	Sebastien Pouliot  <sebastien@ximian.com>
+//
+//  (C) 2008 Andreas Noever
+// Copyright (C) 2008 Novell, Inc (http://www.novell.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Runtime.InteropServices;
+
+using Gendarme.Rules.Correctness;
+
+using NUnit.Framework;
+using Test.Rules.Definitions;
+using Test.Rules.Fixtures;
+
+namespace Test.Rules.Design {
+
+	class NoNativeFields {
+		int A;
+		object b;
+	}
+
+	class NativeFieldsImplementsIDisposeable : IDisposable {
+		object A;
+		IntPtr B;
+
+		public void Dispose ()
+		{
+			throw new NotImplementedException ();
+		}
+	}
+
+	class NativeFieldsExplicit : IDisposable {
+		object A;
+		IntPtr B;
+
+		void IDisposable.Dispose ()
+		{
+			throw new NotImplementedException ();
+		}
+	}
+
+
+	class NativeFieldsIntPtr : ICloneable {
+		object A;
+		IntPtr B;
+
+		public object Clone ()
+		{
+			throw new NotImplementedException ();
+		}
+	}
+
+	class NativeFieldsIntPtrAssigned : ICloneable {
+		object A;
+		IntPtr B;
+
+		public NativeFieldsIntPtrAssigned ()
+		{
+			B = IntPtr.Zero;
+		}
+
+		public object Clone ()
+		{
+			throw new NotImplementedException ();
+		}
+	}
+
+	class NativeFieldsIntPtrAllocated : ICloneable {
+		object A;
+		IntPtr B;
+
+		public NativeFieldsIntPtrAllocated ()
+		{
+			B = Marshal.AllocCoTaskMem (1);
+		}
+
+		public object Clone ()
+		{
+			throw new NotImplementedException ();
+		}
+	}
+
+	class NativeFieldsUIntPtr : ICloneable {
+		object A;
+		UIntPtr B;
+
+		public object Clone ()
+		{
+			throw new NotImplementedException ();
+		}
+	}
+
+	class NativeFieldsUIntPtrAssigned : ICloneable {
+		object A;
+		UIntPtr B;
+
+		public NativeFieldsUIntPtrAssigned ()
+		{
+			B = (UIntPtr) 0x1f00;
+		}
+
+		public object Clone ()
+		{
+			throw new NotImplementedException ();
+		}
+	}
+
+	class NativeFieldsUIntPtrAllocated : ICloneable {
+		object A;
+		UIntPtr B;
+
+		[DllImport ("liberty")]
+		extern static UIntPtr Alloc (int x);
+
+		public NativeFieldsUIntPtrAllocated ()
+		{
+			B = Alloc (1);
+		}
+
+		public object Clone ()
+		{
+			throw new NotImplementedException ();
+		}
+	}
+
+	class NativeFieldsHandleRef : ICloneable {
+		object A;
+		HandleRef B;
+
+		public object Clone ()
+		{
+			throw new NotImplementedException ();
+		}
+	}
+
+	class NativeFieldsHandleRefAssigned : ICloneable {
+		object A;
+		HandleRef B;
+
+		public NativeFieldsHandleRefAssigned ()
+		{
+			GCHandle handle = GCHandle.Alloc (A, GCHandleType.Pinned);
+			B = new HandleRef (handle, handle.AddrOfPinnedObject ());
+		}
+
+		public object Clone ()
+		{
+			throw new NotImplementedException ();
+		}
+	}
+
+	class NativeFieldsHandleRefAllocatedElsewhere: ICloneable {
+		object A;
+		HandleRef B;
+
+		HandleRef GetHandleReference ()
+		{
+			return new HandleRef (A, IntPtr.Zero);
+		}
+
+		public NativeFieldsHandleRefAllocatedElsewhere ()
+		{
+			// fxcop does not trigger on this (or similar cases)
+			B = GetHandleReference ();
+		}
+
+		public object Clone ()
+		{
+			throw new NotImplementedException ();
+		}
+	}
+
+	abstract class AbstractNativeFields : IDisposable {
+		object A;
+		HandleRef B;
+
+		public abstract void Dispose ();
+	}
+
+	abstract class AbstractNativeFields2 : IDisposable {
+		object A;
+		HandleRef B;
+
+		public abstract void Dispose ();
+
+
+		void IDisposable.Dispose ()
+		{
+			throw new NotImplementedException ();
+		}
+	}
+
+	class NativeFieldsArray : ICloneable {
+		object A;
+		IntPtr [] B;
+
+		public object Clone ()
+		{
+			B = new IntPtr [1];
+			// assignation (newobj+stfld) does not need to to be inside ctor
+			// note: fxcop does not catch this one
+			B [0] = Marshal.AllocCoTaskMem (1);
+			A = B;
+			return A;
+		}
+	}
+
+	struct StructWithNativeFields {
+		public IntPtr a;
+		public UIntPtr b;
+		public HandleRef c;
+	}
+
+	class NativeStaticFieldsArray {
+		object A;
+		static UIntPtr [] B;
+	}
+
+	[TestFixture]
+	public class TypesWithNativeFieldsShouldBeDisposableTest : TypeRuleTestFixture<TypesWithNativeFieldsShouldBeDisposableRule> {
+
+		[Test]
+		public void DoesNotApply ()
+		{
+			AssertRuleDoesNotApply (SimpleTypes.Delegate);
+			AssertRuleDoesNotApply (SimpleTypes.Enum);
+			AssertRuleDoesNotApply (SimpleTypes.Interface);
+			AssertRuleDoesNotApply (SimpleTypes.Structure);
+		}
+
+		[Test]
+		public void TestNoNativeFields ()
+		{
+			AssertRuleSuccess<NoNativeFields> ();
+		}
+
+		[Test]
+		public void TestNativeFieldsImplementsIDisposeable ()
+		{
+			AssertRuleSuccess<NativeFieldsImplementsIDisposeable> ();
+		}
+
+		[Test]
+		public void TestNativeFieldsExplicit ()
+		{
+			AssertRuleSuccess<NativeFieldsExplicit> ();
+		}
+
+		[Test]
+		public void TestNativeFieldsIntPtr ()
+		{
+			AssertRuleSuccess<NativeFieldsIntPtr> ();
+			AssertRuleSuccess<NativeFieldsIntPtrAssigned> ();
+			AssertRuleFailure<NativeFieldsIntPtrAllocated> (1);
+		}
+
+		[Test]
+		public void TestNativeFieldsUIntPtr ()
+		{
+			AssertRuleSuccess<NativeFieldsUIntPtr> ();
+			AssertRuleSuccess<NativeFieldsUIntPtrAssigned> ();
+			AssertRuleFailure<NativeFieldsUIntPtrAllocated> (1);
+		}
+
+		[Test]
+		public void TestNativeFieldsHandleRef ()
+		{
+			AssertRuleSuccess<NativeFieldsHandleRef> ();
+			AssertRuleSuccess<NativeFieldsHandleRefAssigned> ();
+			AssertRuleFailure<NativeFieldsHandleRefAllocatedElsewhere> (1);
+		}
+
+		[Test]
+		public void TestAbstractNativeFields ()
+		{
+			AssertRuleFailure<AbstractNativeFields> (1);
+			AssertRuleFailure<AbstractNativeFields2> (1);
+		}
+
+		[Test]
+		public void TestNativeFieldsArray ()
+		{
+			AssertRuleFailure<NativeFieldsArray> (1);
+		}
+
+		[Test]
+		public void TestStructWithNativeFields ()
+		{
+			AssertRuleDoesNotApply<StructWithNativeFields> ();
+		}
+		
+		[Test]
+		public void TestNativeStaticFieldsArray ()
+		{
+			AssertRuleSuccess<NativeStaticFieldsArray> ();
+		}
+	}
+}
+
diff --git a/gendarme/rules/Gendarme.Rules.Correctness/TypesShouldBeDisposableBaseRule.cs b/gendarme/rules/Gendarme.Rules.Correctness/TypesShouldBeDisposableBaseRule.cs
new file mode 100644
index 0000000..247d01a
--- /dev/null
+++ b/gendarme/rules/Gendarme.Rules.Correctness/TypesShouldBeDisposableBaseRule.cs
@@ -0,0 +1,127 @@
+//
+// Gendarme.Rules.Correctness.TypesShouldBeDisposableBaseRule
+//
+// Authors:
+//	Andreas Noever <andreas.noever@gmail.com>
+//	Sebastien Pouliot  <sebastien@ximian.com>
+//
+//  (C) 2008 Andreas Noever
+// Copyright (C) 2011 Novell, Inc (http://www.novell.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+//
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System.Collections.Generic;
+
+using Mono.Cecil;
+
+using Gendarme.Framework;
+using Gendarme.Framework.Helpers;
+using Gendarme.Framework.Rocks;
+
+namespace Gendarme.Rules.Correctness {
+
+	public abstract class TypesShouldBeDisposableBaseRule : Rule, ITypeRule {
+
+		protected TypesShouldBeDisposableBaseRule ()
+		{
+			FieldCandidates = new HashSet<FieldDefinition> ();
+		}
+
+		protected HashSet<FieldDefinition> FieldCandidates { get; private set; }
+
+		protected abstract string AbstractTypeMessage { get; }
+		protected abstract string TypeMessage { get; }
+		protected abstract string AbstractDisposeMessage { get; }
+
+		static bool IsAbstract (MethodDefinition method)
+		{
+			return ((method != null) && (method.IsAbstract));
+		}
+
+		protected abstract void CheckMethod (MethodDefinition method, bool abstractWarning);
+
+		protected abstract bool FieldTypeIsCandidate (TypeDefinition type);
+
+		public RuleResult CheckType (TypeDefinition type)
+		{
+			// that will cover interfaces, delegates too
+			if (!type.HasFields)
+				return RuleResult.DoesNotApply;
+
+			// rule doesn't apply to enums, interfaces, structs, delegates or generated code
+			if (type.IsEnum || type.IsValueType || type.IsGeneratedCode ())
+				return RuleResult.DoesNotApply;
+
+			MethodDefinition explicitDisposeMethod = null;
+			MethodDefinition implicitDisposeMethod = null;
+
+			bool abstractWarning = false;
+
+			if (type.Implements ("System", "IDisposable")) {
+				implicitDisposeMethod = type.GetMethod (MethodSignatures.Dispose);
+				explicitDisposeMethod = type.GetMethod (MethodSignatures.DisposeExplicit);
+
+				if (IsAbstract (implicitDisposeMethod) || IsAbstract (explicitDisposeMethod)) {
+					abstractWarning = true;
+				} else {
+					return RuleResult.Success;
+				}
+			}
+
+			FieldCandidates.Clear ();
+
+			foreach (FieldDefinition field in type.Fields) {
+				// we can't dispose static fields in IDisposable
+				if (field.IsStatic)
+					continue;
+				TypeDefinition fieldType = field.FieldType.GetElementType ().Resolve ();
+				if (fieldType == null)
+					continue;
+				if (FieldTypeIsCandidate (fieldType))
+					FieldCandidates.Add (field);
+			}
+
+			// if there are fields types that implements IDisposable
+			if (type.HasMethods && (FieldCandidates.Count > 0)) {
+				// check if we're assigning new object to them
+				foreach (MethodDefinition method in type.Methods) {
+					CheckMethod (method, abstractWarning);
+				}
+			}
+
+			// Warn about possible confusion if the Dispose methods are abstract
+			if (IsAbstract (implicitDisposeMethod))
+				Runner.Report (implicitDisposeMethod, Severity.Medium, Confidence.High, AbstractDisposeMessage);
+
+			return Runner.CurrentRuleResult;
+		}
+#if false
+		public void Bitmask ()
+		{
+			OpCodeBitmask mask = new OpCodeBitmask ();
+			mask.Set (Code.Stfld);
+			mask.Set (Code.Stelem_Ref);
+			Console.WriteLine (mask);
+		}
+#endif
+	}
+}
+
diff --git a/gendarme/rules/Gendarme.Rules.Correctness/TypesWithDisposableFieldsShouldBeDisposableRule.cs b/gendarme/rules/Gendarme.Rules.Correctness/TypesWithDisposableFieldsShouldBeDisposableRule.cs
new file mode 100644
index 0000000..1731951
--- /dev/null
+++ b/gendarme/rules/Gendarme.Rules.Correctness/TypesWithDisposableFieldsShouldBeDisposableRule.cs
@@ -0,0 +1,136 @@
+//
+// Gendarme.Rules.Correctness.TypesWithDisposableFieldsShouldBeDisposableRule
+//
+// Authors:
+//	Andreas Noever <andreas.noever@gmail.com>
+//	Sebastien Pouliot  <sebastien@ximian.com>
+//
+//  (C) 2008 Andreas Noever
+// Copyright (C) 2011 Novell, Inc (http://www.novell.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+//
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using Mono.Cecil;
+using Mono.Cecil.Cil;
+
+using Gendarme.Framework;
+using Gendarme.Framework.Engines;
+using Gendarme.Framework.Helpers;
+using Gendarme.Framework.Rocks;
+
+namespace Gendarme.Rules.Correctness {
+
+	/// <summary>
+	/// This rule will fire if a type contains disposable fields, i.e. fields whose types implements 
+	/// <c>System.IDisposable</c>, but where the type itself does not implement <c>System.IDisposable</c>.
+	/// The rule will not report types that are not assigning themselves new instances to the fields.
+	/// </summary>
+	/// <example>
+	/// Bad examples:
+	/// <code>
+	/// class DoesNotImplementIDisposable {
+	///	IDisposable field;
+	/// }
+	/// 
+	/// class AbstractDispose : IDisposable {
+	///	IDisposable field;
+	///	
+	///	// the field should be disposed in the type that declares it
+	///	public abstract void Dispose ();
+	/// }
+	/// </code>
+	/// </example>
+	/// <example>
+	/// Good example:
+	/// <code>
+	/// class Dispose : IDisposable {
+	///	IDisposable field;
+	///	
+	///	public void Dispose ()
+	///	{
+	///		field.Dispose ();
+	///	}
+	/// }
+	/// </code>
+	/// </example>
+
+	[Problem ("This type contains disposable field(s) but doesn't implement IDisposable.")]
+	[Solution ("Implement IDisposable and free the disposable field(s) in the Dispose method.")]
+	[FxCopCompatibility ("Microsoft.Design", "CA1001:TypesThatOwnDisposableFieldsShouldBeDisposable")]
+	[EngineDependency (typeof (OpCodeEngine))]
+	public class TypesWithDisposableFieldsShouldBeDisposableRule : TypesShouldBeDisposableBaseRule {
+
+		static OpCodeBitmask StoreFieldBitmask = new OpCodeBitmask (0x0, 0x400000000000000, 0x80000000, 0x0);
+
+		protected override string AbstractTypeMessage { 
+			get { return "Field implement IDisposable. Type should implement a non-abstract Dispose() method"; }
+		}
+
+		protected override string TypeMessage { 
+			get { return "Field implement IDisposable. Type should implement a Dispose() method";  }
+		}
+
+		protected override string AbstractDisposeMessage { 
+			get { return "Some field(s) implement IDisposable. Making this method abstract shifts the reponsability of disposing those fields to the inheritors of this class."; }
+		}
+
+		protected override void CheckMethod (MethodDefinition method, bool abstractWarning)
+		{
+			if ((method == null) || !method.HasBody)
+				return;
+
+			OpCodeBitmask bitmask = OpCodeEngine.GetBitmask (method);
+			// method must have a NEWOBJ and either STFLD or STELEM_REF
+			if (!bitmask.Get (Code.Newobj) || !bitmask.Intersect (StoreFieldBitmask))
+				return;
+
+			foreach (Instruction ins in method.Body.Instructions) {
+				if (!ins.Is (Code.Newobj))
+					continue;
+
+				FieldDefinition field = null;
+				Instruction next = ins.Next;
+				if (next.Is (Code.Stfld)) {
+					field = next.Operand as FieldDefinition;
+				} else if (next.Is (Code.Stelem_Ref)) {
+					Instruction origin = next.TraceBack (method);
+					if (origin != null)
+						field = origin.Operand as FieldDefinition;
+				}
+
+				if (field != null && FieldCandidates.Contains (field)) {
+					Runner.Report (field, Severity.High, Confidence.High,
+						abstractWarning ? AbstractTypeMessage : TypeMessage);
+				}
+			}
+		}
+
+		protected override bool FieldTypeIsCandidate (TypeDefinition type)
+		{
+			// enums and primitives don't implement IDisposable
+			if ((type == null) || type.IsEnum || type.IsPrimitive)
+				return false;
+
+			return type.Implements ("System", "IDisposable");
+		}
+	}
+}
+
diff --git a/gendarme/rules/Gendarme.Rules.Correctness/TypesWithNativeFieldsShouldBeDisposableRule.cs b/gendarme/rules/Gendarme.Rules.Correctness/TypesWithNativeFieldsShouldBeDisposableRule.cs
new file mode 100644
index 0000000..1273a75
--- /dev/null
+++ b/gendarme/rules/Gendarme.Rules.Correctness/TypesWithNativeFieldsShouldBeDisposableRule.cs
@@ -0,0 +1,134 @@
+//
+// Gendarme.Rules.Correctness.TypesWithNativeFieldsShouldBeDisposableRule
+//
+// Authors:
+//	Andreas Noever <andreas.noever@gmail.com>
+//	Sebastien Pouliot  <sebastien@ximian.com>
+//
+//  (C) 2008 Andreas Noever
+// Copyright (C) 2011 Novell, Inc (http://www.novell.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+//
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using Mono.Cecil;
+using Mono.Cecil.Cil;
+
+using Gendarme.Framework;
+using Gendarme.Framework.Engines;
+using Gendarme.Framework.Helpers;
+using Gendarme.Framework.Rocks;
+
+namespace Gendarme.Rules.Correctness {
+
+	/// <summary>
+	/// This rule will fire if a type contains <c>IntPtr</c>, <c>UIntPtr</c>, or 
+	/// <c>HandleRef</c> fields but does not implement <c>System.IDisposable</c>.
+	/// </summary>
+	/// <example>
+	/// Bad examples:
+	/// <code>
+	/// public class DoesNotImplementIDisposable {
+	///	IntPtr field;
+	/// }
+	/// 
+	/// abstract public class AbstractDispose : IDisposable {
+	///	IntPtr field;
+	///	
+	///	// the field should be disposed in the type that declares it
+	///	public abstract void Dispose ();
+	/// }
+	/// </code>
+	/// </example>
+	/// <example>
+	/// Good example:
+	/// <code>
+	/// public class Dispose : IDisposable {
+	///	IDisposable field;
+	///	
+	///	public void Dispose ()
+	///	{
+	///		UnmanagedFree (field);
+	///	}
+	/// }
+	/// </code>
+	/// </example>
+
+	[Problem ("This type contains native field(s) but doesn't implement IDisposable.")]
+	[Solution ("Implement IDisposable and free the native field(s) in the Dispose method.")]
+	[FxCopCompatibility ("Microsoft.Design", "CA1049:TypesThatOwnNativeResourcesShouldBeDisposable")]
+	[EngineDependency (typeof (OpCodeEngine))]
+	public class TypesWithNativeFieldsShouldBeDisposableRule : TypesShouldBeDisposableBaseRule {
+
+		static OpCodeBitmask StoreFieldBitmask = new OpCodeBitmask (0x0, 0x400000000000000, 0x80000000, 0x0);
+
+		protected override string AbstractTypeMessage { 
+			get { return "Field is native. Type should implement a non-abstract Dispose() method"; }
+		}
+
+		protected override string TypeMessage { 
+			get { return "Field is native. Type should implement a Dispose() method";  }
+		}
+
+		protected override string AbstractDisposeMessage { 
+			get { return "Some fields are native pointers. Making this method abstract shifts the reponsability of disposing those fields to the inheritors of this class."; }
+		}
+
+		protected override void CheckMethod (MethodDefinition method, bool abstractWarning)
+		{
+			if ((method == null) || !method.HasBody)
+				return;
+
+			OpCodeBitmask bitmask = OpCodeEngine.GetBitmask (method);
+			// method must have a CALL[VIRT] and either STFLD or STELEM_REF
+			if (!bitmask.Intersect (OpCodeBitmask.Calls) || !bitmask.Intersect (StoreFieldBitmask))
+				return;
+
+			foreach (Instruction ins in method.Body.Instructions) {
+				MethodReference mr = (ins.Operand as MethodReference);
+				if (mr == null || mr.DeclaringType.IsNative ())
+					continue;
+
+				FieldDefinition field = null;
+				Instruction next = ins.Next;
+				if (next.Is (Code.Stfld)) {
+					field = next.Operand as FieldDefinition;
+				} else if (next.Is (Code.Stobj) || next.Is (Code.Stind_I)) {
+					Instruction origin = next.TraceBack (method);
+					if (origin.Is (Code.Ldelema)) {
+						origin = origin.TraceBack (method);
+						if (origin != null)
+							field = origin.Operand as FieldDefinition;
+					}
+				}
+
+				if (field != null && FieldCandidates.Contains (field)) {
+					Runner.Report (field, Severity.High, Confidence.High,
+						abstractWarning ? AbstractTypeMessage : TypeMessage);
+				}
+			}
+		}
+
+		protected override bool FieldTypeIsCandidate (TypeDefinition type)
+		{
+			return ((type != null) && type.IsNative ());
+		}
+	}
+}
diff --git a/gendarme/rules/Gendarme.Rules.Correctness/UseNoInliningWithGetCallingAssemblyRule.cs b/gendarme/rules/Gendarme.Rules.Correctness/UseNoInliningWithGetCallingAssemblyRule.cs
index 0026e04..702ab6b 100644
--- a/gendarme/rules/Gendarme.Rules.Correctness/UseNoInliningWithGetCallingAssemblyRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Correctness/UseNoInliningWithGetCallingAssemblyRule.cs
@@ -71,32 +71,33 @@ namespace Gendarme.Rules.Correctness {
 	[EngineDependency (typeof (OpCodeEngine))]
 	public class UseNoInliningWithGetCallingAssemblyRule : Rule, IMethodRule {
 
-		private const string Assembly = "System.Reflection.Assembly";
-
 		public override void Initialize (IRunner runner)
 		{
 			base.Initialize (runner);
 
 			Runner.AnalyzeModule += delegate (object o, RunnerEventArgs e) {
-				// if the module does not reference System.Reflection.Assembly 
-				// then no method inside it will be calling GetCallingAssembly
+				// if the module does not reference System.Reflection.Assembly.GetCallingAssembly
+				// then there's no point in enabling the rule
 				Active = (e.CurrentAssembly.Name.Name == "mscorlib" ||
-					e.CurrentModule.HasTypeReference (Assembly));
+					e.CurrentModule.AnyMemberReference ((MemberReference mr) => {
+						return IsGetCallingAssembly (mr);
+					})
+				);
 			};
 		}
 
+		static bool IsGetCallingAssembly (MemberReference method)
+		{
+			return method.IsNamed ("System.Reflection", "Assembly", "GetCallingAssembly");
+		}
+
 		static bool IsCallToGetCallingAssembly (Instruction instruction)
 		{
 			var code = instruction.OpCode.Code;
 			if (code != Code.Call && code != Code.Callvirt)
 				return false;
 
-			var method = instruction.Operand as MethodReference;
-			if (method == null)
-				return false;
-
-			return method.Name == "GetCallingAssembly"
-				&& method.DeclaringType.FullName == Assembly;
+			return IsGetCallingAssembly (instruction.GetMethod ());
 		}
 
 		public RuleResult CheckMethod (MethodDefinition method)
diff --git a/gendarme/rules/Gendarme.Rules.Correctness/UseValueInPropertySetterRule.cs b/gendarme/rules/Gendarme.Rules.Correctness/UseValueInPropertySetterRule.cs
index 0e55cbc..c97e3ee 100644
--- a/gendarme/rules/Gendarme.Rules.Correctness/UseValueInPropertySetterRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Correctness/UseValueInPropertySetterRule.cs
@@ -103,7 +103,7 @@ namespace Gendarme.Rules.Correctness {
 				ParameterDefinition pd = instruction.GetParameter (method);
 				if (pd != null) {
 					empty = false;
-					if (pd.GetSequence () == 1) // value
+					if (pd.Index == 0) // value
 						return RuleResult.Success;
 					continue;
 				}
diff --git a/gendarme/rules/Gendarme.Rules.Design.Generic/AvoidDeclaringCustomDelegatesRule.cs b/gendarme/rules/Gendarme.Rules.Design.Generic/AvoidDeclaringCustomDelegatesRule.cs
index 467157a..9156493 100644
--- a/gendarme/rules/Gendarme.Rules.Design.Generic/AvoidDeclaringCustomDelegatesRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Design.Generic/AvoidDeclaringCustomDelegatesRule.cs
@@ -38,9 +38,8 @@ using Gendarme.Framework.Rocks;
 namespace Gendarme.Rules.Design.Generic {
 
 	/// <summary>
-	/// This rule will fire if custom delegates are defined when either pre-defined
-	/// <code>Action</code>, <code>Action&lt;T[,...]&gt;</code> or <code>Func&lt;[Tx,...]TResult&gt;</code>
-	/// could have been used. This rule applies only to code using the framework version 2.0 (or later).
+	/// This rule will fire if custom delegates are defined when either pre-defined <code>System.Action</code>, 
+	/// <code>Action&lt;T[,...]&gt;</code> or <code>Func&lt;[Tx,...]TResult&gt;</code> could have been used.
 	/// </summary>
 	/// <example>
 	/// Bad example (without return value):
@@ -68,32 +67,10 @@ namespace Gendarme.Rules.Design.Generic {
 	/// private Func&lt;int,string,int&gt; func_delegate;
 	/// </code>
 	/// </example>
-	/// <remarks>This rule is available since Gendarme 2.8</remarks>
+	/// <remarks>This rule applies only to assemblies targeting .NET 2.0 and later.</remarks>
 	[Problem ("This delegate could be replaced with an existing framework delegate.")]
 	[Solution ("Prefer the use of Action, Action<T...> and Func<...,TResult> types.")]
-	public class AvoidDeclaringCustomDelegatesRule : Rule, ITypeRule {
-
-		private int MaxParameter = 4; // NET_2_0
-
-		public override void Initialize (IRunner runner)
-		{
-			base.Initialize (runner);
-
-			// we only want to run this on assemblies that use 2.0 or later
-			// since generics were not available before
-			Runner.AnalyzeModule += delegate (object o, RunnerEventArgs e) {
-				TargetRuntime runtime = e.CurrentModule.Runtime;
-				if (runtime >= TargetRuntime.Net_4_0) {
-					MaxParameter = 16;
-					Active = true;
-				} else if (runtime >= TargetRuntime.Net_2_0) {
-					MaxParameter = 4;
-					Active = true;
-				} else {
-					Active = false;
-				}
-			};
-		}
+	public class AvoidDeclaringCustomDelegatesRule : GenericsBaseRule, ITypeRule {
 
 		static string[] ActionMessage = {
 			"Replace with Action()",
@@ -157,7 +134,7 @@ namespace Gendarme.Rules.Design.Generic {
 				n = pdc.Count;
 				// too many parameters to directly use Action/Func
 				// so we lower severity and suggest grouping them
-				if (n > MaxParameter) {
+				if (n > ((type.Module.Runtime >= TargetRuntime.Net_4_0) ? 16 : 4)) {
 					severity = Severity.Low;
 					n = 1;
 					use_structure = true;
@@ -170,7 +147,7 @@ namespace Gendarme.Rules.Design.Generic {
 				}
 			}
 
-			string msg = (invoke.ReturnType.FullName == "System.Void") ? ActionMessage [n] : FuncMessage [n];
+			string msg = invoke.ReturnType.IsNamed ("System", "Void") ? ActionMessage [n] : FuncMessage [n];
 			if (use_structure)
 				msg += " and use a structure to hold all your parameters into <T>.";
 			Runner.Report (type, severity, Confidence.High, msg);
diff --git a/gendarme/rules/Gendarme.Rules.Design.Generic/AvoidExcessiveParametersOnGenericTypesRule.cs b/gendarme/rules/Gendarme.Rules.Design.Generic/AvoidExcessiveParametersOnGenericTypesRule.cs
index e5a8353..d4d02d0 100644
--- a/gendarme/rules/Gendarme.Rules.Design.Generic/AvoidExcessiveParametersOnGenericTypesRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Design.Generic/AvoidExcessiveParametersOnGenericTypesRule.cs
@@ -37,7 +37,8 @@ using Gendarme.Framework.Rocks;
 namespace Gendarme.Rules.Design.Generic {
 
 	/// <summary>
-	/// A type should not have more than two generic parameters.
+	/// A visible type should not have more than two generic parameters. This makes it
+	/// hard for consumers to remember what each parameter is required for.
 	/// </summary>
 	/// <example>
 	/// Bad example:
@@ -53,11 +54,12 @@ namespace Gendarme.Rules.Design.Generic {
 	/// }
 	/// </code>
 	/// </example>
-
-	[Problem ("A type has more than two generic parameters.")]
+	/// <remarks>This rule applies only to assemblies targeting .NET 2.0 and later.</remarks>
+	[Problem ("A visible type has more than two generic parameters.")]
 	[Solution ("Redesign the type so it doesn't take more than two generic parameters.")]
 	[FxCopCompatibility ("Microsoft.Design", "CA1005:AvoidExcessiveParametersOnGenericTypes")]
-	public class AvoidExcessiveParametersOnGenericTypesRule : Rule, ITypeRule {
+	public class AvoidExcessiveParametersOnGenericTypesRule : GenericsBaseRule, ITypeRule {
+
 		public RuleResult CheckType (TypeDefinition type)
 		{
 			if (!type.IsClass || !type.HasGenericParameters || !type.IsVisible ())
diff --git a/gendarme/rules/Gendarme.Rules.Design.Generic/AvoidMethodWithUnusedGenericTypeRule.cs b/gendarme/rules/Gendarme.Rules.Design.Generic/AvoidMethodWithUnusedGenericTypeRule.cs
index b369332..18d21eb 100644
--- a/gendarme/rules/Gendarme.Rules.Design.Generic/AvoidMethodWithUnusedGenericTypeRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Design.Generic/AvoidMethodWithUnusedGenericTypeRule.cs
@@ -27,6 +27,7 @@
 //
 
 using System;
+using System.Globalization;
 
 using Mono.Cecil;
 
@@ -75,50 +76,37 @@ namespace Gendarme.Rules.Design.Generic {
 	/// }
 	/// </code>
 	/// </example>
-	/// <remarks>This rule is available since Gendarme 2.2</remarks>
-
+	/// <remarks>This rule applies only to assemblies targeting .NET 2.0 and later.</remarks>
 	[Problem ("One or more generic type parameters are not used in the formal parameter list.")]
 	[Solution ("This prevents the compiler from inferring types when the method is used which results in hard to use API definitions.")]
 	[FxCopCompatibility ("Microsoft.Design", "CA1004:GenericMethodsShouldProvideTypeParameter")]
-	public class AvoidMethodWithUnusedGenericTypeRule : Rule, IMethodRule {
-
-		public override void Initialize (IRunner runner)
-		{
-			base.Initialize (runner);
-
-			// we only want to run this on assemblies that use 2.0 or later
-			// since generics were not available before
-			Runner.AnalyzeModule += delegate (object o, RunnerEventArgs e) {
-				Active = (e.CurrentModule.Runtime >= TargetRuntime.Net_2_0);
-			};
-		}
+	public class AvoidMethodWithUnusedGenericTypeRule : GenericsBaseRule, IMethodRule {
 
-		static bool FindGenericType (IGenericInstance git, string fullname)
+		static bool FindGenericType (IGenericInstance git, string nameSpace, string name)
 		{
 			foreach (object o in git.GenericArguments) {
-				if (IsGenericParameter (o, fullname))
+				if (IsGenericParameter (o, nameSpace, name))
 					return true;
 
 				GenericInstanceType inner = (o as GenericInstanceType);
-				if ((inner != null) && (FindGenericType (inner, fullname)))
+				if ((inner != null) && (FindGenericType (inner, nameSpace, name)))
 					return true;
 			}
 			return false;
 		}
 
-		static bool IsGenericParameter (object obj, string fullname)
+		static bool IsGenericParameter (object obj, string nameSpace, string name)
 		{
-			GenericParameter gp = (obj as GenericParameter);
-			return ((gp != null) && (gp.FullName == fullname));
+			return (obj as GenericParameter).IsNamed (nameSpace, name);
 		}
 
-		static bool IsGenericType (MemberReference type, string fullname)
+		static bool IsGenericType (TypeReference type, string nspace, string name)
 		{
-			if (type.FullName == fullname)
+			if (type.IsNamed (nspace, name))
 				return true;
 
 			var type_spec = type as TypeSpecification;
-			if (type_spec != null && type_spec.ElementType.FullName == fullname)
+			if (type_spec != null && type_spec.ElementType.IsNamed (nspace, name))
 				return true;
 
 			// handle things like ICollection<T>
@@ -126,7 +114,7 @@ namespace Gendarme.Rules.Design.Generic {
 			if (git == null)
 				return false;
 
-			return FindGenericType (git, fullname);
+			return FindGenericType (git, nspace, name);
 		}
 
 		public RuleResult CheckMethod (MethodDefinition method)
@@ -139,21 +127,23 @@ namespace Gendarme.Rules.Design.Generic {
 			foreach (GenericParameter gp in method.GenericParameters) {
 				Severity severity = Severity.Medium;
 				bool found = false;
-				string gp_fullname = gp.FullName;
+				string nspace = gp.Namespace;
+				string name = gp.Name;
 				// ... is being used by the method parameters
 				foreach (ParameterDefinition pd in method.Parameters) {
-					if (IsGenericType (pd.ParameterType, gp_fullname)) {
+					if (IsGenericType (pd.ParameterType, nspace, name)) {
 						found = true;
 						break;
 					}
 				}
 				if (!found) {
 					// it's a defect when used only for the return value - but we reduce its severity
-					if (IsGenericType (method.ReturnType, gp_fullname))
+					if (IsGenericType (method.ReturnType, nspace, name))
 						severity = Severity.Low;
 				}
 				if (!found) {
-					string msg = String.Format ("Generic parameter '{0}' is not used by the method parameters.", gp_fullname);
+					string msg = String.Format (CultureInfo.InvariantCulture,
+						"Generic parameter '{0}.{1}' is not used by the method parameters.", nspace, name);
 					Runner.Report (method, severity, Confidence.High, msg);
 				}
 			}
diff --git a/gendarme/rules/Gendarme.Rules.Design.Generic/DoNotDeclareStaticMembersOnGenericTypesRule.cs b/gendarme/rules/Gendarme.Rules.Design.Generic/DoNotDeclareStaticMembersOnGenericTypesRule.cs
index 00badaa..bc77797 100644
--- a/gendarme/rules/Gendarme.Rules.Design.Generic/DoNotDeclareStaticMembersOnGenericTypesRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Design.Generic/DoNotDeclareStaticMembersOnGenericTypesRule.cs
@@ -33,13 +33,14 @@ using Gendarme.Framework.Rocks;
 namespace Gendarme.Rules.Design.Generic {
 
 	/// <summary>
-	/// This rule checks for generic types that contain static members.
+	/// This rule checks for generic types that contain static members. Such members requires the type argument
+	/// to be specified when consumed, leading to harder to use or confusing API.
 	/// </summary>
 	/// <example>
 	/// Bad example:
 	/// <code>
 	/// public class BadClass&lt;T&gt; {
-	///	public static string member () {
+	///	public static string Member () {
 	///	}
 	/// }
 	/// </code>
@@ -48,16 +49,16 @@ namespace Gendarme.Rules.Design.Generic {
 	/// Good example:
 	/// <code>
 	/// public class GoodClass&lt;T&gt; {
-	///	public string member () {
+	///	public string Member () {
 	///	}
 	/// }
 	/// </code>
 	/// </example>
-
+	/// <remarks>This rule applies only to assemblies targeting .NET 2.0 and later.</remarks>
 	[Problem ("An externally visible generic type has a static member.")]
 	[Solution ("Remove the static member or change it to an instance member.")]
 	[FxCopCompatibility ("Microsoft.Design", "CA1000:DoNotDeclareStaticMembersOnGenericTypes")]
-	public class DoNotDeclareStaticMembersOnGenericTypesRule : Rule, ITypeRule {
+	public class DoNotDeclareStaticMembersOnGenericTypesRule : GenericsBaseRule, ITypeRule {
 		public RuleResult CheckType (TypeDefinition type)
 		{
 			if (!type.IsClass || !type.HasGenericParameters || !type.IsVisible ())
diff --git a/gendarme/rules/Gendarme.Rules.Design.Generic/DoNotExposeGenericListsRule.cs b/gendarme/rules/Gendarme.Rules.Design.Generic/DoNotExposeGenericListsRule.cs
index c8712ad..37f3904 100644
--- a/gendarme/rules/Gendarme.Rules.Design.Generic/DoNotExposeGenericListsRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Design.Generic/DoNotExposeGenericListsRule.cs
@@ -37,8 +37,8 @@ using Gendarme.Framework.Rocks;
 namespace Gendarme.Rules.Design.Generic {
 
 	/// <summary>
-	/// A type has an externally visible member that is, returns, or has a signature containing a 
-	/// System.Collections.Generic.List&lt;T&gt;.
+	/// A type has an externally visible member that is, returns or has a signature containing a 
+	/// <c>System.Collections.Generic.List&lt;T&gt;</c>.
 	/// </summary>
 	/// <example>
 	/// Bad example:
@@ -56,17 +56,17 @@ namespace Gendarme.Rules.Design.Generic {
 	/// }
 	/// </code>
 	/// </example>
-
+	/// <remarks>This rule applies only to assemblies targeting .NET 2.0 and later.</remarks>
 	[Problem ("The type exposes System.Collections.Generic.List<T>.")]
 	[Solution ("Use a type such as System.Collections.ObjectModel.Collection<T> instead.")]
 	[FxCopCompatibility ("Microsoft.Design", "CA1002:DoNotExposeGenericLists")]
-	public class DoNotExposeGenericListsRule : Rule, ITypeRule {
+	public class DoNotExposeGenericListsRule : GenericsBaseRule, ITypeRule {
 		private const string List = "List`1";
 
 		private static bool IsList (TypeReference type)
 		{			
 			return type.Namespace == "System.Collections.Generic" &&
-				type.Name.StartsWith (List);
+				type.Name.StartsWith (List, StringComparison.Ordinal);
 		}
 
 		private void CheckField (FieldReference field)
@@ -80,9 +80,7 @@ namespace Gendarme.Rules.Design.Generic {
 			if (!IsList (property.PropertyType))
 				return;
 
-			MethodDefinition getm = property.GetMethod;
-			MethodDefinition setm = property.SetMethod;
-			if (((getm != null) && getm.IsVisible ()) || ((setm != null) && setm.IsVisible ()))
+			if (property.GetMethod.IsVisible () || property.SetMethod.IsVisible ())
 				Runner.Report (property, Severity.Medium, Confidence.Total);
 		}
 
diff --git a/gendarme/rules/Gendarme.Rules.Design.Generic/DoNotExposeNestedGenericSignaturesRule.cs b/gendarme/rules/Gendarme.Rules.Design.Generic/DoNotExposeNestedGenericSignaturesRule.cs
index 40450bc..d8c5f01 100644
--- a/gendarme/rules/Gendarme.Rules.Design.Generic/DoNotExposeNestedGenericSignaturesRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Design.Generic/DoNotExposeNestedGenericSignaturesRule.cs
@@ -41,7 +41,7 @@ namespace Gendarme.Rules.Design.Generic {
 	/// <c>List&lt;List&lt;int&gt;&gt;</c>. Such types are hard to construct and should
 	/// be avoided because simpler alternatives generally exist.
 	/// Since some language, like C#, have direct support for nullable types, i.e. 
-	/// <c>Nullable&lt;T&gt;</c> this specific case is ignored by the rule.
+	/// <c>System.Nullable&lt;T&gt;</c> this specific case is ignored by the rule.
 	/// </summary>
 	/// <example>
 	/// Bad example:
@@ -63,23 +63,11 @@ namespace Gendarme.Rules.Design.Generic {
 	/// }
 	/// </code>
 	/// </example>
-	/// <remarks>This rule is available since Gendarme 2.4</remarks>
-
+	/// <remarks>This rule applies only to assemblies targeting .NET 2.0 and later.</remarks>
 	[Problem ("This method exposes a nested generic type in its signature.")]
 	[Solution ("Remove the nested generics to keep the visible API simple to use.")]
 	[FxCopCompatibility ("Microsoft.Design", "CA1006:DoNotNestGenericTypesInMemberSignatures")]
-	public class DoNotExposeNestedGenericSignaturesRule : Rule, IMethodRule {
-
-		public override void Initialize (IRunner runner)
-		{
-			base.Initialize (runner);
-
-			// we only want to run this on assemblies that use 2.0 or later
-			// since generics were not available before
-			Runner.AnalyzeModule += delegate (object o, RunnerEventArgs e) {
-				Active = (e.CurrentModule.Runtime >= TargetRuntime.Net_2_0);
-			};
-		}
+	public class DoNotExposeNestedGenericSignaturesRule : GenericsBaseRule, IMethodRule {
 
 		static Severity? Check (TypeReference type)
 		{
@@ -91,7 +79,7 @@ namespace Gendarme.Rules.Design.Generic {
 						// nullable are an exception because there is syntaxic sugar (at 
 						// least in some language like C#) to make them easier to use
 						// note: FxCop does not ignore them
-						if (git.ElementType.FullName == "System.Nullable`1")
+						if (git.ElementType.IsNamed ("System", "Nullable`1"))
 							return null;
 						// FIXME: we should look at ignoring LINQ queries too, because it
 						// too pretty much hides the complexity of nested generics
diff --git a/gendarme/rules/Gendarme.Rules.Design.Generic/Gendarme.Rules.Design.Generic.csproj b/gendarme/rules/Gendarme.Rules.Design.Generic/Gendarme.Rules.Design.Generic.csproj
index 9ab2871..17731ea 100644
--- a/gendarme/rules/Gendarme.Rules.Design.Generic/Gendarme.Rules.Design.Generic.csproj
+++ b/gendarme/rules/Gendarme.Rules.Design.Generic/Gendarme.Rules.Design.Generic.csproj
@@ -1,5 +1,5 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
     <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
@@ -10,8 +10,28 @@
     <AppDesignerFolder>Properties</AppDesignerFolder>
     <RootNamespace>Gendarme.Rules.Design.Generic</RootNamespace>
     <AssemblyName>Gendarme.Rules.Design.Generic</AssemblyName>
-    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
     <FileAlignment>512</FileAlignment>
+    <FileUpgradeFlags>
+    </FileUpgradeFlags>
+    <OldToolsVersion>3.5</OldToolsVersion>
+    <UpgradeBackupLocation />
+    <PublishUrl>publish\</PublishUrl>
+    <Install>true</Install>
+    <InstallFrom>Disk</InstallFrom>
+    <UpdateEnabled>false</UpdateEnabled>
+    <UpdateMode>Foreground</UpdateMode>
+    <UpdateInterval>7</UpdateInterval>
+    <UpdateIntervalUnits>Days</UpdateIntervalUnits>
+    <UpdatePeriodically>false</UpdatePeriodically>
+    <UpdateRequired>false</UpdateRequired>
+    <MapFileExtensions>true</MapFileExtensions>
+    <ApplicationRevision>0</ApplicationRevision>
+    <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
+    <IsWebBootstrapper>false</IsWebBootstrapper>
+    <UseApplicationTrust>false</UseApplicationTrust>
+    <BootstrapperEnabled>true</BootstrapperEnabled>
+    <TargetFrameworkProfile />
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
     <DebugSymbols>true</DebugSymbols>
@@ -24,6 +44,7 @@
     <DocumentationFile>..\..\console\bin\Debug\Gendarme.Rules.Design.Generic.xml</DocumentationFile>
     <NoWarn>1591</NoWarn>
     <WarningsAsErrors>1570</WarningsAsErrors>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
     <DebugType>pdbonly</DebugType>
@@ -35,6 +56,7 @@
     <NoWarn>1591</NoWarn>
     <WarningsAsErrors>1570</WarningsAsErrors>
     <DocumentationFile>..\..\console\bin\Release\Gendarme.Rules.Design.Generic.xml</DocumentationFile>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <ItemGroup>
     <Reference Include="System" />
@@ -52,6 +74,7 @@
     <Compile Include="DoNotDeclareStaticMembersOnGenericTypesRule.cs" />
     <Compile Include="DoNotExposeGenericListsRule.cs" />
     <Compile Include="DoNotExposeNestedGenericSignaturesRule.cs" />
+    <Compile Include="GenericsBaseRule.cs" />
     <Compile Include="ImplementGenericCollectionInterfacesRule.cs" />
     <Compile Include="UseGenericEventHandlerRule.cs" />
     <Compile Include="PreferGenericsOverRefObjectRule.cs" />
@@ -66,6 +89,23 @@
       <Name>Gendarme.Framework</Name>
     </ProjectReference>
   </ItemGroup>
+  <ItemGroup>
+    <BootstrapperPackage Include="Microsoft.Net.Client.3.5">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1 Client Profile</ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Windows.Installer.3.1">
+      <Visible>False</Visible>
+      <ProductName>Windows Installer 3.1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+  </ItemGroup>
   <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
   <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
        Other similar extension points exist, see Microsoft.Common.targets.
diff --git a/gendarme/rules/Gendarme.Rules.Design.Generic/GenericsBaseRule.cs b/gendarme/rules/Gendarme.Rules.Design.Generic/GenericsBaseRule.cs
new file mode 100644
index 0000000..12be75c
--- /dev/null
+++ b/gendarme/rules/Gendarme.Rules.Design.Generic/GenericsBaseRule.cs
@@ -0,0 +1,50 @@
+//
+// Gendarme.Rules.Design.Generic.GenericBaseRule
+//
+// Authors:
+//	Sebastien Pouliot <sebastien@ximian.com>
+//
+// Copyright (C) 2011 Novell, Inc (http://www.novell.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+//
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using Mono.Cecil;
+
+using Gendarme.Framework;
+
+namespace Gendarme.Rules.Design.Generic {
+
+	public abstract class GenericsBaseRule : Rule {
+
+		public override void Initialize (IRunner runner)
+		{
+			base.Initialize (runner);
+
+			// we only want to run Design.Generic.* rules on assemblies that 
+			// use 2.0 or later since generics were not available before
+			Runner.AnalyzeModule += delegate (object o, RunnerEventArgs e) {
+				Active = (e.CurrentModule.Runtime >= TargetRuntime.Net_2_0);
+			};
+		}
+	}
+}
+
diff --git a/gendarme/rules/Gendarme.Rules.Design.Generic/ImplementGenericCollectionInterfacesRule.cs b/gendarme/rules/Gendarme.Rules.Design.Generic/ImplementGenericCollectionInterfacesRule.cs
index 87391eb..c2d2c32 100644
--- a/gendarme/rules/Gendarme.Rules.Design.Generic/ImplementGenericCollectionInterfacesRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Design.Generic/ImplementGenericCollectionInterfacesRule.cs
@@ -36,9 +36,9 @@ using Gendarme.Framework.Rocks;
 namespace Gendarme.Rules.Design.Generic {
 
 	/// <summary>
-	/// This rule checks for types which implement the non-generic IEnumerable interface but 
-	/// not the IEnumerable&lt;T&gt; interface. Implementing the generic version
-	/// of IEnumerable avoids casts, and possibly boxing, when iterating the collection.
+	/// This rule checks for types which implement the non-generic <code>System.IEnumerable</code> interface but 
+	/// not the <code>System.IEnumerable&lt;T&gt;</code> interface. Implementing the generic version
+	/// of <code>System.IEnumerable</code> avoids casts, and possibly boxing, when iterating the collection.
 	/// </summary>
 	/// <example>
 	/// Bad example:
@@ -64,23 +64,11 @@ namespace Gendarme.Rules.Design.Generic {
 	/// }
 	/// </code>
 	/// </example>
-	/// <remarks>Before Gendarme 2.2 this rule was part of Gendarme.Rules.Design assembly.</remarks>
-
+	/// <remarks>This rule applies only to assemblies targeting .NET 2.0 and later.</remarks>
 	[Problem ("This type implements the non-generic IEnumerable interface but not IEnumerable<T> which would make your collection type-safe.")]
 	[Solution ("Implement one of generic collection interfaces such as IEnumerable<T>, ICollection<T> or IList<T>.")]
 	[FxCopCompatibility ("Microsoft.Design", "CA1010:CollectionsShouldImplementGenericInterface")]
-	public class ImplementGenericCollectionInterfacesRule : Rule, ITypeRule {
-
-		public override void Initialize (IRunner runner)
-		{
-			base.Initialize (runner);
-
-			// we only want to run this on assemblies that use 2.0 or later
-			// since generics were not available before
-			Runner.AnalyzeModule += delegate (object o, RunnerEventArgs e) {
-				Active = (e.CurrentModule.Runtime >= TargetRuntime.Net_2_0);
-			};
-		}
+	public class ImplementGenericCollectionInterfacesRule : GenericsBaseRule, ITypeRule {
 
 		public RuleResult CheckType (TypeDefinition type)
 		{
@@ -93,15 +81,15 @@ namespace Gendarme.Rules.Design.Generic {
 				return RuleResult.DoesNotApply;
 
 			// rule only applies if the type implements IEnumerable
-			if (!type.Implements ("System.Collections.IEnumerable"))
+			if (!type.Implements ("System.Collections", "IEnumerable"))
 				return RuleResult.DoesNotApply;
 		
 			// rule does not apply to the types implementing IDictionary
-			if (type.Implements ("System.Collections.IDictionary"))
+			if (type.Implements ("System.Collections", "IDictionary"))
 				return RuleResult.DoesNotApply;
 
 			// the type should implement IEnumerable<T> too
-			if (!type.Implements ("System.Collections.Generic.IEnumerable`1"))
+			if (!type.Implements ("System.Collections.Generic", "IEnumerable`1"))
 				Runner.Report (type, Severity.Medium, Confidence.High);
 
 			return Runner.CurrentRuleResult;
diff --git a/gendarme/rules/Gendarme.Rules.Design.Generic/Makefile.am b/gendarme/rules/Gendarme.Rules.Design.Generic/Makefile.am
index 4e50027..701ad0e 100644
--- a/gendarme/rules/Gendarme.Rules.Design.Generic/Makefile.am
+++ b/gendarme/rules/Gendarme.Rules.Design.Generic/Makefile.am
@@ -7,6 +7,7 @@ rules_sources =  \
 	DoNotDeclareStaticMembersOnGenericTypesRule.cs \
 	DoNotExposeGenericListsRule.cs \
 	DoNotExposeNestedGenericSignaturesRule.cs \
+	GenericsBaseRule.cs \
 	ImplementGenericCollectionInterfacesRule.cs \
 	PreferGenericsOverRefObjectRule.cs \
 	UseGenericEventHandlerRule.cs
diff --git a/gendarme/rules/Gendarme.Rules.Design.Generic/PreferGenericsOverRefObjectRule.cs b/gendarme/rules/Gendarme.Rules.Design.Generic/PreferGenericsOverRefObjectRule.cs
index 56f67a4..fe94e7f 100644
--- a/gendarme/rules/Gendarme.Rules.Design.Generic/PreferGenericsOverRefObjectRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Design.Generic/PreferGenericsOverRefObjectRule.cs
@@ -38,7 +38,7 @@ namespace Gendarme.Rules.Design.Generic {
 
 	/// <summary>
 	/// This rule fires if a method has a reference argument (<c>ref</c> or
-	/// <c>out</c> in C#) to System.Object. These methods can generally be
+	/// <c>out</c> in C#) to <c>System.Object</c>. These methods can generally be
 	/// rewritten in .NET 2.0 using generics which provides type safety, eliminates
 	/// casts, and makes the API easier to consume.
 	/// </summary>
@@ -61,23 +61,11 @@ namespace Gendarme.Rules.Design.Generic {
 	/// }
 	/// </code>
 	/// </example>
-	/// <remarks>This rule is available since Gendarme 2.2</remarks>
-
+	/// <remarks>This rule applies only to assemblies targeting .NET 2.0 and later.</remarks>
 	[Problem ("This method contains a reference parameter to System.Object which is often an indication that the code is not type safe.")]
 	[Solution ("Change the parameter to use a generic type where the caller will provide the type.")]
 	[FxCopCompatibility ("Microsoft.Design", "CA1007:UseGenericsWhereAppropriate")]
-	public class PreferGenericsOverRefObjectRule : Rule, IMethodRule {
-
-		public override void Initialize (IRunner runner)
-		{
-			base.Initialize (runner);
-
-			// we only want to run this on assemblies that use 2.0 or later
-			// since generics were not available before
-			Runner.AnalyzeModule += delegate (object o, RunnerEventArgs e) {
-				Active = (e.CurrentModule.Runtime >= TargetRuntime.Net_2_0);
-			};
-		}
+	public class PreferGenericsOverRefObjectRule : GenericsBaseRule, IMethodRule {
 
 		public RuleResult CheckMethod (MethodDefinition method)
 		{
@@ -86,11 +74,11 @@ namespace Gendarme.Rules.Design.Generic {
 				return RuleResult.DoesNotApply;
 
 			// exclude the "bool Try* (ref)" pattern from the rule
-			if (method.Name.StartsWith ("Try", StringComparison.Ordinal) && (method.ReturnType.FullName == "System.Boolean"))
+			if (method.Name.StartsWith ("Try", StringComparison.Ordinal) && method.ReturnType.IsNamed ("System", "Boolean"))
 				return RuleResult.DoesNotApply;
 
 			foreach (ParameterDefinition parameter in method.Parameters) {
-				if (parameter.ParameterType.FullName != "System.Object&")
+				if (!parameter.ParameterType.IsNamed ("System", "Object&"))
 					continue;
 
 				// suggest using generics
diff --git a/gendarme/rules/Gendarme.Rules.Design.Generic/README.md b/gendarme/rules/Gendarme.Rules.Design.Generic/README.md
new file mode 100644
index 0000000..f7ce631
--- /dev/null
+++ b/gendarme/rules/Gendarme.Rules.Design.Generic/README.md
@@ -0,0 +1,9 @@
+# Gendarme.Rules.Design.Generic Rules
+
+You can access the latest rules documentation from our [[wiki|https://github.com/spouliot/gendarme/wiki/Gendarme.Rules.Design.Generic(git)]] pages.
+
+
+## Feedback
+
+Please report any documentation errors, typos or suggestions to the [[Gendarme Mailing List|https://groups.google.com/forum/?fromgroups#!forum/gendarme]]. Thanks!
+
diff --git a/gendarme/rules/Gendarme.Rules.Design.Generic/Test/Tests.Rules.Design.Generic.csproj b/gendarme/rules/Gendarme.Rules.Design.Generic/Test/Tests.Rules.Design.Generic.csproj
index ca2b70d..5eb62ff 100644
--- a/gendarme/rules/Gendarme.Rules.Design.Generic/Test/Tests.Rules.Design.Generic.csproj
+++ b/gendarme/rules/Gendarme.Rules.Design.Generic/Test/Tests.Rules.Design.Generic.csproj
@@ -1,5 +1,5 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
     <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
@@ -10,8 +10,28 @@
     <AppDesignerFolder>Properties</AppDesignerFolder>
     <RootNamespace>Tests.Rules.Design.Generic</RootNamespace>
     <AssemblyName>Tests.Rules.Design.Generic</AssemblyName>
-    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
     <FileAlignment>512</FileAlignment>
+    <FileUpgradeFlags>
+    </FileUpgradeFlags>
+    <OldToolsVersion>3.5</OldToolsVersion>
+    <UpgradeBackupLocation />
+    <PublishUrl>publish\</PublishUrl>
+    <Install>true</Install>
+    <InstallFrom>Disk</InstallFrom>
+    <UpdateEnabled>false</UpdateEnabled>
+    <UpdateMode>Foreground</UpdateMode>
+    <UpdateInterval>7</UpdateInterval>
+    <UpdateIntervalUnits>Days</UpdateIntervalUnits>
+    <UpdatePeriodically>false</UpdatePeriodically>
+    <UpdateRequired>false</UpdateRequired>
+    <MapFileExtensions>true</MapFileExtensions>
+    <ApplicationRevision>0</ApplicationRevision>
+    <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
+    <IsWebBootstrapper>false</IsWebBootstrapper>
+    <UseApplicationTrust>false</UseApplicationTrust>
+    <BootstrapperEnabled>true</BootstrapperEnabled>
+    <TargetFrameworkProfile />
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
     <DebugSymbols>true</DebugSymbols>
@@ -21,6 +41,7 @@
     <DefineConstants>DEBUG;TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
     <DebugType>pdbonly</DebugType>
@@ -29,6 +50,7 @@
     <DefineConstants>TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <ItemGroup>
     <Reference Include="nunit.framework, Version=2.4.8.0, Culture=neutral, PublicKeyToken=96d09a1eb7f44a77, processorArchitecture=MSIL">
@@ -76,6 +98,23 @@
   <ItemGroup>
     <Folder Include="Properties\" />
   </ItemGroup>
+  <ItemGroup>
+    <BootstrapperPackage Include="Microsoft.Net.Client.3.5">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1 Client Profile</ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Windows.Installer.3.1">
+      <Visible>False</Visible>
+      <ProductName>Windows Installer 3.1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+  </ItemGroup>
   <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
   <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
        Other similar extension points exist, see Microsoft.Common.targets.
diff --git a/gendarme/rules/Gendarme.Rules.Design.Generic/UseGenericEventHandlerRule.cs b/gendarme/rules/Gendarme.Rules.Design.Generic/UseGenericEventHandlerRule.cs
index 9535a2a..71083fd 100644
--- a/gendarme/rules/Gendarme.Rules.Design.Generic/UseGenericEventHandlerRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Design.Generic/UseGenericEventHandlerRule.cs
@@ -38,8 +38,8 @@ using Gendarme.Framework.Rocks;
 namespace Gendarme.Rules.Design.Generic {
 
 	/// <summary>
-	/// This rule fires if an assembly targets .NET 2.0 or later and defines a delegate
-	/// which can be replaced by <c>System.EventHandler&lt;TEventArgs&gt;</c>.
+	/// This rule fires if an assembly defines a delegate which can be
+	/// replaced by <c>System.EventHandler&lt;TEventArgs&gt;</c>.
 	/// </summary>
 	/// <example>
 	/// Bad example:
@@ -57,23 +57,11 @@ namespace Gendarme.Rules.Design.Generic {
 	/// public event EventHandler&lt;AuthenticityEventArgs&gt; CheckedAuthenticity;
 	/// </code>
 	/// </example>
-	/// <remarks>This rule is available since Gendarme 2.2</remarks>
-
+	/// <remarks>This rule applies only to assemblies targeting .NET 2.0 and later.</remarks>
 	[Problem ("This delegate definition is not needed with .NET 2.0 and later runtimes.")]
 	[Solution ("Replace the delegate with System.EventHandler<TEventArgs>.")]
 	[FxCopCompatibility ("Microsoft.Design", "CA1003:UseGenericEventHandlerInstances")]
-	public class UseGenericEventHandlerRule : Rule, ITypeRule {
-
-		public override void Initialize (IRunner runner)
-		{
-			base.Initialize (runner);
-
-			// we only want to run this on assemblies that use 2.0 or later
-			// since generics were not available before
-			Runner.AnalyzeModule += delegate (object o, RunnerEventArgs e) {
-				Active = (e.CurrentModule.Runtime >= TargetRuntime.Net_2_0);
-			};
-		}
+	public class UseGenericEventHandlerRule : GenericsBaseRule, ITypeRule {
 
 		public RuleResult CheckType (TypeDefinition type)
 		{
@@ -86,7 +74,7 @@ namespace Gendarme.Rules.Design.Generic {
 			if (invoke == null)
 				return RuleResult.DoesNotApply;
 
-			if (invoke.ReturnType.FullName != "System.Void")
+			if (!invoke.ReturnType.IsNamed ("System", "Void"))
 				return RuleResult.Success;
 
 			if (!invoke.HasParameters)
@@ -95,9 +83,9 @@ namespace Gendarme.Rules.Design.Generic {
 			IList<ParameterDefinition> pdc = invoke.Parameters;
 			if (pdc.Count != 2)
 				return RuleResult.Success;
-			if (pdc [0].ParameterType.FullName != "System.Object")
+			if (!pdc [0].ParameterType.IsNamed ("System", "Object"))
 				return RuleResult.Success;
-			if (!pdc [1].ParameterType.Inherits ("System.EventArgs"))
+			if (!pdc [1].ParameterType.Inherits ("System", "EventArgs"))
 				return RuleResult.Success;
 
 			Runner.Report (type, Severity.Medium, Confidence.High);
diff --git a/gendarme/rules/Gendarme.Rules.Design.Linq/AvoidExtensionMethodOnSystemObjectRule.cs b/gendarme/rules/Gendarme.Rules.Design.Linq/AvoidExtensionMethodOnSystemObjectRule.cs
index a5935e0..a2f1308 100644
--- a/gendarme/rules/Gendarme.Rules.Design.Linq/AvoidExtensionMethodOnSystemObjectRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Design.Linq/AvoidExtensionMethodOnSystemObjectRule.cs
@@ -77,8 +77,11 @@ namespace Gendarme.Rules.Design.Linq {
 			// extension methods are only available in FX3.5
 			// check runtime >= NET2_0 (fast) then check if [ExtensionAttribute] is referenced
 			Runner.AnalyzeModule += (object o, RunnerEventArgs e) => {
-				Active = e.CurrentModule.Runtime >= TargetRuntime.Net_2_0 &&
-					e.CurrentModule.HasTypeReference ("System.Runtime.CompilerServices.ExtensionAttribute");
+				Active = (e.CurrentModule.Runtime >= TargetRuntime.Net_2_0 &&
+					e.CurrentModule.AnyTypeReference ((TypeReference tr) => {
+						return tr.IsNamed ("System.Runtime.CompilerServices", "ExtensionAttribute");
+					})
+				);
 			};
 		}
 
@@ -92,7 +95,7 @@ namespace Gendarme.Rules.Design.Linq {
 			if (!method.HasParameters)
 				return false;
 
-			return method.HasAttribute ("System.Runtime.CompilerServices.ExtensionAttribute");
+			return method.HasAttribute ("System.Runtime.CompilerServices", "ExtensionAttribute");
 		}
 
 		public RuleResult CheckMethod (MethodDefinition method)
@@ -100,7 +103,7 @@ namespace Gendarme.Rules.Design.Linq {
 			if (!IsExtension (method))
 				return RuleResult.DoesNotApply;
 
-			if (method.Parameters [0].ParameterType.FullName != "System.Object")
+			if (!method.Parameters [0].ParameterType.IsNamed ("System", "Object"))
 				return RuleResult.Success;
 
 			Runner.Report (method, Severity.High, Confidence.High);
diff --git a/gendarme/rules/Gendarme.Rules.Design.Linq/Gendarme.Rules.Design.Linq.csproj b/gendarme/rules/Gendarme.Rules.Design.Linq/Gendarme.Rules.Design.Linq.csproj
index 6a09a06..135c620 100644
--- a/gendarme/rules/Gendarme.Rules.Design.Linq/Gendarme.Rules.Design.Linq.csproj
+++ b/gendarme/rules/Gendarme.Rules.Design.Linq/Gendarme.Rules.Design.Linq.csproj
@@ -1,5 +1,5 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
     <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
@@ -10,8 +10,28 @@
     <AppDesignerFolder>Properties</AppDesignerFolder>
     <RootNamespace>Gendarme.Rules.Design.Linq</RootNamespace>
     <AssemblyName>Gendarme.Rules.Design.Linq</AssemblyName>
-    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
     <FileAlignment>512</FileAlignment>
+    <FileUpgradeFlags>
+    </FileUpgradeFlags>
+    <OldToolsVersion>3.5</OldToolsVersion>
+    <UpgradeBackupLocation />
+    <PublishUrl>publish\</PublishUrl>
+    <Install>true</Install>
+    <InstallFrom>Disk</InstallFrom>
+    <UpdateEnabled>false</UpdateEnabled>
+    <UpdateMode>Foreground</UpdateMode>
+    <UpdateInterval>7</UpdateInterval>
+    <UpdateIntervalUnits>Days</UpdateIntervalUnits>
+    <UpdatePeriodically>false</UpdatePeriodically>
+    <UpdateRequired>false</UpdateRequired>
+    <MapFileExtensions>true</MapFileExtensions>
+    <ApplicationRevision>0</ApplicationRevision>
+    <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
+    <IsWebBootstrapper>false</IsWebBootstrapper>
+    <UseApplicationTrust>false</UseApplicationTrust>
+    <BootstrapperEnabled>true</BootstrapperEnabled>
+    <TargetFrameworkProfile />
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
     <DebugSymbols>true</DebugSymbols>
@@ -24,6 +44,7 @@
     <DocumentationFile>..\..\console\bin\Debug\Gendarme.Rules.Design.Linq.xml</DocumentationFile>
     <NoWarn>1591</NoWarn>
     <WarningsAsErrors>1570</WarningsAsErrors>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
     <DebugType>pdbonly</DebugType>
@@ -35,6 +56,7 @@
     <NoWarn>1591</NoWarn>
     <WarningsAsErrors>1570</WarningsAsErrors>
     <DocumentationFile>..\..\console\bin\Release\Gendarme.Rules.Design.Linq.xml</DocumentationFile>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <ItemGroup>
     <Reference Include="System" />
@@ -58,6 +80,23 @@
       <Name>Gendarme.Framework</Name>
     </ProjectReference>
   </ItemGroup>
+  <ItemGroup>
+    <BootstrapperPackage Include="Microsoft.Net.Client.3.5">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1 Client Profile</ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Windows.Installer.3.1">
+      <Visible>False</Visible>
+      <ProductName>Windows Installer 3.1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+  </ItemGroup>
   <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
   <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
        Other similar extension points exist, see Microsoft.Common.targets.
diff --git a/gendarme/rules/Gendarme.Rules.Design.Linq/README.md b/gendarme/rules/Gendarme.Rules.Design.Linq/README.md
new file mode 100644
index 0000000..d80660c
--- /dev/null
+++ b/gendarme/rules/Gendarme.Rules.Design.Linq/README.md
@@ -0,0 +1,9 @@
+# Gendarme.Rules.Design.Linq Rules
+
+You can access the latest rules documentation from our [[wiki|https://github.com/spouliot/gendarme/wiki/Gendarme.Rules.Design.Linq(git)]] pages.
+
+
+## Feedback
+
+Please report any documentation errors, typos or suggestions to the [[Gendarme Mailing List|https://groups.google.com/forum/?fromgroups#!forum/gendarme]]. Thanks!
+
diff --git a/gendarme/rules/Gendarme.Rules.Design.Linq/Test/Tests.Rules.Design.Linq.csproj b/gendarme/rules/Gendarme.Rules.Design.Linq/Test/Tests.Rules.Design.Linq.csproj
index 2a013ee..10db1dc 100644
--- a/gendarme/rules/Gendarme.Rules.Design.Linq/Test/Tests.Rules.Design.Linq.csproj
+++ b/gendarme/rules/Gendarme.Rules.Design.Linq/Test/Tests.Rules.Design.Linq.csproj
@@ -1,5 +1,5 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
     <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
@@ -10,8 +10,28 @@
     <AppDesignerFolder>Properties</AppDesignerFolder>
     <RootNamespace>Tests.Rules.Design.Linq</RootNamespace>
     <AssemblyName>Tests.Rules.Design.Linq</AssemblyName>
-    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
     <FileAlignment>512</FileAlignment>
+    <FileUpgradeFlags>
+    </FileUpgradeFlags>
+    <OldToolsVersion>3.5</OldToolsVersion>
+    <UpgradeBackupLocation />
+    <PublishUrl>publish\</PublishUrl>
+    <Install>true</Install>
+    <InstallFrom>Disk</InstallFrom>
+    <UpdateEnabled>false</UpdateEnabled>
+    <UpdateMode>Foreground</UpdateMode>
+    <UpdateInterval>7</UpdateInterval>
+    <UpdateIntervalUnits>Days</UpdateIntervalUnits>
+    <UpdatePeriodically>false</UpdatePeriodically>
+    <UpdateRequired>false</UpdateRequired>
+    <MapFileExtensions>true</MapFileExtensions>
+    <ApplicationRevision>0</ApplicationRevision>
+    <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
+    <IsWebBootstrapper>false</IsWebBootstrapper>
+    <UseApplicationTrust>false</UseApplicationTrust>
+    <BootstrapperEnabled>true</BootstrapperEnabled>
+    <TargetFrameworkProfile />
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
     <DebugSymbols>true</DebugSymbols>
@@ -21,6 +41,7 @@
     <DefineConstants>DEBUG;TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
     <DebugType>pdbonly</DebugType>
@@ -29,6 +50,7 @@
     <DefineConstants>TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <ItemGroup>
     <Reference Include="nunit.framework, Version=2.4.8.0, Culture=neutral, PublicKeyToken=96d09a1eb7f44a77, processorArchitecture=MSIL">
@@ -68,6 +90,23 @@
   <ItemGroup>
     <Folder Include="Properties\" />
   </ItemGroup>
+  <ItemGroup>
+    <BootstrapperPackage Include="Microsoft.Net.Client.3.5">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1 Client Profile</ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Windows.Installer.3.1">
+      <Visible>False</Visible>
+      <ProductName>Windows Installer 3.1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+  </ItemGroup>
   <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
   <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
        Other similar extension points exist, see Microsoft.Common.targets.
diff --git a/gendarme/rules/Gendarme.Rules.Design/AttributeArgumentsShouldHaveAccessorsRule.cs b/gendarme/rules/Gendarme.Rules.Design/AttributeArgumentsShouldHaveAccessorsRule.cs
index df472de..cc037aa 100644
--- a/gendarme/rules/Gendarme.Rules.Design/AttributeArgumentsShouldHaveAccessorsRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Design/AttributeArgumentsShouldHaveAccessorsRule.cs
@@ -26,6 +26,7 @@
 
 using System;
 using System.Collections.Generic;
+using System.Globalization;
 
 using Mono.Cecil;
 
@@ -106,11 +107,18 @@ namespace Gendarme.Rules.Design {
 
 			// look through getters
 			allProperties.Clear ();
-			foreach (PropertyDefinition property in type.Properties) {
-				if (property.GetMethod != null) {
-					allProperties.Add (property.Name);
+
+			TypeDefinition t = type;
+			// Walk up the inheritance tree so that inherited properties are counted
+			do
+			{
+				foreach (PropertyDefinition property in t.Properties) {
+					if (property.GetMethod != null) {
+						allProperties.Add (property.Name);
+					}
 				}
-			}
+				t = t.BaseType != null ? t.BaseType.Resolve () : null;
+			} while (t != null  && !t.IsNamed ("System", "Attribute"));
 
 			// look through parameters
 			foreach (MethodDefinition constructor in type.Methods) {
@@ -119,9 +127,11 @@ namespace Gendarme.Rules.Design {
 
 				foreach (ParameterDefinition param in constructor.Parameters) {
 					 // pascal case it
-					string correspondingPropertyName = Char.ToUpper (param.Name [0]).ToString () + param.Name.Substring (1);
+					string correspondingPropertyName = Char.ToUpper (param.Name [0], CultureInfo.InvariantCulture).ToString (CultureInfo.InvariantCulture) +
+						param.Name.Substring (1);
 					if (!allProperties.Contains (correspondingPropertyName)) {
-						string s = String.Format ("Add '{0}' property to the attribute class.", correspondingPropertyName);
+						string s = String.Format (CultureInfo.InvariantCulture, 
+							"Add '{0}' property to the attribute class.", correspondingPropertyName);
 						Runner.Report (param, Severity.Medium, Confidence.High, s);
 						allProperties.Add (correspondingPropertyName); // to avoid double catching same property (e.g. from different constructors)
 					}
diff --git a/gendarme/rules/Gendarme.Rules.Design/AvoidPublicInstanceFieldsRule.cs b/gendarme/rules/Gendarme.Rules.Design/AvoidPublicInstanceFieldsRule.cs
index 0641913..9932c47 100644
--- a/gendarme/rules/Gendarme.Rules.Design/AvoidPublicInstanceFieldsRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Design/AvoidPublicInstanceFieldsRule.cs
@@ -25,6 +25,7 @@
 // THE SOFTWARE.
 
 using System;
+using System.Globalization;
 
 using Mono.Cecil;
 
@@ -89,11 +90,13 @@ namespace Gendarme.Rules.Design {
 
 				string name = fd.Name;
 				if (fd.FieldType.IsArray) {
-					string s = String.Format ("Consider changing the field '{0}' to a private or internal field and add a 'Set{1}{2}' method.",
-						name, Char.ToUpper (name [0]).ToString (), name.Substring (1));
+					string s = String.Format (CultureInfo.InvariantCulture, 
+						"Consider changing the field '{0}' to a private or internal field and add a 'Set{1}{2}' method.",
+						name, Char.ToUpper (name [0], CultureInfo.InvariantCulture).ToString (CultureInfo.InvariantCulture), name.Substring (1));
 					Runner.Report (fd, Severity.Medium, Confidence.Total, s);
 				} else {
-					string s = String.Format ("Field '{0}' should be private or internal and its value accessed through a property.", name);
+					string s = String.Format (CultureInfo.InvariantCulture, 
+						"Field '{0}' should be private or internal and its value accessed through a property.", name);
 					Runner.Report (fd, Severity.Medium, Confidence.Total, s);
 				}
 			}
diff --git a/gendarme/rules/Gendarme.Rules.Design/AvoidRefAndOutParametersRule.cs b/gendarme/rules/Gendarme.Rules.Design/AvoidRefAndOutParametersRule.cs
index 2e86234..b8828e9 100644
--- a/gendarme/rules/Gendarme.Rules.Design/AvoidRefAndOutParametersRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Design/AvoidRefAndOutParametersRule.cs
@@ -27,6 +27,7 @@
 //
 
 using System;
+using System.Globalization;
 using Mono.Cecil;
 
 using Gendarme.Framework;
@@ -139,7 +140,7 @@ namespace Gendarme.Rules.Design {
 				string how = null;
 				if (parameter.IsOut) {
 					// out is permitted for the "bool Try* (...)" pattern
-					if ((method.ReturnType.FullName == "System.Boolean") && 
+					if (method.ReturnType.IsNamed ("System", "Boolean") && 
 						method.Name.StartsWith ("Try", StringComparison.Ordinal)) {
 						continue;
 					}
@@ -153,7 +154,8 @@ namespace Gendarme.Rules.Design {
 				if ((how != null) && !IsSignatureDictatedByInterface (method)) {
 					// goal is to keep the API as simple as possible so this is more severe for public than protected methods
 					Severity severity = method.IsPublic ? Severity.Medium : Severity.Low;
-					string msg = String.Format ("Parameter '{0}' passed by reference ({1}).", parameter.Name, how);
+					string msg = String.Format (CultureInfo.InvariantCulture,
+						"Parameter '{0}' passed by reference ({1}).", parameter.Name, how);
 					Runner.Report (parameter, severity, Confidence.Total, msg);
 				}
 			}
diff --git a/gendarme/rules/Gendarme.Rules.Design/AvoidSmallNamespaceRule.cs b/gendarme/rules/Gendarme.Rules.Design/AvoidSmallNamespaceRule.cs
index 138b556..76f590a 100644
--- a/gendarme/rules/Gendarme.Rules.Design/AvoidSmallNamespaceRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Design/AvoidSmallNamespaceRule.cs
@@ -29,6 +29,7 @@
 using System;
 using System.Collections.Generic;
 using System.ComponentModel;
+using System.Globalization;
 
 using Mono.Cecil;
 
@@ -164,7 +165,8 @@ namespace Gendarme.Rules.Design {
 				// e.g. VS.NET adds a .Properties namespace to SWF apps
 				if ((count > 0) && (count < Minimum)) {
 					NamespaceDefinition n = NamespaceDefinition.GetDefinition (ns);
-					string msg = String.Format ("Only {0} visible types are defined inside this namespace.", count);
+					string msg = String.Format (CultureInfo.CurrentCulture, 
+						"Only {0} visible types are defined inside this namespace.", count);
 					// overloads of Report cannot be used here since the 'target' has been lost in the runner
 					Runner.Report (new Defect (this, n, n, Severity.Low, Confidence.Total, msg));
 				}
diff --git a/gendarme/rules/Gendarme.Rules.Design/ConsiderAddingInterfaceRule.cs b/gendarme/rules/Gendarme.Rules.Design/ConsiderAddingInterfaceRule.cs
index 342218f..ddcb92a 100644
--- a/gendarme/rules/Gendarme.Rules.Design/ConsiderAddingInterfaceRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Design/ConsiderAddingInterfaceRule.cs
@@ -28,6 +28,7 @@
 
 using System;
 using System.Collections.Generic;
+using System.Globalization;
 using System.Linq;
 
 using Mono.Cecil;
@@ -143,7 +144,8 @@ namespace Gendarme.Rules.Design {
 					if (HasConstraints (type))
 						continue;
 					if (DoesTypeStealthilyImplementInterface (type, iface)) {
-						string msg = string.Format ("Type implements '{0}' interface but does not declare it.", iface);
+						string msg = string.Format (CultureInfo.InvariantCulture,
+							"Type implements '{0}' interface but does not declare it.", iface);
 						// use our own Defect since the *real* target (of analysis) is 'type' not 'iface'
 						Runner.Report (new Defect (this, type, type, Severity.Medium, Confidence.High, msg));
 					}
@@ -165,7 +167,7 @@ namespace Gendarme.Rules.Design {
 				return false;
 
 			//type already publicly says it implements the interface
-			if (type.Implements (iface.FullName))
+			if (type.Implements (iface.Namespace, iface.Name))
 				return false;
 
 			foreach (MethodDefinition m in mdc) {
diff --git a/gendarme/rules/Gendarme.Rules.Design/ConsiderConvertingFieldToNullableRule.cs b/gendarme/rules/Gendarme.Rules.Design/ConsiderConvertingFieldToNullableRule.cs
index 453fc23..e5ffcfc 100644
--- a/gendarme/rules/Gendarme.Rules.Design/ConsiderConvertingFieldToNullableRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Design/ConsiderConvertingFieldToNullableRule.cs
@@ -25,6 +25,7 @@
 // THE SOFTWARE.
 
 using System;
+using System.Globalization;
 
 using Mono.Cecil;
 
@@ -75,7 +76,7 @@ namespace Gendarme.Rules.Design {
 
 		static bool IsHasField (FieldReference fd, ref string prefix, ref string suffix)
 		{
-			if (fd.FieldType.FullName != "System.Boolean")
+			if (!fd.FieldType.IsNamed ("System", "Boolean"))
 				return false;
 
 			string name = fd.Name;
@@ -122,7 +123,9 @@ namespace Gendarme.Rules.Design {
 					&& HasValueTypeField(type, string.Concat(prefix,suffix)) ) {
 					//TODO: check if they are both used in the same method? does the complexity worth it?
 					string s = (Runner.VerbosityLevel > 0)
-						? String.Format ("Field '{0}' should probably be a nullable if '{1}' purpose is to inform if '{0}' has been set.", fd.Name, suffix)
+						? String.Format (CultureInfo.InvariantCulture, 
+							"Field '{0}' should probably be a nullable if '{1}' purpose is to inform if '{0}' has been set.", 
+							fd.Name, suffix)
 						: string.Empty;
 					Runner.Report (fd, Severity.Low, Confidence.Low, s);
 				}
@@ -140,7 +143,7 @@ namespace Gendarme.Rules.Design {
 		{
 			foreach (FieldDefinition field in type.Fields) {
 				if (field.FieldType.IsValueType
-					&& "System.Nullable`1" != field.FieldType.GetElementType().FullName
+					&& !field.FieldType.GetElementType ().IsNamed ("System", "Nullable`1")
 					&& 0 == string.Compare(name, field.Name, StringComparison.OrdinalIgnoreCase))
 					return field;
 			}
diff --git a/gendarme/rules/Gendarme.Rules.Design/ConsiderConvertingMethodToPropertyRule.cs b/gendarme/rules/Gendarme.Rules.Design/ConsiderConvertingMethodToPropertyRule.cs
index 9d4ebbe..01622f4 100644
--- a/gendarme/rules/Gendarme.Rules.Design/ConsiderConvertingMethodToPropertyRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Design/ConsiderConvertingMethodToPropertyRule.cs
@@ -90,9 +90,9 @@ namespace Gendarme.Rules.Design {
 		string ReportAssociatedSetter (MethodDefinition getter)
 		{
 			string name = "Set" + getter.Name.Substring (3);
-			parameter [0] = getter.ReturnType.FullName;
+			parameter [0] = getter.ReturnType.GetFullName ();
 			MethodDefinition setter = getter.DeclaringType.GetMethod (name, Void, parameter);
-			return setter == null ? String.Empty : setter.ToString ();
+			return setter == null ? String.Empty : setter.GetFullName ();
 		}
 
 		public RuleResult CheckMethod (MethodDefinition method)
@@ -130,7 +130,7 @@ namespace Gendarme.Rules.Design {
 			bool get = name.StartsWith ("get", StringComparison.OrdinalIgnoreCase);
 			bool isp = name.StartsWith ("is", StringComparison.OrdinalIgnoreCase);
 			bool has = name.StartsWith ("has", StringComparison.OrdinalIgnoreCase);
-			if ((get || isp || has) && (method.Parameters.Count == 0) && (return_type.FullName != Void)) {
+			if ((get || isp || has) && !method.HasParameters && !return_type.IsNamed ("System", "Void")) {
 				// if it's a getter then look for a setter (to complete the report)
 				string msg = get ? ReportAssociatedSetter (method) : String.Empty;
 				Runner.Report (method, Severity.Low, Confidence.Normal, msg);
diff --git a/gendarme/rules/Gendarme.Rules.Design/ConsiderUsingStaticTypeRule.cs b/gendarme/rules/Gendarme.Rules.Design/ConsiderUsingStaticTypeRule.cs
index d6a5691..d024c20 100644
--- a/gendarme/rules/Gendarme.Rules.Design/ConsiderUsingStaticTypeRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Design/ConsiderUsingStaticTypeRule.cs
@@ -4,7 +4,7 @@
 // Authors:
 //	Sebastien Pouliot <sebastien@ximian.com>
 //
-// Copyright (C) 2008 Novell, Inc (http://www.novell.com)
+// Copyright (C) 2008, 2011 Novell, Inc (http://www.novell.com)
 //
 // Permission is hereby granted, free of charge, to any person obtaining
 // a copy of this software and associated documentation files (the
@@ -37,8 +37,8 @@ namespace Gendarme.Rules.Design {
 
 	/// <summary>
 	/// This rule checks for types that contain only static members and, if the assembly
-	/// targets the CLR version 2.0 or later, suggests that the type be made <c>static</c>.
-	/// The rule will ignore assemblies targeting earlier versions of the CLR.
+	/// targets the CLR version 2.0 or later, suggests that the type be made <c>static</c>
+	/// or, for earlier versions, that the type be made <c>sealed</c>.
 	/// </summary>
 	/// <example>
 	/// Bad example:
@@ -51,7 +51,7 @@ namespace Gendarme.Rules.Design {
 	/// </code>
 	/// </example>
 	/// <example>
-	/// Good example:
+	/// Good example (targetting CLR 2.0 and later):
 	/// <code>
 	/// public static class Class {
 	///	public static void Method ()
@@ -60,22 +60,22 @@ namespace Gendarme.Rules.Design {
 	/// }
 	/// </code>
 	/// </example>
+	/// <example>
+	/// Good example (targetting CLR 1.x):
+	/// <code>
+	/// public sealed class Class {
+	///	public static void Method ()
+	///	{
+	///	}
+	/// }
+	/// </code>
+	/// </example>
 
 	[Problem ("This type contains only static fields and methods and should be static.")]
-	[Solution ("Change this type into a static type to gain clarity and better error reporting.")]
+	[Solution ("Change this type into a static (or sealed for 1.x) type gain clarity and better error reporting.")]
+	[FxCopCompatibility ("Microsoft.Design", "CA1052:StaticHolderTypesShouldBeSealed")]
 	public class ConsiderUsingStaticTypeRule : Rule, ITypeRule {
 
-		public override void Initialize (IRunner runner)
-		{
-			base.Initialize (runner);
-
-			// Static type exists only since 2.0 so there's no point to execute this
-			// rule on every type if the assembly target runtime is earlier than 2.0
-			Runner.AnalyzeModule += delegate (object o, RunnerEventArgs e) {
-				Active = (e.CurrentModule.Runtime >= TargetRuntime.Net_2_0);
-			};
-		}
-
 		static bool IsAllStatic (TypeDefinition type)
 		{
 			if (type.HasMethods) {
@@ -99,31 +99,15 @@ namespace Gendarme.Rules.Design {
 			return true;
 		}
 
-		static int GetMethodCount (TypeDefinition type)
-		{
-			if (!type.HasMethods)
-				return 0;
-
-			int methods = 0;
-
-			foreach (var method in type.Methods) {
-				if (!method.IsConstructor)
-					methods++;
-			}
-
-			return methods;
-		}
-
 		public RuleResult CheckType (TypeDefinition type)
 		{
 			// rule applies only if the type isn't: an enum, an interface, a struct, a delegate or compiler generated
-			if (type.IsEnum || type.IsInterface || type.IsValueType || !type.HasFields && GetMethodCount (type) == 0
-				|| type.IsDelegate () || type.IsGeneratedCode () 
-				|| type.BaseType != null && type.BaseType.FullName != "System.Object")
+			if (type.IsEnum || type.IsInterface || type.IsValueType || type.IsDelegate () || type.IsGeneratedCode () 
+				|| type.BaseType != null && !type.BaseType.IsNamed ("System", "Object"))
 				return RuleResult.DoesNotApply;
 			
-			// success if the type is already static
-			if (type.IsStatic ())
+			// success if the type is already static or, before 2.0, is it's sealed
+			if ((type.Module.Runtime >= TargetRuntime.Net_2_0) ? type.IsStatic () : type.IsSealed)
 				return RuleResult.Success;
 			
 			if (IsAllStatic (type)) {
diff --git a/gendarme/rules/Gendarme.Rules.Design/DeclareEventHandlersCorrectlyRule.cs b/gendarme/rules/Gendarme.Rules.Design/DeclareEventHandlersCorrectlyRule.cs
index 82386a2..d6cf62b 100644
--- a/gendarme/rules/Gendarme.Rules.Design/DeclareEventHandlersCorrectlyRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Design/DeclareEventHandlersCorrectlyRule.cs
@@ -28,6 +28,7 @@
 
 using System;
 using System.Collections.Generic;
+using System.Globalization;
 using Gendarme.Framework;
 using Gendarme.Framework.Rocks;
 using Gendarme.Framework.Helpers;
@@ -85,11 +86,12 @@ namespace Gendarme.Rules.Design {
 
 		private bool CheckReturnVoid (IMetadataTokenProvider eventType, IMethodSignature invoke)
 		{
-			string full_name = invoke.ReturnType.FullName;
-			if (String.Compare (full_name, "System.Void") == 0)
+			TypeReference rtype = invoke.ReturnType;
+			if (rtype.IsNamed ("System", "Void"))
 				return true;
 
-			string msg = String.Format ("The delegate should return void, not {0}", full_name);
+			string msg = String.Format (CultureInfo.InvariantCulture, 
+				"The delegate should return void, not {0}", rtype.GetFullName ());
 			Runner.Report (eventType, Severity.Medium, Confidence.High, msg);
 			return false;
 		}
@@ -112,14 +114,16 @@ namespace Gendarme.Rules.Design {
 			IList<ParameterDefinition> pdc = invoke.Parameters;
 			int count = pdc.Count;
 			if (count >= 1) {
-				string type_name = pdc [0].ParameterType.FullName;
-				if (String.Compare (type_name, "System.Object") != 0) {
-					Runner.Report (eventType, Severity.Medium, Confidence.High, String.Format ("The first parameter should have an object, not {0}", type_name));
+				TypeReference ptype = pdc [0].ParameterType;
+				if (!ptype.IsNamed ("System", "Object")) {
+					string msg = String.Format (CultureInfo.InvariantCulture, 
+						"The first parameter should have an object, not {0}", ptype.GetFullName ());
+					Runner.Report (eventType, Severity.Medium, Confidence.High, msg);
 					ok = false;
 				}
 			}
 			if (count >= 2) {
-				if (!pdc [1].ParameterType.Inherits ("System.EventArgs")) {
+				if (!pdc [1].ParameterType.Inherits ("System", "EventArgs")) {
 					Runner.Report (eventType, Severity.Medium, Confidence.High, "The second parameter should be a subclass of System.EventArgs");
 					ok = false;
 				}
@@ -129,10 +133,12 @@ namespace Gendarme.Rules.Design {
 
 		private bool CheckParameterName (IMetadataTokenProvider eventType, ParameterReference invokeParameter, string expectedName)
 		{
-			if (String.Compare (invokeParameter.Name, expectedName) == 0)
+			if (invokeParameter.Name == expectedName)
 				return true;
 
-			Runner.Report (eventType, Severity.Low, Confidence.High, String.Format ("The expected name is {0}, not {1}", expectedName, invokeParameter.Name));
+			string msg = String.Format (CultureInfo.InvariantCulture, "The expected name is {0}, not {1}", 
+				expectedName, invokeParameter.Name);
+			Runner.Report (eventType, Severity.Low, Confidence.High, msg);
 			return false;
 		}
 		
@@ -189,9 +195,9 @@ namespace Gendarme.Rules.Design {
 			return valid;
 		}
 
-		private bool CheckGenericDelegate (MemberReference type)
+		private bool CheckGenericDelegate (TypeReference type)
 		{
-			if (type.FullName == "System.EventHandler`1")
+			if (type.IsNamed ("System", "EventHandler`1"))
 				return true;
 
 			Runner.Report (type, Severity.Medium, Confidence.High, "Generic delegates should use EventHandler<TEventArgs>");
diff --git a/gendarme/rules/Gendarme.Rules.Design/DisposableTypesShouldHaveFinalizerRule.cs b/gendarme/rules/Gendarme.Rules.Design/DisposableTypesShouldHaveFinalizerRule.cs
index 56133c9..dff2b48 100644
--- a/gendarme/rules/Gendarme.Rules.Design/DisposableTypesShouldHaveFinalizerRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Design/DisposableTypesShouldHaveFinalizerRule.cs
@@ -75,7 +75,7 @@ namespace Gendarme.Rules.Design {
 				return RuleResult.DoesNotApply;
 
 			// rule onyly applies to type that implements IDisposable
-			if (!type.Implements ("System.IDisposable"))
+			if (!type.Implements ("System", "IDisposable"))
 				return RuleResult.DoesNotApply;
 
 			// no problem is a finalizer is found
diff --git a/gendarme/rules/Gendarme.Rules.Design/DoNotDeclareSettersOnCollectionPropertiesRule.cs b/gendarme/rules/Gendarme.Rules.Design/DoNotDeclareSettersOnCollectionPropertiesRule.cs
new file mode 100644
index 0000000..37c7b8c
--- /dev/null
+++ b/gendarme/rules/Gendarme.Rules.Design/DoNotDeclareSettersOnCollectionPropertiesRule.cs
@@ -0,0 +1,124 @@
+// 
+// Gendarme.Rules.Design.DoNotDeclareSettersOnCollectionPropertiesRule
+//
+// Authors:
+//	Sebastien Pouliot <sebastien@ximian.com>
+//
+// Copyright (C) 2011 Novell, Inc (http://www.novell.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+using Mono.Cecil;
+
+using Gendarme.Framework;
+using Gendarme.Framework.Rocks;
+
+namespace Gendarme.Rules.Design {
+
+	/// <summary>
+	/// The rule detect <c>System.Collections.ICollection</c> and 
+	/// <c>System.Collections.Generic.ICollection&lt;T&gt;</c> properties that declare a visible setter.
+	/// There is rarely a need to be able to replace the collection (e.g. most collections provide a <c>Clear</c>
+	/// method) and having a getter only does not prevent the consumer from adding and removing items in the collection.
+	/// Also read-only properties have special support for binary and XML serialization, making your code more useful.
+	/// A special exception is made for <c>System.Security.PermissionSet</c> and types that derives from it.
+	/// </summary>
+	/// <example>
+	/// Bad example:
+	/// <code>
+	/// public class Holder {
+	///	public string Name { get; set; }
+	///	public ICollection&lt;string&gt; List { get; set; }
+	/// }
+	/// 
+	/// public static Holder Copy (Holder h)
+	/// {
+	///	Holder copy = new Holder ();
+	///	copy.Name = h.Name;
+	///	// bad, same list would be shared between instances
+	///	copy.List = h.List;
+	///	copy.List.AddRange (h.List);
+	///	return copy;
+	/// }
+	/// </code>
+	/// </example>
+	/// <example>
+	/// Good example:
+	/// <code>
+	/// public class Holder {
+	///	List&lt;string&gt; list;
+	///	
+	///	public Holder ()
+	///	{
+	///		list = new List&lt;string&gt; ();
+	///	}
+	///	
+	///	public string Name { get; set; }
+	///	
+	///	public ICollection&lt;string&gt; List { 
+	///		get { return list; }
+	///	}
+	/// }
+	/// 
+	/// public static Holder Copy (Holder h)
+	/// {
+	///	Holder copy = new Holder ();
+	///	copy.Name = h.Name;
+	///	copy.List.AddRange (h.List);
+	///	return copy;
+	/// }
+	/// </code>
+	/// </example>
+	[Problem ("A visible setter is declared for an ICollection (or derived) property")]
+	[Solution ("Replace the setter with a method or decrease the setter visibility")]
+	[FxCopCompatibility ("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly")]
+	public class DoNotDeclareSettersOnCollectionPropertiesRule : Rule, ITypeRule {
+
+		static bool IsICollection (TypeReference type)
+		{
+			if (type.Implements ("System.Collections", "ICollection"))
+				return true;
+
+			return type.Implements ("System.Collections.Generic", "ICollection`1");
+		}
+
+		static bool IsSpecialCase (TypeReference type)
+		{
+			return type.Inherits ("System.Security", "PermissionSet");
+		}
+
+		public RuleResult CheckType (TypeDefinition type)
+		{
+			if (!type.HasProperties || !type.IsVisible ())
+				return RuleResult.DoesNotApply;
+
+			bool is_interface = type.IsInterface;
+			foreach (PropertyDefinition pd in type.Properties) {
+				MethodDefinition setter = pd.SetMethod;
+				if ((setter == null) || (!is_interface && !setter.IsVisible ()))
+					continue;
+
+				TypeReference ptype = pd.PropertyType;
+				if (IsICollection (ptype) && !IsSpecialCase (ptype))
+					Runner.Report (setter, Severity.Medium, Confidence.High);
+			}
+			return Runner.CurrentRuleResult;
+		}
+	}
+}
diff --git a/gendarme/rules/Gendarme.Rules.Design/EnsureSymmetryForOverloadedOperatorsRule.cs b/gendarme/rules/Gendarme.Rules.Design/EnsureSymmetryForOverloadedOperatorsRule.cs
index 7f45898..33d8fce 100644
--- a/gendarme/rules/Gendarme.Rules.Design/EnsureSymmetryForOverloadedOperatorsRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Design/EnsureSymmetryForOverloadedOperatorsRule.cs
@@ -28,6 +28,7 @@
 
 using System;
 using System.Collections.Generic;
+using System.Globalization;
 using Mono.Cecil;
 
 using Gendarme.Framework;
@@ -124,7 +125,7 @@ namespace Gendarme.Rules.Design {
 					return; //both are defined
 			}
 
-			string s = string.Format (Message, pair.Key.Name, pair.Value.Name);
+			string s = string.Format (CultureInfo.InvariantCulture, Message, pair.Key.Name, pair.Value.Name);
 			Runner.Report (op, severity, Confidence.Total, s);
 		}
 	}
diff --git a/gendarme/rules/Gendarme.Rules.Design/EnumeratorsShouldBeStronglyTypedRule.cs b/gendarme/rules/Gendarme.Rules.Design/EnumeratorsShouldBeStronglyTypedRule.cs
index 815b329..a3bc8e4 100644
--- a/gendarme/rules/Gendarme.Rules.Design/EnumeratorsShouldBeStronglyTypedRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Design/EnumeratorsShouldBeStronglyTypedRule.cs
@@ -78,29 +78,40 @@ namespace Gendarme.Rules.Design {
 	[FxCopCompatibility ("Microsoft.Design", "CA1038:EnumeratorsShouldBeStronglyTyped")]
 	public class EnumeratorsShouldBeStronglyTypedRule : StronglyTypedRule, ITypeRule {
 
+		private MethodSignature [] Empty = { };
+		private static string [] Current = { "Current" };
+
 		protected override MethodSignature [] GetMethods ()
 		{
-			return new MethodSignature [] { };
+			return Empty;
 		}
 
 		protected override string [] GetProperties ()
 		{
-			return new string [] { "Current" };
+			return Current;
 		}
 
 		protected override string InterfaceName {
-			get { return "System.Collections.IEnumerator"; }
+			get { return "IEnumerator"; }
+		}
+
+		protected override string InterfaceNamespace {
+			get { return "System.Collections"; }
 		}
 
 		override public RuleResult CheckType (TypeDefinition type)
 		{
 			TypeReference baseType = type;
 			while (baseType != null) {
-				string name = baseType.FullName;
-				if (name == "System.Collections.CollectionBase" ||
-					name == "System.Collections.DictionaryBase" ||
-					name == "System.Collections.ReadOnlyCollectionBase")
-					return RuleResult.DoesNotApply;
+				if (baseType.Namespace == "System.Collections") {
+					switch (baseType.Name) {
+					case "CollectionBase":
+					case "DictionaryBase":
+					case "ReadOnlyCollectionBase":
+						return RuleResult.DoesNotApply;
+					}
+				}
+
 				TypeDefinition td = baseType.Resolve ();
 				if (td != null)
 					baseType = td.BaseType;
diff --git a/gendarme/rules/Gendarme.Rules.Design/EnumsShouldUseInt32Rule.cs b/gendarme/rules/Gendarme.Rules.Design/EnumsShouldUseInt32Rule.cs
index 13460c2..3d2da47 100644
--- a/gendarme/rules/Gendarme.Rules.Design/EnumsShouldUseInt32Rule.cs
+++ b/gendarme/rules/Gendarme.Rules.Design/EnumsShouldUseInt32Rule.cs
@@ -25,6 +25,7 @@
 // THE SOFTWARE.
 
 using System;
+using System.Globalization;
 
 using Mono.Cecil;
 
@@ -89,33 +90,36 @@ namespace Gendarme.Rules.Design {
 
 			// rule applies!
 
-			string value_type = null;
+			TypeReference ftype = null;
 
 			foreach (FieldDefinition field in type.Fields) {
 				// we looking for the special value__
 				if (!field.IsStatic) {
-					value_type = field.FieldType.FullName;
+					ftype = field.FieldType;
 					break;
 				}
 			}
 
-			Severity severity;
-			switch (value_type) {
-			case "System.Int32":
-				return RuleResult.Success;
-			// some are bad choice (when possible) but usable by all CLS compliant languages
-			case "System.Byte":
-			case "System.Int16":
-			case "System.Int64":
+			Severity severity = Severity.Critical;
+			if ((ftype != null) && (ftype.Namespace == "System")) {
+				switch (ftype.Name) {
+				case "Int32":
+					return RuleResult.Success;
+				// some are bad choice (when possible) but usable by all CLS compliant languages
+				case "Byte":
+				case "Int16":
+				case "Int64":
 				severity = Severity.High;
-				break;
-			// while others are not usable in non-CLS compliant languages
-			default: // System.SByte, System.UInt16, System.UInt32, System.UInt64
-				severity = Severity.Critical;
-				break;
+					break;
+				// while others are not usable in non-CLS compliant languages
+				default: // System.SByte, System.UInt16, System.UInt32, System.UInt64
+					severity = Severity.Critical;
+					break;
+				}
 			}
 
-			string text = String.Format ("Enums should use System.Int32 instead of '{0}'.", value_type);
+			string text = String.Format (CultureInfo.InvariantCulture, 
+				"Enums should use System.Int32 instead of '{0}'.", ftype.GetFullName ());
 			Runner.Report (type, severity, Confidence.Total, text);
 			return RuleResult.Failure;
 		}
diff --git a/gendarme/rules/Gendarme.Rules.Design/Gendarme.Rules.Design.csproj b/gendarme/rules/Gendarme.Rules.Design/Gendarme.Rules.Design.csproj
index c9f8ed4..9f6ad7c 100755
--- a/gendarme/rules/Gendarme.Rules.Design/Gendarme.Rules.Design.csproj
+++ b/gendarme/rules/Gendarme.Rules.Design/Gendarme.Rules.Design.csproj
@@ -1,5 +1,5 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
     <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
@@ -10,8 +10,28 @@
     <AppDesignerFolder>Properties</AppDesignerFolder>
     <RootNamespace>Gendarme.Rules.Design</RootNamespace>
     <AssemblyName>Gendarme.Rules.Design</AssemblyName>
-    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
     <FileAlignment>512</FileAlignment>
+    <FileUpgradeFlags>
+    </FileUpgradeFlags>
+    <OldToolsVersion>3.5</OldToolsVersion>
+    <UpgradeBackupLocation />
+    <PublishUrl>publish\</PublishUrl>
+    <Install>true</Install>
+    <InstallFrom>Disk</InstallFrom>
+    <UpdateEnabled>false</UpdateEnabled>
+    <UpdateMode>Foreground</UpdateMode>
+    <UpdateInterval>7</UpdateInterval>
+    <UpdateIntervalUnits>Days</UpdateIntervalUnits>
+    <UpdatePeriodically>false</UpdatePeriodically>
+    <UpdateRequired>false</UpdateRequired>
+    <MapFileExtensions>true</MapFileExtensions>
+    <ApplicationRevision>0</ApplicationRevision>
+    <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
+    <IsWebBootstrapper>false</IsWebBootstrapper>
+    <UseApplicationTrust>false</UseApplicationTrust>
+    <BootstrapperEnabled>true</BootstrapperEnabled>
+    <TargetFrameworkProfile />
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
     <DebugSymbols>true</DebugSymbols>
@@ -24,6 +44,7 @@
     <DocumentationFile>..\..\console\bin\Debug\Gendarme.Rules.Design.xml</DocumentationFile>
     <NoWarn>1591</NoWarn>
     <WarningsAsErrors>1570</WarningsAsErrors>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
     <DebugType>pdbonly</DebugType>
@@ -35,6 +56,7 @@
     <NoWarn>1591</NoWarn>
     <WarningsAsErrors>1570</WarningsAsErrors>
     <DocumentationFile>..\..\console\bin\Release\Gendarme.Rules.Design.xml</DocumentationFile>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <ItemGroup>
     <Reference Include="System" />
@@ -90,8 +112,6 @@
     <Compile Include="ProvideTryParseAlternativeRule.cs" />
     <Compile Include="StronglyTypedRule.cs" />
     <Compile Include="TypesShouldBeInsideNamespacesRule.cs" />
-    <Compile Include="TypesWithDisposableFieldsShouldBeDisposableRule.cs" />
-    <Compile Include="TypesWithNativeFieldsShouldBeDisposableRule.cs" />
     <Compile Include="UseCorrectDisposeSignaturesRule.cs" />
     <Compile Include="UseFlagsAttributeRule.cs" />
     <Compile Include="UsingCloneWithoutImplementingICloneableRule.cs" />
@@ -107,6 +127,23 @@
       <Name>Gendarme.Framework</Name>
     </ProjectReference>
   </ItemGroup>
+  <ItemGroup>
+    <BootstrapperPackage Include="Microsoft.Net.Client.3.5">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1 Client Profile</ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Windows.Installer.3.1">
+      <Visible>False</Visible>
+      <ProductName>Windows Installer 3.1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+  </ItemGroup>
   <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
   <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
        Other similar extension points exist, see Microsoft.Common.targets.
diff --git a/gendarme/rules/Gendarme.Rules.Design/ImplementEqualsAndGetHashCodeInPairRule.cs b/gendarme/rules/Gendarme.Rules.Design/ImplementEqualsAndGetHashCodeInPairRule.cs
index 14e555f..c1e01c5 100644
--- a/gendarme/rules/Gendarme.Rules.Design/ImplementEqualsAndGetHashCodeInPairRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Design/ImplementEqualsAndGetHashCodeInPairRule.cs
@@ -27,6 +27,7 @@
 // THE SOFTWARE.
 				
 using System;
+using System.Globalization;
 
 using Mono.Cecil;
 
@@ -99,13 +100,13 @@ namespace Gendarme.Rules.Design {
 
 			// if we have Equals but no GetHashCode method
 			if (equals && !getHashCode) {
-				string text = String.Format (Message, MethodSignatures.Equals, MethodSignatures.GetHashCode);
+				string text = String.Format (CultureInfo.InvariantCulture, Message, MethodSignatures.Equals, MethodSignatures.GetHashCode);
 				Runner.Report (type, Severity.Critical, Confidence.High, text);
 			}
 
 			// if we have GetHashCode but no Equals method
 			if (!equals && getHashCode) {
-				string text = String.Format (Message, MethodSignatures.GetHashCode, MethodSignatures.Equals);
+				string text = String.Format (CultureInfo.InvariantCulture, Message, MethodSignatures.GetHashCode, MethodSignatures.Equals);
 				Runner.Report (type, Severity.Medium, Confidence.High, text);
 			}
 
diff --git a/gendarme/rules/Gendarme.Rules.Design/ImplementIComparableCorreclyRule.cs b/gendarme/rules/Gendarme.Rules.Design/ImplementIComparableCorreclyRule.cs
index a214f80..11c45aa 100644
--- a/gendarme/rules/Gendarme.Rules.Design/ImplementIComparableCorreclyRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Design/ImplementIComparableCorreclyRule.cs
@@ -110,8 +110,10 @@ namespace Gendarme.Rules.Design {
 			// Note: we do not use Implements rock because we do not want a recursive answer
 			bool icomparable = false;
 			foreach (TypeReference iface in type.Interfaces) {
+				if (iface.Namespace != "System")
+					continue;
 				// catch both System.IComparable and System.IComparable`1<X>
-				if (iface.FullName.StartsWith ("System.IComparable", StringComparison.Ordinal)) {
+				if (iface.Name.StartsWith ("IComparable", StringComparison.Ordinal)) {
 					icomparable = true;
 					break;
 				}
diff --git a/gendarme/rules/Gendarme.Rules.Design/ListsAreStronglyTypedRule.cs b/gendarme/rules/Gendarme.Rules.Design/ListsAreStronglyTypedRule.cs
index f669c6a..9595df1 100644
--- a/gendarme/rules/Gendarme.Rules.Design/ListsAreStronglyTypedRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Design/ListsAreStronglyTypedRule.cs
@@ -74,8 +74,9 @@ namespace Gendarme.Rules.Design {
 	[Problem ("Types that implement IList should have strongly typed versions of IList.Item, IList.Add, IList.Contains, IList.IndexOf, IList.Insert and IList.Remove")]
 	[Solution ("Explicitly implement IList members and provide strongly typed alternatives to them.")]
 	[FxCopCompatibility ("Microsoft.Design", "CA1039:ListsAreStronglyTyped")]
-	public class ListsAreStronglyTypedRule : StronglyTypedRule, ITypeRule
-	{
+	public class ListsAreStronglyTypedRule : StronglyTypedRule, ITypeRule {
+
+		private static string [] Item = new string [] { "Item" };
 
 		private static string[] SystemObject = new string[] {"System.Object"};
 		private static MethodSignature Add = new MethodSignature ("Add", "System.Int32", SystemObject);
@@ -83,25 +84,31 @@ namespace Gendarme.Rules.Design {
 		private static MethodSignature IndexOf = new MethodSignature ("IndexOf", "System.Int32", SystemObject);
 		private static MethodSignature Insert = new MethodSignature ("Insert", "System.Void", new string [] { "System.Int32", "System.Object" });
 		private static MethodSignature Remove = new MethodSignature ("Remove", "System.Void", SystemObject);
-		
+
+		private static MethodSignature [] Signatures = {
+			Add,
+			Contains,
+			IndexOf,
+			Insert,
+			Remove,
+		};
+
 		protected override MethodSignature [] GetMethods ()
 		{
-			return new MethodSignature[] {
-				Add,
-				Contains,
-				IndexOf,
-				Insert,
-				Remove,
-			};
+			return Signatures;
 		}
 
 		protected override string [] GetProperties ()
 		{
-			return new string [] { "Item" };
+			return Item;
 		}
 
 		protected override string InterfaceName {
-			get { return "System.Collections.IList"; }
+			get { return "IList"; }
+		}
+
+		protected override string InterfaceNamespace {
+			get { return "System.Collections"; }
 		}
 	}
 }
diff --git a/gendarme/rules/Gendarme.Rules.Design/Makefile.am b/gendarme/rules/Gendarme.Rules.Design/Makefile.am
index d6c861d..e9545b3 100644
--- a/gendarme/rules/Gendarme.Rules.Design/Makefile.am
+++ b/gendarme/rules/Gendarme.Rules.Design/Makefile.am
@@ -17,6 +17,7 @@ rules_sources =  \
 	DeclareEventHandlersCorrectlyRule.cs \
 	DefineAZeroValueRule.cs \
 	DisposableTypesShouldHaveFinalizerRule.cs \
+	DoNotDeclareSettersOnCollectionPropertiesRule.cs \
 	DoNotDeclareVirtualMethodsInSealedTypeRule.cs \
 	DontDeclareProtectedFieldsInSealedClassRule.cs \
 	EnsureSymmetryForOverloadedOperatorsRule.cs \
@@ -46,8 +47,6 @@ rules_sources =  \
 	StronglyTypedRule.cs \
 	StronglyTypeICollectionMembersRule.cs \
 	TypesShouldBeInsideNamespacesRule.cs \
-	TypesWithDisposableFieldsShouldBeDisposableRule.cs \
-	TypesWithNativeFieldsShouldBeDisposableRule.cs \
 	UseFlagsAttributeRule.cs \
 	UseCorrectDisposeSignaturesRule.cs \
 	UsingCloneWithoutImplementingICloneableRule.cs
@@ -70,6 +69,7 @@ tests_sources = \
 	ConsiderUsingStaticTypeTest.cs \
 	DeclareEventHandlersCorrectlyTest.cs \
 	DisposableTypesShouldHaveFinalizerTest.cs \
+	DoNotDeclareSettersOnCollectionPropertiesTest.cs \
 	DoNotDeclareVirtualMethodsInSealedTypeTest.cs \
 	DontDeclareProtectedFieldsInSealedClassTest.cs \
 	EnsureSymmetryForOverloadedOperatorsTest.cs \
@@ -98,8 +98,6 @@ tests_sources = \
 	ProvideAlternativeNamesForOperatorOverloadsTest.cs \
 	StronglyTypeICollectionMembersTest.cs \
 	TypesShouldBeInsideNamespacesTest.cs \
-	TypesWithDisposableFieldsShouldBeDisposableTest.cs \
-	TypesWithNativeFieldsShouldBeDisposableTest.cs \
 	UseFlagsAttributeTest.cs \
 	UseCorrectDisposeSignaturesTest.cs \
 	UsingCloneWithoutImplementingICloneableTest.cs
diff --git a/gendarme/rules/Gendarme.Rules.Design/MarkAssemblyWithAttributeRule.cs b/gendarme/rules/Gendarme.Rules.Design/MarkAssemblyWithAttributeRule.cs
index 031667a..f9dc4af 100644
--- a/gendarme/rules/Gendarme.Rules.Design/MarkAssemblyWithAttributeRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Design/MarkAssemblyWithAttributeRule.cs
@@ -38,6 +38,7 @@ namespace Gendarme.Rules.Design {
 
 	abstract public class MarkAssemblyWithAttributeRule : Rule, IAssemblyRule {
 
+		abstract protected string AttributeNamespace { get; }
 		abstract protected string AttributeName { get; }
 
 		abstract protected Severity Severity { get; }
@@ -47,7 +48,7 @@ namespace Gendarme.Rules.Design {
 			if (!assembly.HasCustomAttributes)
 				return RuleResult.DoesNotApply;
 
-			if (assembly.HasAttribute (AttributeName))
+			if (assembly.HasAttribute (AttributeNamespace, AttributeName))
 				return RuleResult.Success;
 
 			Runner.Report (assembly, Severity, Confidence.Total);
diff --git a/gendarme/rules/Gendarme.Rules.Design/MarkAssemblyWithCLSCompliantRule.cs b/gendarme/rules/Gendarme.Rules.Design/MarkAssemblyWithCLSCompliantRule.cs
index a2594c8..c686d4b 100644
--- a/gendarme/rules/Gendarme.Rules.Design/MarkAssemblyWithCLSCompliantRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Design/MarkAssemblyWithCLSCompliantRule.cs
@@ -56,8 +56,12 @@ namespace Gendarme.Rules.Design {
 	[FxCopCompatibility ("Microsoft.Design", "CA1014:MarkAssembliesWithClsCompliant")]
 	public class MarkAssemblyWithCLSCompliantRule : MarkAssemblyWithAttributeRule {
 
+		protected override string AttributeNamespace {
+			get { return "System"; }
+		}
+
 		protected override string AttributeName {
-			get { return "System.CLSCompliantAttribute"; }
+			get { return "CLSCompliantAttribute"; }
 		}
 
 		protected override Severity Severity {
diff --git a/gendarme/rules/Gendarme.Rules.Design/MarkAssemblyWithComVisibleRule.cs b/gendarme/rules/Gendarme.Rules.Design/MarkAssemblyWithComVisibleRule.cs
index ca2dcc4..59dfac8 100644
--- a/gendarme/rules/Gendarme.Rules.Design/MarkAssemblyWithComVisibleRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Design/MarkAssemblyWithComVisibleRule.cs
@@ -55,8 +55,12 @@ namespace Gendarme.Rules.Design {
 	[FxCopCompatibility ("Microsoft.Design", "CA1017:MarkAssembliesWithComVisible")]
 	public class MarkAssemblyWithComVisibleRule : MarkAssemblyWithAttributeRule {
 
+		protected override string AttributeNamespace	{
+			get { return "System.Runtime.InteropServices"; }
+		}
+
 		protected override string AttributeName	{
-			get { return "System.Runtime.InteropServices.ComVisibleAttribute"; }
+			get { return "ComVisibleAttribute"; }
 		}
 
 		protected override Severity Severity {
diff --git a/gendarme/rules/Gendarme.Rules.Design/MissingAttributeUsageOnCustomAttributeRule.cs b/gendarme/rules/Gendarme.Rules.Design/MissingAttributeUsageOnCustomAttributeRule.cs
index addc0d5..e0e5135 100644
--- a/gendarme/rules/Gendarme.Rules.Design/MissingAttributeUsageOnCustomAttributeRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Design/MissingAttributeUsageOnCustomAttributeRule.cs
@@ -66,15 +66,13 @@ namespace Gendarme.Rules.Design {
 	[FxCopCompatibility ("Microsoft.Design", "CA1018:MarkAttributesWithAttributeUsage")]
 	public class MissingAttributeUsageOnCustomAttributeRule : Rule, ITypeRule {
 
-		private const string AttributeUsageAttribute = "System.AttributeUsageAttribute";
-
 		public RuleResult CheckType (TypeDefinition type)
 		{
 			// rule applies only to attributes
 			if (!type.IsAttribute ())
 				return RuleResult.DoesNotApply;
 
-			if (type.HasAttribute (AttributeUsageAttribute)) // it's ok
+			if (type.HasAttribute ("System", "AttributeUsageAttribute")) // it's ok
 				return RuleResult.Success;
 
 			Runner.Report (type, Severity.High, Confidence.Total);
diff --git a/gendarme/rules/Gendarme.Rules.Design/PreferIntegerOrStringForIndexersRule.cs b/gendarme/rules/Gendarme.Rules.Design/PreferIntegerOrStringForIndexersRule.cs
index ff8f07b..8da1533 100644
--- a/gendarme/rules/Gendarme.Rules.Design/PreferIntegerOrStringForIndexersRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Design/PreferIntegerOrStringForIndexersRule.cs
@@ -80,16 +80,22 @@ namespace Gendarme.Rules.Design {
 				return RuleResult.Success;
 
 			foreach (ParameterDefinition parameter in method.Parameters) {
-				switch (parameter.ParameterType.FullName) {
-				case "System.Int32":
-				case "System.Int64":
-				case "System.String":
-				case "System.Object": // tolerable in some circumstances
-					break;
-				default:
-					Runner.Report (parameter, Severity.Medium, Confidence.Total);
-					break;
+				TypeReference ptype = parameter.ParameterType;
+				bool ok = (ptype.Namespace == "System");
+				if (ok) {
+					switch (ptype.Name) {
+					case "Int32":
+					case "Int64":
+					case "String":
+					case "Object": // tolerable in some circumstances
+						break;
+					default:
+						ok = false;
+						break;
+					}
 				}
+				if (!ok)
+					Runner.Report (parameter, Severity.Medium, Confidence.Total);
 			}
 			return Runner.CurrentRuleResult;
 		}
diff --git a/gendarme/rules/Gendarme.Rules.Design/PreferUriOverStringRule.cs b/gendarme/rules/Gendarme.Rules.Design/PreferUriOverStringRule.cs
index cc15916..8143bda 100644
--- a/gendarme/rules/Gendarme.Rules.Design/PreferUriOverStringRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Design/PreferUriOverStringRule.cs
@@ -34,6 +34,7 @@ using Gendarme.Framework.Rocks;
 using System;
 using System.Linq;
 using System.Collections.Generic;
+using System.Globalization;
 
 namespace Gendarme.Rules.Design {
 
@@ -100,7 +101,7 @@ namespace Gendarme.Rules.Design {
 			// We assume the name is pascal- or camel- cased: to prevent false-positives (such as the urn in return),
 			// the position is only returned if the character is the first in the string, or is an uppercase letter.
 			while ((index = memberName.IndexOf (token, index, StringComparison.OrdinalIgnoreCase)) != -1) {
-				if (index == 0 || char.IsUpper (memberName [index]))
+				if (index == 0 || Char.IsUpper (memberName [index]))
 					break;
 				index += token.Length;
 			}
@@ -110,10 +111,10 @@ namespace Gendarme.Rules.Design {
 		private static bool IsUri (string memberName)
 		{
 			int index = 0;
-			while ((index = FindTokenStart (memberName, "ur", index)) != -1) {
-				if (memberName.Length < index + 2)
+			while ((index = FindTokenStart(memberName, "ur", index)) != -1){
+				if (memberName.Length <= index + 2)
 					break;
-				if (url_enders.Contains (char.ToLower (memberName [index + 2])))
+				if (url_enders.Contains(Char.ToLower(memberName[index + 2], CultureInfo.InvariantCulture)))
 					return true;
 				index += 2;
 			}
@@ -159,7 +160,7 @@ namespace Gendarme.Rules.Design {
 		{
 			// attributes are a special case where Uri cannot be used and has it's own
 			// rule to cover this: Gendarme.Rules.Correctness.AttributeStringLiteralShouldParseCorrectlyRule
-			if (method.IsConstructor && method.DeclaringType.Inherits ("System.Attribute"))
+			if (method.IsConstructor && method.DeclaringType.Inherits ("System", "Attribute"))
 				return;
 
 			var methodParams = method.Parameters;
diff --git a/gendarme/rules/Gendarme.Rules.Design/PreferXmlAbstractionsRule.cs b/gendarme/rules/Gendarme.Rules.Design/PreferXmlAbstractionsRule.cs
index 32bc46f..6ce3fdc 100644
--- a/gendarme/rules/Gendarme.Rules.Design/PreferXmlAbstractionsRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Design/PreferXmlAbstractionsRule.cs
@@ -94,10 +94,6 @@ namespace Gendarme.Rules.Design {
 	[FxCopCompatibility ("Microsoft.Design", "CA1059:MembersShouldNotExposeCertainConcreteTypes")]
 	public class PreferXmlAbstractionsRule : Rule, IMethodRule {
 
-		const string XmlDocumentClass = "System.Xml.XmlDocument";
-		const string XPathDocumentClass = "System.Xml.XPath.XPathDocument";
-		const string XmlNodeClass = "System.Xml.XmlNode";
-
 		public override void Initialize (IRunner runner)
 		{
 			base.Initialize (runner);
@@ -119,7 +115,7 @@ namespace Gendarme.Rules.Design {
 				return RuleResult.DoesNotApply;
 
 			MethodReturnType mrt = method.MethodReturnType;
-			if (IsSpecificXmlType (mrt.ReturnType.FullName))
+			if (IsSpecificXmlType (mrt.ReturnType))
 				Runner.Report (mrt, GetSeverity (method), Confidence.High);
 
 			if (method.HasParameters) {
@@ -127,7 +123,7 @@ namespace Gendarme.Rules.Design {
 					if (parameter.IsOut)
 						continue; //out params already have their rule
 
-					if (IsSpecificXmlType (parameter.ParameterType.FullName))
+					if (IsSpecificXmlType (parameter.ParameterType))
 						Runner.Report (parameter, GetSeverity (method), Confidence.High);
 				}
 			}
@@ -135,9 +131,13 @@ namespace Gendarme.Rules.Design {
 			return Runner.CurrentRuleResult;
 		}
 
-		static bool IsSpecificXmlType (string name)
+		static bool IsSpecificXmlType (TypeReference type)
 		{
-			return name == XmlDocumentClass || name == XPathDocumentClass || name == XmlNodeClass;
+			if (type.Namespace == "System.Xml") {
+				string name = type.Name;
+				return ((name == "XmlDocument") || (name == "XmlNode"));
+			}
+			return type.IsNamed ("System.Xml.XPath", "XPathDocument");
 		}
 
 		static Severity GetSeverity (MethodDefinition method)
diff --git a/gendarme/rules/Gendarme.Rules.Design/ProvideAlternativeNamesForOperatorOverloadsRule.cs b/gendarme/rules/Gendarme.Rules.Design/ProvideAlternativeNamesForOperatorOverloadsRule.cs
index 1e1347e..e2197c5 100644
--- a/gendarme/rules/Gendarme.Rules.Design/ProvideAlternativeNamesForOperatorOverloadsRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Design/ProvideAlternativeNamesForOperatorOverloadsRule.cs
@@ -28,6 +28,7 @@
 
 using System;
 using System.Collections.Generic;
+using System.Globalization;
 using Mono.Cecil;
 
 using Gendarme.Framework;
@@ -171,7 +172,8 @@ namespace Gendarme.Rules.Design {
 				}
 
 				if (!alternativeDefined) {
-					string s = String.Format ("This type implements the '{0}' operator. Some languages do not support overloaded operators so an alternative '{1}' method should be provided.",
+					string s = String.Format (CultureInfo.InvariantCulture,
+						"This type implements the '{0}' operator. Some languages do not support overloaded operators so an alternative '{1}' method should be provided.",
 						kv.Key.Name, kv.Value.Name);
 					Runner.Report (op, Severity.Medium, Confidence.High, s);
 				}
diff --git a/gendarme/rules/Gendarme.Rules.Design/README.md b/gendarme/rules/Gendarme.Rules.Design/README.md
new file mode 100644
index 0000000..22a4957
--- /dev/null
+++ b/gendarme/rules/Gendarme.Rules.Design/README.md
@@ -0,0 +1,9 @@
+# Gendarme.Rules.Design Rules
+
+You can access the latest rules documentation from our [[wiki|https://github.com/spouliot/gendarme/wiki/Gendarme.Rules.Design(git)]] pages.
+
+
+## Feedback
+
+Please report any documentation errors, typos or suggestions to the [[Gendarme Mailing List|https://groups.google.com/forum/?fromgroups#!forum/gendarme]]. Thanks!
+
diff --git a/gendarme/rules/Gendarme.Rules.Design/StronglyTypeICollectionMembersRule.cs b/gendarme/rules/Gendarme.Rules.Design/StronglyTypeICollectionMembersRule.cs
index 637e9e8..75605a1 100644
--- a/gendarme/rules/Gendarme.Rules.Design/StronglyTypeICollectionMembersRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Design/StronglyTypeICollectionMembersRule.cs
@@ -72,24 +72,30 @@ namespace Gendarme.Rules.Design {
 	[Problem ("Types that implement ICollection interface should have strongly typed version of ICollection.CopyTo method")]
 	[Solution ("Explicitly implement ICollection.CopyTo and add strongly typed alternative to it")]
 	[FxCopCompatibility ("Microsoft.Design", "CA1035:ICollectionImplementationsHaveStronglyTypedMembers")]
-	public class StronglyTypeICollectionMembersRule : StronglyTypedRule, ITypeRule
-	{
+	public class StronglyTypeICollectionMembersRule : StronglyTypedRule, ITypeRule {
 
-		private static MethodSignature CopyTo = new MethodSignature("CopyTo", "System.Void",
-		                                                            new string[] {"System.Array", "System.Int32"});
+		private static string [] Empty = new string [] { };
+
+		private static MethodSignature [] CopyTo = new MethodSignature [] {
+			new MethodSignature ("CopyTo", "System.Void", new string [] { "System.Array", "System.Int32" })
+		};
 
 		protected override MethodSignature [] GetMethods ()
 		{
-			return new MethodSignature [] { CopyTo };
+			return CopyTo;
 		}
 
 		protected override string [] GetProperties ()
 		{
-			return new string [] { };
+			return Empty;
 		}
 
 		protected override string InterfaceName {
-			get { return "System.Collections.ICollection"; }
+			get { return "ICollection"; }
+		}
+
+		protected override string InterfaceNamespace {
+			get { return "System.Collections"; }
 		}
 	}
 }
diff --git a/gendarme/rules/Gendarme.Rules.Design/StronglyTypedRule.cs b/gendarme/rules/Gendarme.Rules.Design/StronglyTypedRule.cs
index f38fecc..b60feae 100644
--- a/gendarme/rules/Gendarme.Rules.Design/StronglyTypedRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Design/StronglyTypedRule.cs
@@ -42,12 +42,7 @@ namespace Gendarme.Rules.Design {
 		abstract protected MethodSignature [] GetMethods ();
 		abstract protected string [] GetProperties ();
 		abstract protected string InterfaceName { get; }
-
-		HashSet<string> weakTypes = new HashSet<string> {
-			"System.Object",
-			"System.Array",
-			"System.Object[]",
-		};
+		abstract protected string InterfaceNamespace { get; }
 
 		MethodSignature [] signatures;
 		string [] propertyNames;
@@ -55,7 +50,7 @@ namespace Gendarme.Rules.Design {
 
 		virtual public RuleResult CheckType (TypeDefinition type)
 		{
-			if (type.IsAbstract || type.IsGeneratedCode () || !type.Implements (InterfaceName))
+			if (type.IsAbstract || type.IsGeneratedCode () || !type.Implements (InterfaceNamespace, InterfaceName))
 				return RuleResult.DoesNotApply;
 
 			signatures = GetMethods ();
@@ -106,13 +101,26 @@ namespace Gendarme.Rules.Design {
 				ProcessProperties (baseType);
 		}
 
+		static bool IsWeak (TypeReference type)
+		{
+			if (type.Namespace != "System")
+				return false;
+			string name = type.Name;
+			return ((name == "Object") || (name == "Array") || (name == "Object[]"));
+		}
+
+		static bool IsWeak (string typeName)
+		{
+			return ((typeName == "System.Object") || (typeName == "System.Array") || (typeName == "System.Object[]"));
+		}
+
 		private void ProcessProperties (TypeDefinition baseType)
 		{
 			foreach (PropertyDefinition property in baseType.Properties) {
 				for (int i = 0; i < propertyNames.Length; i++) {
 					if (propertyNames [i] == null || propertyNames [i] != property.Name)
 						continue;
-					if (!weakTypes.Contains (property.PropertyType.FullName)) {
+					if (!IsWeak (property.PropertyType)) {
 						propertiesLeft--;
 						propertyNames [i] = null;
 					}
@@ -133,9 +141,9 @@ namespace Gendarme.Rules.Design {
 
 					bool foundStrong = true;
 					for (int j = 0; j < methodParameters.Count; j++) {
-						if (!weakTypes.Contains (signatures [i].Parameters [j]))
+						if (!IsWeak (signatures [i].Parameters [j]))
 							continue;
-						if (weakTypes.Contains (methodParameters [j].ParameterType.FullName))
+						if (IsWeak (methodParameters [j].ParameterType))
 							foundStrong = false;
 					}
 
diff --git a/gendarme/rules/Gendarme.Rules.Design/Test/AttributeArgumentsShouldHaveAccessorsTest.cs b/gendarme/rules/Gendarme.Rules.Design/Test/AttributeArgumentsShouldHaveAccessorsTest.cs
index 0640805..02c92a0 100644
--- a/gendarme/rules/Gendarme.Rules.Design/Test/AttributeArgumentsShouldHaveAccessorsTest.cs
+++ b/gendarme/rules/Gendarme.Rules.Design/Test/AttributeArgumentsShouldHaveAccessorsTest.cs
@@ -196,6 +196,35 @@ namespace Test.Rules.Design {
 		}
 	}
 
+	internal abstract class FooAttribute : Attribute
+	{
+		protected FooAttribute (string foo)
+		{
+			this.Foo = foo;
+		}
+
+		public string Foo
+		{
+			get;
+			private set;
+		}
+	}
+
+	internal class FooBarAttribute : FooAttribute
+	{
+		protected FooBarAttribute (string foo, string bar) : base (foo)
+		{
+			this.Bar = bar;
+		}
+
+		public string Bar
+		{
+			get;
+			private set;
+		}
+	}
+
+
 	[TestFixture]
 	public class AttributeArgumentsShouldHaveAccessorsTest : TypeRuleTestFixture<AttributeArgumentsShouldHaveAccessorsRule> {
 
@@ -252,5 +281,11 @@ namespace Test.Rules.Design {
 		{
 			AssertRuleFailure<TwoAccessorsMissingAttribute> (2);
 		}
+
+		[Test]
+		public void TestInheritedPropertiesAttribute ()
+		{
+			AssertRuleSuccess<FooBarAttribute> ();
+		}
 	}
 }
diff --git a/gendarme/rules/Gendarme.Rules.Design/Test/ConsiderUsingStaticTypeTest.cs b/gendarme/rules/Gendarme.Rules.Design/Test/ConsiderUsingStaticTypeTest.cs
index 9e9c707..8e55722 100644
--- a/gendarme/rules/Gendarme.Rules.Design/Test/ConsiderUsingStaticTypeTest.cs
+++ b/gendarme/rules/Gendarme.Rules.Design/Test/ConsiderUsingStaticTypeTest.cs
@@ -4,7 +4,7 @@
 // Authors:
 //	Sebastien Pouliot <sebastien@ximian.com>
 //
-// Copyright (C) 2008 Novell, Inc (http://www.novell.com)
+// Copyright (C) 2008, 2011 Novell, Inc (http://www.novell.com)
 //
 // Permission is hereby granted, free of charge, to any person obtaining
 // a copy of this software and associated documentation files (the
@@ -84,9 +84,9 @@ namespace Test.Rules.Design {
 		}
 
 		[Test]
-		public void SkipOnEmptyClassTest ()
+		public void EmptyClassHasDefaultPublicInstanceCtor ()
 		{
-			AssertRuleDoesNotApply<EmptyClass> ();
+			AssertRuleFailure<EmptyClass> ();
 		}
 
 		//You cannot do this class static
diff --git a/gendarme/rules/Gendarme.Rules.Design/Test/DoNotDeclareSettersOnCollectionPropertiesTest.cs b/gendarme/rules/Gendarme.Rules.Design/Test/DoNotDeclareSettersOnCollectionPropertiesTest.cs
new file mode 100644
index 0000000..4e22ddd
--- /dev/null
+++ b/gendarme/rules/Gendarme.Rules.Design/Test/DoNotDeclareSettersOnCollectionPropertiesTest.cs
@@ -0,0 +1,137 @@
+// 
+// Unit tests for DoNotDeclareSettersOnCollectionPropertiesRule
+//
+// Authors:
+//	Sebastien Pouliot <sebastien@ximian.com>
+//
+// Copyright (C) 2011 Novell, Inc (http://www.novell.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Security;
+
+using Gendarme.Rules.Design;
+
+using NUnit.Framework;
+using Test.Rules.Fixtures;
+using Test.Rules.Definitions;
+
+namespace Test.Rules.Design {
+
+	[TestFixture]
+	public class DoNotDeclareSettersOnCollectionPropertiesTest : TypeRuleTestFixture<DoNotDeclareSettersOnCollectionPropertiesRule> {
+
+		[Test]
+		public void DoesNotApply ()
+		{
+			AssertRuleDoesNotApply (SimpleTypes.Class);
+			AssertRuleDoesNotApply (SimpleTypes.Delegate);
+			AssertRuleDoesNotApply (SimpleTypes.Enum);
+			AssertRuleDoesNotApply (SimpleTypes.GeneratedType);
+			AssertRuleDoesNotApply (SimpleTypes.Interface);
+			AssertRuleDoesNotApply (SimpleTypes.Structure);
+		}
+
+		public interface IGoodInterface {
+			ICollection Collection { get; }
+			ICollection<string> GenericCollection { get; }
+		}
+
+		public class TypeImplementingGoodInterface : IGoodInterface {
+			public ICollection Collection { get; private set; }
+			public ICollection<string> GenericCollection { get; private set; }
+		}
+
+		public struct GoodStruct {
+			private ArrayList list;
+
+			public IDictionary Dictionary { get; private set; }
+			public ArrayList List { 
+				get { return list; }
+			}
+		}
+
+		[Test]
+		public void Good ()
+		{
+			AssertRuleSuccess<IGoodInterface> ();
+			AssertRuleSuccess<TypeImplementingGoodInterface> ();
+			AssertRuleSuccess<GoodStruct> ();
+		}
+
+		// interface members are not "declared" as public - but they force a type to do so!
+		public interface IBadInterface {
+			ICollection Collection { get; set; }
+			ICollection<string> GenericCollection { get; set; }
+		}
+
+		public class TypeImplementingBadInterface : IBadInterface {
+			public ICollection Collection { get; set; }
+			public ICollection<string> GenericCollection { get; set; }
+		}
+
+		public struct BadStruct {
+			public IDictionary Dictionary { private get; set; }
+			public ArrayList List { get; set; }
+		}
+
+		[Test]
+		public void Bad ()
+		{
+			AssertRuleFailure<IBadInterface> (2);
+			AssertRuleFailure<TypeImplementingBadInterface> (2);
+			AssertRuleFailure<BadStruct> (2);
+		}
+
+		public class SecurityPermissions {
+			public PermissionSet Permissions { get; set; }
+			public NamedPermissionSet NamedPermissions { get; set; }
+		}
+
+		public class Indexers {
+			int [] array;
+
+			public int this [int index] {
+				get { return array [index]; }
+				set { array [index] = value; }
+			}
+
+			public int this [int x, int y] {
+				get { return array [x]; }
+				set { array [y] = value; }
+			}
+		}
+
+		public class Arrays {
+
+			public Array Array { get; set; }
+		}
+
+		[Test]
+		public void SpecialCases ()
+		{
+			AssertRuleSuccess<SecurityPermissions> ();
+			AssertRuleSuccess<Indexers> ();
+			AssertRuleFailure<Arrays> (1);
+		}
+	}
+}
diff --git a/gendarme/rules/Gendarme.Rules.Design/Test/DoNotDeclareVirtualMethodsInSealedTypeTest.cs b/gendarme/rules/Gendarme.Rules.Design/Test/DoNotDeclareVirtualMethodsInSealedTypeTest.cs
index f495193..c5ae0ef 100644
--- a/gendarme/rules/Gendarme.Rules.Design/Test/DoNotDeclareVirtualMethodsInSealedTypeTest.cs
+++ b/gendarme/rules/Gendarme.Rules.Design/Test/DoNotDeclareVirtualMethodsInSealedTypeTest.cs
@@ -4,7 +4,7 @@
 // Authors:
 //	Sebastien Pouliot  <sebastien@ximian.com>
 //
-// Copyright (C) 2008 Novell, Inc (http://www.novell.com)
+// Copyright (C) 2008,2011 Novell, Inc (http://www.novell.com)
 //
 // Permission is hereby granted, free of charge, to any person obtaining a copy
 // of this software and associated documentation files (the "Software"), to deal
@@ -25,6 +25,7 @@
 // THE SOFTWARE.
 
 using System;
+using System.Collections.Generic;
 
 using Mono.Cecil;
 using Gendarme.Rules.Design;
@@ -103,7 +104,7 @@ namespace Test.Rules.Design {
 		}
 
 		public abstract class AbstractClass {
-			public abstract string GetIt ();
+			public abstract string GetZit ();
 		}
 
 		public sealed class SealedClass : AbstractClass {
@@ -113,7 +114,7 @@ namespace Test.Rules.Design {
 				return 42;
 			}
 
-			public override string GetIt ()
+			public override string GetZit ()
 			{
 				return String.Empty;
 			}
@@ -130,5 +131,34 @@ namespace Test.Rules.Design {
 			AssertRuleDoesNotApply<AbstractClass> ();
 			AssertRuleSuccess<SealedClass> ();
 		}
+
+		// extracted from mono/mcs/class/corlib/System.Collections.Generic/EqualityComparer.cs
+		// they override 'T', not string, base methods
+		sealed class InternalStringComparer : EqualityComparer<string> {
+
+			public override int GetHashCode (string obj)
+			{
+				if (obj == null)
+					return 0;
+				return obj.GetHashCode ();
+			}
+
+			public override bool Equals (string x, string y)
+			{
+				if (x == null)
+					return y == null;
+
+				if ((object) x == (object) y)
+					return true;
+
+				return x.Equals (y);
+			}
+		}
+
+		[Test]
+		public void Generic ()
+		{
+			AssertRuleSuccess<InternalStringComparer> ();
+		}
 	}
 }
diff --git a/gendarme/rules/Gendarme.Rules.Design/Test/PreferUriOverStringTest.cs b/gendarme/rules/Gendarme.Rules.Design/Test/PreferUriOverStringTest.cs
index ed460fd..ff975fd 100644
--- a/gendarme/rules/Gendarme.Rules.Design/Test/PreferUriOverStringTest.cs
+++ b/gendarme/rules/Gendarme.Rules.Design/Test/PreferUriOverStringTest.cs
@@ -52,6 +52,11 @@ namespace Test.Rules.Design {
 			get;
 			set;
 		}
+		public string CUR
+		{
+			get; 
+			set;
+		}
 
 		public Uri GetUri ()
 		{
@@ -117,6 +122,7 @@ namespace Test.Rules.Design {
 		{
 			AssertRuleSuccess (SimpleMethods.EmptyMethod);
 			AssertRuleSuccess<GoodUris> ("GetUri");
+			AssertRuleSuccess<GoodUris>("get_CUR");
 			AssertRuleSuccess<GoodUris> ("GetNewLink");
 			AssertRuleSuccess<GoodUris> ("OverloadedMethod", new Type [] { typeof (string) });
 		}
diff --git a/gendarme/rules/Gendarme.Rules.Design/Test/Tests.Rules.Design.csproj b/gendarme/rules/Gendarme.Rules.Design/Test/Tests.Rules.Design.csproj
index cf19ae8..c59cc09 100755
--- a/gendarme/rules/Gendarme.Rules.Design/Test/Tests.Rules.Design.csproj
+++ b/gendarme/rules/Gendarme.Rules.Design/Test/Tests.Rules.Design.csproj
@@ -1,5 +1,5 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
     <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
@@ -10,8 +10,28 @@
     <AppDesignerFolder>Properties</AppDesignerFolder>
     <RootNamespace>Test</RootNamespace>
     <AssemblyName>Tests.Rules.Design</AssemblyName>
-    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
     <FileAlignment>512</FileAlignment>
+    <FileUpgradeFlags>
+    </FileUpgradeFlags>
+    <OldToolsVersion>3.5</OldToolsVersion>
+    <UpgradeBackupLocation />
+    <PublishUrl>publish\</PublishUrl>
+    <Install>true</Install>
+    <InstallFrom>Disk</InstallFrom>
+    <UpdateEnabled>false</UpdateEnabled>
+    <UpdateMode>Foreground</UpdateMode>
+    <UpdateInterval>7</UpdateInterval>
+    <UpdateIntervalUnits>Days</UpdateIntervalUnits>
+    <UpdatePeriodically>false</UpdatePeriodically>
+    <UpdateRequired>false</UpdateRequired>
+    <MapFileExtensions>true</MapFileExtensions>
+    <ApplicationRevision>0</ApplicationRevision>
+    <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
+    <IsWebBootstrapper>false</IsWebBootstrapper>
+    <UseApplicationTrust>false</UseApplicationTrust>
+    <BootstrapperEnabled>true</BootstrapperEnabled>
+    <TargetFrameworkProfile />
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
     <DebugSymbols>true</DebugSymbols>
@@ -21,6 +41,8 @@
     <DefineConstants>TRACE;DEBUG;CODE_ANALYSIS</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
+    <AllowUnsafeBlocks>false</AllowUnsafeBlocks>
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
     <DebugType>pdbonly</DebugType>
@@ -29,6 +51,7 @@
     <DefineConstants>TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <ItemGroup>
     <Reference Include="nunit.framework, Version=2.4.8.0, Culture=neutral, PublicKeyToken=96d09a1eb7f44a77, processorArchitecture=MSIL">
@@ -85,8 +108,6 @@
     <Compile Include="ProvideAlternativeNamesForOperatorOverloadsTest.cs" />
     <Compile Include="ProvideTryParseAlternativeTest.cs" />
     <Compile Include="TypesShouldBeInsideNamespacesTest.cs" />
-    <Compile Include="TypesWithDisposableFieldsShouldBeDisposableTest.cs" />
-    <Compile Include="TypesWithNativeFieldsShouldBeDisposableTest.cs" />
     <Compile Include="UseCorrectDisposeSignaturesTest.cs" />
     <Compile Include="UseFlagsAttributeTest.cs" />
     <Compile Include="UsingCloneWithoutImplementingICloneableTest.cs" />
@@ -112,6 +133,23 @@
   <ItemGroup>
     <Folder Include="Properties\" />
   </ItemGroup>
+  <ItemGroup>
+    <BootstrapperPackage Include="Microsoft.Net.Client.3.5">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1 Client Profile</ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Windows.Installer.3.1">
+      <Visible>False</Visible>
+      <ProductName>Windows Installer 3.1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+  </ItemGroup>
   <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
   <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
        Other similar extension points exist, see Microsoft.Common.targets.
diff --git a/gendarme/rules/Gendarme.Rules.Design/Test/TypesWithDisposableFieldsShouldBeDisposableTest.cs b/gendarme/rules/Gendarme.Rules.Design/Test/TypesWithDisposableFieldsShouldBeDisposableTest.cs
deleted file mode 100644
index 811ba7e..0000000
--- a/gendarme/rules/Gendarme.Rules.Design/Test/TypesWithDisposableFieldsShouldBeDisposableTest.cs
+++ /dev/null
@@ -1,170 +0,0 @@
-//
-// Unit tests for TypesWithDisposableFieldsShouldBeDisposableRule
-//
-// Authors:
-//	Andreas Noever <andreas.noever@gmail.com>
-//	Sebastien Pouliot  <sebastien@ximian.com>
-//
-//  (C) 2008 Andreas Noever
-// Copyright (C) 2008 Novell, Inc (http://www.novell.com)
-//
-// Permission is hereby granted, free of charge, to any person obtaining
-// a copy of this software and associated documentation files (the
-// "Software"), to deal in the Software without restriction, including
-// without limitation the rights to use, copy, modify, merge, publish,
-// distribute, sublicense, and/or sell copies of the Software, and to
-// permit persons to whom the Software is furnished to do so, subject to
-// the following conditions:
-// 
-// The above copyright notice and this permission notice shall be
-// included in all copies or substantial portions of the Software.
-// 
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
-// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
-// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
-// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-//
-
-using System;
-
-using Gendarme.Rules.Design;
-
-using NUnit.Framework;
-using Test.Rules.Definitions;
-using Test.Rules.Fixtures;
-
-namespace Test.Rules.Design {
-
-	class Disposable : IDisposable {
-		public void Dispose ()
-		{
-			throw new NotImplementedException ();
-		}
-	}
-
-	class NoDisposeableFields {
-		int A;
-		object b;
-	}
-
-	class DisposeableFieldsImplementsIDisposeable : IDisposable {
-		object A;
-		Disposable B;
-
-		public void Dispose ()
-		{
-			throw new NotImplementedException ();
-		}
-	}
-
-	class DisposeableFieldsExplicit : IDisposable {
-		object A;
-		Disposable B;
-
-		void IDisposable.Dispose ()
-		{
-			throw new NotImplementedException ();
-		}
-	}
-
-	abstract class DisposeableFieldsImplementsIDisposeableAbstract : IDisposable {
-		object A;
-		Disposable B;
-		public void Dispose (object asd) { B.Dispose (); }
-		public abstract void Dispose ();
-	}
-
-	class DisposeableFields : ICloneable {
-		object A;
-		Disposable B;
-
-		public object Clone ()
-		{
-			throw new NotImplementedException ();
-		}
-	}
-
-	class DisposeableFieldsArray : ICloneable {
-		object A;
-		Disposable [] B;
-
-		public object Clone ()
-		{
-			throw new NotImplementedException ();
-		}
-	}
-
-	struct StructWithDisposeableFields {
-		Disposable a;
-		object b;
-	}
-
-	class DisposeableStaticFieldsArray {
-		object A;
-		static Disposable [] B;
-	}
-
-	[TestFixture]
-	public class TypesWithDisposableFieldsShouldBeDisposableTest : TypeRuleTestFixture<TypesWithDisposableFieldsShouldBeDisposableRule> {
-
-		[Test]
-		public void DoesNotApply ()
-		{
-			AssertRuleDoesNotApply (SimpleTypes.Delegate);
-			AssertRuleDoesNotApply (SimpleTypes.Enum);
-			AssertRuleDoesNotApply (SimpleTypes.Interface);
-			AssertRuleDoesNotApply (SimpleTypes.Structure);
-		}
-
-		[Test]
-		public void TestNoDisposeableFields ()
-		{
-			AssertRuleSuccess<NoDisposeableFields> ();
-		}
-
-		[Test]
-		public void TestDisposeableFieldsImplementsIDisposeable ()
-		{
-			AssertRuleSuccess<DisposeableFieldsImplementsIDisposeable> ();
-		}
-
-		[Test]
-		public void TestDisposeableFieldsExplicit ()
-		{
-			AssertRuleSuccess<DisposeableFieldsExplicit> ();
-		}
-
-		[Test]
-		public void TestDisposeableFieldsImplementsIDisposeableAbstract ()
-		{
-			AssertRuleFailure<DisposeableFieldsImplementsIDisposeableAbstract> (2);
-		}
-
-		[Test]
-		public void TestDisposeableFields ()
-		{
-			AssertRuleFailure<DisposeableFields> (1);
-		}
-
-		[Test]
-		public void TestDisposeableFieldsArray ()
-		{
-			AssertRuleFailure<DisposeableFieldsArray> (1);
-		}
-
-		[Test]
-		public void TestStructWithDisposeableFields ()
-		{
-			AssertRuleDoesNotApply<StructWithDisposeableFields> ();
-		}
-
-		[Test]
-		public void TestDisposeableStaticFieldsArray ()
-		{
-			AssertRuleSuccess<DisposeableStaticFieldsArray> ();
-		}
-	}
-}
diff --git a/gendarme/rules/Gendarme.Rules.Design/Test/TypesWithNativeFieldsShouldBeDisposableTest.cs b/gendarme/rules/Gendarme.Rules.Design/Test/TypesWithNativeFieldsShouldBeDisposableTest.cs
deleted file mode 100644
index 75216df..0000000
--- a/gendarme/rules/Gendarme.Rules.Design/Test/TypesWithNativeFieldsShouldBeDisposableTest.cs
+++ /dev/null
@@ -1,217 +0,0 @@
-//
-// Unit tests for TypesWithNativeFieldsShouldBeDisposableRule
-//
-// Authors:
-//	Andreas Noever <andreas.noever@gmail.com>
-//	Sebastien Pouliot  <sebastien@ximian.com>
-//
-//  (C) 2008 Andreas Noever
-// Copyright (C) 2008 Novell, Inc (http://www.novell.com)
-//
-// Permission is hereby granted, free of charge, to any person obtaining
-// a copy of this software and associated documentation files (the
-// "Software"), to deal in the Software without restriction, including
-// without limitation the rights to use, copy, modify, merge, publish,
-// distribute, sublicense, and/or sell copies of the Software, and to
-// permit persons to whom the Software is furnished to do so, subject to
-// the following conditions:
-// 
-// The above copyright notice and this permission notice shall be
-// included in all copies or substantial portions of the Software.
-// 
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
-// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
-// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
-// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-//
-
-using System;
-using System.Runtime.InteropServices;
-
-using Gendarme.Rules.Design;
-
-using NUnit.Framework;
-using Test.Rules.Definitions;
-using Test.Rules.Fixtures;
-
-namespace Test.Rules.Design {
-
-	class NoNativeFields {
-		int A;
-		object b;
-	}
-
-	class NativeFieldsImplementsIDisposeable : IDisposable {
-		object A;
-		IntPtr B;
-
-		public void Dispose ()
-		{
-			throw new NotImplementedException ();
-		}
-	}
-
-	class NativeFieldsExplicit : IDisposable {
-		object A;
-		IntPtr B;
-
-		void IDisposable.Dispose ()
-		{
-			throw new NotImplementedException ();
-		}
-	}
-
-
-	class NativeFieldsIntPtr : ICloneable {
-		object A;
-		IntPtr B;
-
-		public object Clone ()
-		{
-			throw new NotImplementedException ();
-		}
-	}
-
-	class NativeFieldsUIntPtr : ICloneable {
-		object A;
-		UIntPtr B;
-
-		public object Clone ()
-		{
-			throw new NotImplementedException ();
-		}
-	}
-
-	class NativeFieldsHandleRef : ICloneable {
-		object A;
-		System.Runtime.InteropServices.HandleRef B;
-
-		public object Clone ()
-		{
-			throw new NotImplementedException ();
-		}
-	}
-
-	abstract class AbstractNativeFields : IDisposable {
-		object A;
-		System.Runtime.InteropServices.HandleRef B;
-
-		public abstract void Dispose ();
-	}
-
-	abstract class AbstractNativeFields2 : IDisposable {
-		object A;
-		System.Runtime.InteropServices.HandleRef B;
-
-		public abstract void Dispose ();
-
-
-		void IDisposable.Dispose ()
-		{
-			throw new NotImplementedException ();
-		}
-	}
-
-	class NativeFieldsArray : ICloneable {
-		object A;
-		UIntPtr [] B;
-
-		public object Clone ()
-		{
-			throw new NotImplementedException ();
-		}
-	}
-
-	struct StructWithNativeFields {
-		IntPtr a;
-		UIntPtr b;
-		HandleRef c;
-	}
-
-	class NativeStaticFieldsArray {
-		object A;
-		static UIntPtr [] B;
-	}
-
-	[TestFixture]
-	public class TypesWithNativeFieldsShouldBeDisposableTest : TypeRuleTestFixture<TypesWithNativeFieldsShouldBeDisposableRule> {
-
-		[Test]
-		public void DoesNotApply ()
-		{
-			AssertRuleDoesNotApply (SimpleTypes.Delegate);
-			AssertRuleDoesNotApply (SimpleTypes.Enum);
-			AssertRuleDoesNotApply (SimpleTypes.Interface);
-			AssertRuleDoesNotApply (SimpleTypes.Structure);
-		}
-
-		[Test]
-		public void TestNoNativeFields ()
-		{
-			AssertRuleSuccess<NoNativeFields> ();
-		}
-
-		[Test]
-		public void TestNativeFieldsImplementsIDisposeable ()
-		{
-			AssertRuleSuccess<NativeFieldsImplementsIDisposeable> ();
-		}
-
-		[Test]
-		public void TestNativeFieldsExplicit ()
-		{
-			AssertRuleSuccess<NativeFieldsExplicit> ();
-		}
-
-		[Test]
-		public void TestNativeFieldsIntPtr ()
-		{
-			AssertRuleFailure<NativeFieldsIntPtr> (1);
-		}
-
-		[Test]
-		public void TestNativeFieldsUIntPtr ()
-		{
-			AssertRuleFailure<NativeFieldsUIntPtr> (1);
-		}
-
-		[Test]
-		public void TestNativeFieldsHandleRef ()
-		{
-			AssertRuleFailure<NativeFieldsHandleRef> (1);
-		}
-
-		[Test]
-		public void TestAbstractNativeFields ()
-		{
-			AssertRuleFailure<AbstractNativeFields> (2);
-		}
-
-		[Test]
-		public void TestAbstractNativeFields2 ()
-		{
-			AssertRuleFailure<AbstractNativeFields2> (2);
-		}
-
-		[Test]
-		public void TestNativeFieldsArray ()
-		{
-			AssertRuleFailure<NativeFieldsArray> (1);
-		}
-
-		[Test]
-		public void TestStructWithNativeFields ()
-		{
-			AssertRuleDoesNotApply<StructWithNativeFields> ();
-		}
-		
-		[Test]
-		public void TestNativeStaticFieldsArray ()
-		{
-			AssertRuleSuccess<NativeStaticFieldsArray> ();
-		}
-	}
-}
diff --git a/gendarme/rules/Gendarme.Rules.Design/TypesWithDisposableFieldsShouldBeDisposableRule.cs b/gendarme/rules/Gendarme.Rules.Design/TypesWithDisposableFieldsShouldBeDisposableRule.cs
deleted file mode 100644
index b1d6f85..0000000
--- a/gendarme/rules/Gendarme.Rules.Design/TypesWithDisposableFieldsShouldBeDisposableRule.cs
+++ /dev/null
@@ -1,136 +0,0 @@
-//
-// Gendarme.Rules.Design.TypesWithDisposableFieldsShouldBeDisposableRule
-//
-// Authors:
-//	Andreas Noever <andreas.noever@gmail.com>
-//
-//  (C) 2008 Andreas Noever
-//
-// Permission is hereby granted, free of charge, to any person obtaining
-// a copy of this software and associated documentation files (the
-// "Software"), to deal in the Software without restriction, including
-// without limitation the rights to use, copy, modify, merge, publish,
-// distribute, sublicense, and/or sell copies of the Software, and to
-// permit persons to whom the Software is furnished to do so, subject to
-// the following conditions:
-//
-// The above copyright notice and this permission notice shall be
-// included in all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
-// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
-// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
-// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-//
-
-using System;
-using System.Text;
-using System.Collections.Generic;
-using System.Diagnostics;
-using System.IO;
-
-using Mono.Cecil;
-using Mono.Cecil.Cil;
-using Gendarme.Framework;
-using Gendarme.Framework.Helpers;
-using Gendarme.Framework.Rocks;
-
-namespace Gendarme.Rules.Design {
-
-	/// <summary>
-	/// This rule will fire if a type contains disposable fields but does not implement
-	/// <c>System.IDisposable</c>.
-	/// </summary>
-	/// <example>
-	/// Bad examples:
-	/// <code>
-	/// class DoesNotImplementIDisposable {
-	///	IDisposable field;
-	/// }
-	/// 
-	/// class AbstractDispose : IDisposable {
-	///	IDisposable field;
-	///	
-	///	// the field should be disposed in the type that declares it
-	///	public abstract void Dispose ();
-	/// }
-	/// </code>
-	/// </example>
-	/// <example>
-	/// Good example:
-	/// <code>
-	/// class Dispose : IDisposable {
-	///	IDisposable field;
-	///	
-	///	public void Dispose ()
-	///	{
-	///		field.Dispose ();
-	///	}
-	/// }
-	/// </code>
-	/// </example>
-
-	[Problem ("This type contains disposable field(s) but doesn't implement IDisposable.")]
-	[Solution ("Implement IDisposable and free the disposable field(s) in the Dispose method.")]
-	[FxCopCompatibility ("Microsoft.Design", "CA1001:TypesThatOwnDisposableFieldsShouldBeDisposable")]
-	public class TypesWithDisposableFieldsShouldBeDisposableRule : Rule, ITypeRule {
-
-		private const string AbstractTypeMessage = "Field implement IDisposable. Type should implement a non-abstract Dispose() method";
-		private const string TypeMessage = "Field implement IDisposable. Type should implement a Dispose() method";
-		private const string AbstractDisposeMessage = "Some field(s) implement IDisposable. Making this method abstract shifts the reponsability of disposing those fields to the inheritors of this class.";
-
-		static bool IsAbstract (MethodDefinition method)
-		{
-			return ((method != null) && (method.IsAbstract));
-		}
-
-		public RuleResult CheckType (TypeDefinition type)
-		{
-			// rule doesn't apply to enums, interfaces, structs, delegates or generated code
-			if (type.IsEnum || type.IsInterface || type.IsValueType || type.IsDelegate () || type.IsGeneratedCode ())
-				return RuleResult.DoesNotApply;
-
-			MethodDefinition explicitDisposeMethod = null;
-			MethodDefinition implicitDisposeMethod = null;
-
-			bool abstractWarning = false;
-
-			if (type.Implements ("System.IDisposable")) {
-				implicitDisposeMethod = type.GetMethod (MethodSignatures.Dispose);
-				explicitDisposeMethod = type.GetMethod (MethodSignatures.DisposeExplicit);
-
-				if (IsAbstract (implicitDisposeMethod) || IsAbstract (explicitDisposeMethod)) {
-					abstractWarning = true;
-				} else {
-					return RuleResult.Success;
-				}
-			}
-
-			foreach (FieldDefinition field in type.Fields) {
-				// we can't dispose static fields in IDisposable
-				if (field.IsStatic)
-					continue;
-				TypeDefinition fieldType = field.FieldType.GetElementType ().Resolve ();
-				if (fieldType == null)
-					continue;
-				// enums and primitives don't implement IDisposable
-				if (fieldType.IsEnum || fieldType.IsPrimitive)
-					continue;
-				if (fieldType.Implements ("System.IDisposable")) {
-					Runner.Report (field, Severity.High, Confidence.High,
-						abstractWarning ? AbstractTypeMessage : TypeMessage);
-				}
-			}
-
-			// Warn about possible confusion if the Dispose methods are abstract
-			if (IsAbstract (implicitDisposeMethod))
-				Runner.Report (implicitDisposeMethod, Severity.Medium, Confidence.High, AbstractDisposeMessage);
-
-			return Runner.CurrentRuleResult;
-		}
-	}
-}
-
diff --git a/gendarme/rules/Gendarme.Rules.Design/TypesWithNativeFieldsShouldBeDisposableRule.cs b/gendarme/rules/Gendarme.Rules.Design/TypesWithNativeFieldsShouldBeDisposableRule.cs
deleted file mode 100644
index 113a5dd..0000000
--- a/gendarme/rules/Gendarme.Rules.Design/TypesWithNativeFieldsShouldBeDisposableRule.cs
+++ /dev/null
@@ -1,123 +0,0 @@
-//
-// Gendarme.Rules.Design.TypesWithNativeFieldsShouldBeDisposableRule
-//
-// Authors:
-//	Andreas Noever <andreas.noever@gmail.com>
-//
-//  (C) 2008 Andreas Noever
-//
-// Permission is hereby granted, free of charge, to any person obtaining
-// a copy of this software and associated documentation files (the
-// "Software"), to deal in the Software without restriction, including
-// without limitation the rights to use, copy, modify, merge, publish,
-// distribute, sublicense, and/or sell copies of the Software, and to
-// permit persons to whom the Software is furnished to do so, subject to
-// the following conditions:
-//
-// The above copyright notice and this permission notice shall be
-// included in all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
-// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
-// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
-// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-//
-
-using System;
-using Mono.Cecil;
-using Gendarme.Framework;
-using Gendarme.Framework.Helpers;
-using Gendarme.Framework.Rocks;
-
-namespace Gendarme.Rules.Design {
-
-	/// <summary>
-	/// This rule will fire if a type contains <c>IntPtr</c>, <c>UIntPtr</c>, or 
-	/// <c>HandleRef</c> fields but does not implement <c>System.IDisposable</c>.
-	/// </summary>
-	/// <example>
-	/// Bad examples:
-	/// <code>
-	/// public class DoesNotImplementIDisposable {
-	///	IntPtr field;
-	/// }
-	/// 
-	/// abstract public class AbstractDispose : IDisposable {
-	///	IntPtr field;
-	///	
-	///	// the field should be disposed in the type that declares it
-	///	public abstract void Dispose ();
-	/// }
-	/// </code>
-	/// </example>
-	/// <example>
-	/// Good example:
-	/// <code>
-	/// public class Dispose : IDisposable {
-	///	IDisposable field;
-	///	
-	///	public void Dispose ()
-	///	{
-	///		UnmanagedFree (field);
-	///	}
-	/// }
-	/// </code>
-	/// </example>
-
-	[Problem ("This type contains native field(s) but doesn't implement IDisposable.")]
-	[Solution ("Implement IDisposable and free the native field(s) in the Dispose method.")]
-	[FxCopCompatibility ("Microsoft.Design", "CA1049:TypesThatOwnNativeResourcesShouldBeDisposable")]
-	public class TypesWithNativeFieldsShouldBeDisposableRule : Rule, ITypeRule {
-
-		private const string AbstractTypeMessage = "Field is native. Type should implement a non-abstract Dispose() method";
-		private const string TypeMessage = "Field is native. Type should implement a Dispose() method";
-		private const string AbstractDisposeMessage = "Some fields are native pointers. Making this method abstract shifts the reponsability of disposing those fields to the inheritors of this class.";
-
-		static bool IsAbstract (MethodDefinition method)
-		{
-			return ((method != null) && (method.IsAbstract));
-		}
-
-		public RuleResult CheckType (TypeDefinition type)
-		{
-			// rule doesn't apply to enums, interfaces, structs, delegates or generated code
-			if (type.IsEnum || type.IsInterface || type.IsValueType || type.IsDelegate () || type.IsGeneratedCode ())
-				return RuleResult.DoesNotApply;
-
-			MethodDefinition explicitDisposeMethod = null;
-			MethodDefinition implicitDisposeMethod = null;
-
-			bool abstractWarning = false;
-
-			if (type.Implements ("System.IDisposable")) {
-				implicitDisposeMethod = type.GetMethod (MethodSignatures.Dispose);
-				explicitDisposeMethod = type.GetMethod (MethodSignatures.DisposeExplicit);
-
-				if (IsAbstract (implicitDisposeMethod) || IsAbstract (explicitDisposeMethod)) {
-					abstractWarning = true;
-				} else {
-					return RuleResult.Success;
-				}
-			}
-
-			foreach (FieldDefinition field in type.Fields) {
-				// we can't dispose static fields in IDisposable
-				if (field.IsStatic)
-					continue;
-				if (field.FieldType.GetElementType ().IsNative ()) {
-					Runner.Report (field, Severity.High, Confidence.High, 
-						abstractWarning ? AbstractTypeMessage : TypeMessage);
-				}
-			}
-
-			// Warn about possible confusion if the Dispose methods are abstract
-			if (IsAbstract (implicitDisposeMethod))
-				Runner.Report (implicitDisposeMethod, Severity.Medium, Confidence.High, AbstractDisposeMessage);
-
-			return Runner.CurrentRuleResult;
-		}
-	}
-}
diff --git a/gendarme/rules/Gendarme.Rules.Design/UseCorrectDisposeSignaturesRule.cs b/gendarme/rules/Gendarme.Rules.Design/UseCorrectDisposeSignaturesRule.cs
index 6041eb4..697c61b 100644
--- a/gendarme/rules/Gendarme.Rules.Design/UseCorrectDisposeSignaturesRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Design/UseCorrectDisposeSignaturesRule.cs
@@ -141,10 +141,10 @@ namespace Gendarme.Rules.Design {
 			if (type.IsInterface || type.IsEnum || type.IsDelegate ())
 				return RuleResult.DoesNotApply;
 			
-			if (type.Implements ("System.IDisposable")) {
+			if (type.Implements ("System", "IDisposable")) {
 				Log.WriteLine (this);
 				Log.WriteLine (this, "----------------------------------");
-				Log.WriteLine (this, type.FullName);
+				Log.WriteLine (this, type);
 				
 				MethodDefinition dispose0 = null;
 				MethodDefinition dispose1 = null;
@@ -236,7 +236,7 @@ namespace Gendarme.Rules.Design {
 		{
 			if (type.HasInterfaces) {
 				foreach (TypeReference candidate in type.Interfaces) {
-					if (candidate.FullName == "System.IDisposable")
+					if (candidate.IsNamed ("System", "IDisposable"))
 						return true;
 				}
 			}
diff --git a/gendarme/rules/Gendarme.Rules.Design/UseFlagsAttributeRule.cs b/gendarme/rules/Gendarme.Rules.Design/UseFlagsAttributeRule.cs
index 79671d8..c6adf87 100644
--- a/gendarme/rules/Gendarme.Rules.Design/UseFlagsAttributeRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Design/UseFlagsAttributeRule.cs
@@ -27,6 +27,7 @@
 using System;
 using System.Collections.Generic;
 using System.Diagnostics;
+using System.Globalization;
 using System.Linq;
 
 using Mono.Cecil;
@@ -94,7 +95,7 @@ namespace Gendarme.Rules.Design {
 							values.Add (value);
 
 					} else {
-						long v = Convert.ToInt64 (o);
+						long v = Convert.ToInt64 (o, CultureInfo.InvariantCulture);
 
 						if (v > 0) {
 							value = (ulong) v;
@@ -159,7 +160,7 @@ namespace Gendarme.Rules.Design {
 #if DEBUG
 			Log.WriteLine (this);
 			Log.WriteLine (this, "------------------------------------");
-			Log.WriteLine (this, type.FullName);
+			Log.WriteLine (this, type);
 			Log.WriteLine (this, "values: {0}", string.Join (" ", (from x in values select x.ToString ("X4")).ToArray ()));
 #endif
 
diff --git a/gendarme/rules/Gendarme.Rules.Design/UsingCloneWithoutImplementingICloneableRule.cs b/gendarme/rules/Gendarme.Rules.Design/UsingCloneWithoutImplementingICloneableRule.cs
index f33e66f..3184afc 100644
--- a/gendarme/rules/Gendarme.Rules.Design/UsingCloneWithoutImplementingICloneableRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Design/UsingCloneWithoutImplementingICloneableRule.cs
@@ -95,7 +95,7 @@ namespace Gendarme.Rules.Design {
 		public RuleResult CheckType (TypeDefinition type)
 		{
 			// rule applies to type that doesn't implement System.IClonable
-			if (type.Implements ("System.ICloneable"))
+			if (type.Implements ("System", "ICloneable"))
 				return RuleResult.DoesNotApply;
 
 			foreach (MethodDefinition method in type.Methods) {
@@ -110,7 +110,7 @@ namespace Gendarme.Rules.Design {
 
 				// that return System.Object, e.g. public object Clone()
 				// or the current type, e.g. public <type> Clone()
-				if (method.ReturnType.FullName == "System.Object")
+				if (method.ReturnType.IsNamed ("System", "Object"))
 					Runner.Report (method, Severity.Low, Confidence.High);
 			}
 
diff --git a/gendarme/rules/Gendarme.Rules.Exceptions/AvoidArgumentExceptionDefaultConstructorRule.cs b/gendarme/rules/Gendarme.Rules.Exceptions/AvoidArgumentExceptionDefaultConstructorRule.cs
index 6ddab93..44b14df 100644
--- a/gendarme/rules/Gendarme.Rules.Exceptions/AvoidArgumentExceptionDefaultConstructorRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Exceptions/AvoidArgumentExceptionDefaultConstructorRule.cs
@@ -96,21 +96,22 @@ namespace Gendarme.Rules.Exceptions {
 					continue;
 
 				TypeReference type = ctor.DeclaringType;
-				string name = type.FullName;
-				switch (name) {
-				// most common cases
-				case "System.ArgumentException":
-				case "System.ArgumentNullException":
-				case "System.ArgumentOutOfRangeException":
-				case "System.DuplicateWaitObjectException":
-					Runner.Report (method, ins, Severity.Medium, Confidence.Total, name);
-					break;
-				default:
-					if (!name.EndsWith ("Exception", StringComparison.Ordinal))
-						break;
-					if (type.Inherits ("System.ArgumentException"))
-						Runner.Report (method, ins, Severity.Medium, Confidence.Total, name);
-					break;
+				string name = type.Name;
+				if (type.Namespace == "System") {
+					// most common cases
+					switch (name) {
+					case "ArgumentException":
+					case "ArgumentNullException":
+					case "ArgumentOutOfRangeException":
+					case "DuplicateWaitObjectException":
+						Runner.Report (method, ins, Severity.Medium, Confidence.Total, type.GetFullName ());
+						continue;
+					}
+				}
+
+				if (name.EndsWith ("Exception", StringComparison.Ordinal)) {
+					if (type.Inherits ("System", "ArgumentException"))
+						Runner.Report (method, ins, Severity.Medium, Confidence.Total, type.GetFullName ());
 				}
 			}
 			return Runner.CurrentRuleResult;
diff --git a/gendarme/rules/Gendarme.Rules.Exceptions/AvoidThrowingBasicExceptionsRule.cs b/gendarme/rules/Gendarme.Rules.Exceptions/AvoidThrowingBasicExceptionsRule.cs
index a43d01c..0ac510d 100644
--- a/gendarme/rules/Gendarme.Rules.Exceptions/AvoidThrowingBasicExceptionsRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Exceptions/AvoidThrowingBasicExceptionsRule.cs
@@ -26,6 +26,7 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
+using Mono.Cecil;
 using Gendarme.Framework;
 
 namespace Gendarme.Rules.Exceptions {
@@ -67,15 +68,12 @@ namespace Gendarme.Rules.Exceptions {
 	[FxCopCompatibility ("Microsoft.Usage", "CA2201:DoNotRaiseReservedExceptionTypes")]
 	public class AvoidThrowingBasicExceptionsRule : NewExceptionsRule {
 
-		static string [] BasicExceptions = { 
-			"System.Exception", 
-			"System.ApplicationException", 
-			"System.SystemException"
-		};
-
-		protected override string [] GetExceptionTypes ()
+		protected override bool CheckException (TypeReference type)
 		{
-			return BasicExceptions;
+			if ((type == null) || (type.Namespace != "System"))
+				return false;
+			string name = type.Name;
+			return ((name == "Exception") || (name == "ApplicationException") || (name == "SystemException"));
 		}
 
 		protected override Severity Severity {
diff --git a/gendarme/rules/Gendarme.Rules.Exceptions/DoNotDestroyStackTraceRule.cs b/gendarme/rules/Gendarme.Rules.Exceptions/DoNotDestroyStackTraceRule.cs
index b1587d7..661b53f 100644
--- a/gendarme/rules/Gendarme.Rules.Exceptions/DoNotDestroyStackTraceRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Exceptions/DoNotDestroyStackTraceRule.cs
@@ -1,7 +1,7 @@
 //
 // DoNotDestroyStackTraceRule
 //
-// Copyright (C) 2008 Novell, Inc (http://www.novell.com)
+// Copyright (C) 2008, 2011 Novell, Inc (http://www.novell.com)
 //
 // Permission is hereby granted, free of charge, to any person obtaining
 // a copy of this software and associated documentation files (the
@@ -23,7 +23,6 @@
 // WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 //
 
-using System;
 using System.Collections.Generic;
 
 using Mono.Cecil;
@@ -31,6 +30,7 @@ using Mono.Cecil.Cil;
 
 using Gendarme.Framework;
 using Gendarme.Framework.Engines;
+using Gendarme.Framework.Helpers;
 using Gendarme.Framework.Rocks;
 using Gendarme.Rules.Exceptions.Impl;
 
@@ -74,39 +74,116 @@ namespace Gendarme.Rules.Exceptions {
 	[FxCopCompatibility ("Microsoft.Usage", "CA2200:RethrowToPreserveStackDetails")]
 	public class DoNotDestroyStackTraceRule : Rule, IMethodRule {
 
+		// all branches instructions except leave[_s]
+		static OpCodeBitmask branches = new OpCodeBitmask (0xFFFFFC0000000000, 0xF, 0x0, 0x0);
+
 		private List<int> warned_offsets_in_method = new List<int> ();
 
 		public RuleResult CheckMethod (MethodDefinition method)
 		{
 			// rule only applies to methods with IL and exceptions handlers
-			if (!method.HasBody)
-				return RuleResult.DoesNotApply;
-
-			MethodBody body = method.Body;
-			if (!body.HasExceptionHandlers)
+			if (!method.HasBody || !method.Body.HasExceptionHandlers)
 				return RuleResult.DoesNotApply;
 
 			// and when the IL contains a Throw instruction (Rethrow is fine)
-			if (!OpCodeEngine.GetBitmask (method).Get (Code.Throw))
+			OpCodeBitmask mask = OpCodeEngine.GetBitmask (method);
+			if (!mask.Get (Code.Throw))
 				return RuleResult.DoesNotApply;
 
+			// we can use a faster code path when no branches are present in the method
+			if (mask.Intersect (branches)) {
+				Branches (method);
+			} else {
+				Branchless (method);
+			}
+
 			warned_offsets_in_method.Clear ();
+
+			return Runner.CurrentRuleResult;
+		}
+
+		private void Branchless (MethodDefinition method)
+		{
+			// Current stack position: 0 = top of stack
+			int exStackPos = 0;
+			// Local variable position: -1 = not stored in local variable
+			int localVarPos = -1;
+
+			foreach (ExceptionHandler eh in method.Body.ExceptionHandlers) {
+				if (eh.HandlerType != ExceptionHandlerType.Catch)
+					continue;
+
+				ProcessCatchBlock (eh.HandlerStart, eh.HandlerEnd, method, ref exStackPos, ref localVarPos);
+			}
+		}
+
+		private void ProcessCatchBlock (Instruction first, Instruction last, MethodDefinition method, ref int exStackPos, ref int localVarPos)
+		{
+			Instruction cur = null;
+			
+			while (cur != last) {
+				if (cur == null)
+					cur = first;
+				else
+					cur = cur.Next;
+
+				// Rethrown exception - no problem!
+				if (cur.Is (Code.Rethrow))
+					return;
+
+				if (cur.IsStoreLocal ()) {
+					int varIndex = cur.GetVariable (method).Index;
+					if (exStackPos == 0) {
+						// Storing argument on top of stack in local variable reference
+						localVarPos = varIndex;
+						exStackPos = -1;
+					} else if (localVarPos != -1 && varIndex == localVarPos)
+						// Writing over orignal exception...
+						localVarPos = -1;
+				} else if (localVarPos != -1 && cur.IsLoadLocal ()) {
+					int varIndex = cur.GetVariable (method).Index;
+					if (varIndex == localVarPos)
+						// Loading exception from local var back onto stack
+						exStackPos = 0;
+				} else if (cur.Is (Code.Throw) && exStackPos == 0) {
+					// If our original exception is on top of the stack,
+					// we're rethrowing it.This is deemed naughty...
+					if (!warned_offsets_in_method.Contains (cur.Offset)) {
+						Runner.Report (method, cur, Severity.Critical, Confidence.High);
+						warned_offsets_in_method.Add (cur.Offset);
+					}
+					return;
+				} else if (exStackPos != -1) {
+					// If we're still on the stack, track our position after
+					// this instruction
+					int numPops = cur.GetPopCount (method);
+					if (exStackPos < numPops) {
+						// Popped ex off of stack
+						exStackPos = -1;
+					} else {
+						int numPushes = cur.GetPushCount ();
+						exStackPos += numPushes - numPops;
+					}
+				}
+			}
+		}
+
+		private void Branches (MethodDefinition method)
+		{
 			ExecutionPathFactory epf = new ExecutionPathFactory ();
 
-			foreach (ExceptionHandler eh in body.ExceptionHandlers) {
+			foreach (ExceptionHandler eh in method.Body.ExceptionHandlers) {
 				if (eh.HandlerType != ExceptionHandlerType.Catch)
 					continue;
 
 				var list = epf.CreatePaths (eh.HandlerStart, eh.HandlerEnd);
 				if (list.Count == 0) {
 					Runner.Report (method, eh.HandlerStart, Severity.Medium, Confidence.Normal, "Handler too complex for analysis");
-				}  else {
+				} else {
 					foreach (ExecutionPathCollection catchPath in list)
 						ProcessCatchPath (catchPath, method);
 				}
 			}
-
-			return Runner.CurrentRuleResult;
 		}
 
 		private void ProcessCatchPath (IEnumerable<ExecutionBlock> catchPath, MethodDefinition method)
@@ -120,54 +197,41 @@ namespace Gendarme.Rules.Exceptions {
 			int localVarPos = -1;
 
 			foreach (ExecutionBlock block in catchPath) {
-				Instruction cur = null;
-				
-				while (cur != block.Last) {
-					if (cur == null)
-						cur = block.First;
-					else
-						cur = cur.Next;
- 
-					if (cur.OpCode == OpCodes.Rethrow)
-						// Rethrown exception - no problem!
-						return;
-
-					if (cur.IsStoreLocal ()) {
-						int varIndex = cur.GetVariable (method).Index;
-						if (exStackPos == 0) {
-							// Storing argument on top of stack in local variable reference
-							localVarPos = varIndex;
-							exStackPos = -1;
-						} else if (localVarPos != -1 && varIndex == localVarPos)
-							// Writing over orignal exception...
-							localVarPos = -1;
-					} else if (localVarPos != -1 && cur.IsLoadLocal ()) {
-						int varIndex = cur.GetVariable (method).Index;
-						if (varIndex == localVarPos)
-							// Loading exception from local var back onto stack
-							exStackPos = 0;
-					} else if (cur.OpCode == OpCodes.Throw && exStackPos == 0) {
-						// If our original exception is on top of the stack,
-						// we're rethrowing it.This is deemed naughty...
-						if (!warned_offsets_in_method.Contains (cur.Offset)) {
-							Runner.Report (method, cur, Severity.Critical, Confidence.High);
-							warned_offsets_in_method.Add (cur.Offset);
-						}
-						return;
-					} else if (exStackPos != -1) {
-						// If we're still on the stack, track our position after
-						// this instruction
-						int numPops = cur.GetPopCount (method);
-						if (exStackPos < numPops) {
-							// Popped ex off of stack
-							exStackPos = -1;
-						} else {
-							int numPushes = cur.GetPushCount ();
-							exStackPos += numPushes - numPops;
-						}
-					}
-				}
+				ProcessCatchBlock (block.First, block.Last, method, ref exStackPos, ref localVarPos);
 			}
 		}
+#if false
+		public void Bitmask ()
+		{
+			OpCodeBitmask branches = new OpCodeBitmask ();
+			branches.Set (Code.Beq);
+			branches.Set (Code.Beq_S);
+			branches.Set (Code.Bge);
+			branches.Set (Code.Bge_S);
+			branches.Set (Code.Bge_Un);
+			branches.Set (Code.Bge_Un_S);
+			branches.Set (Code.Bgt);
+			branches.Set (Code.Bgt_S);
+			branches.Set (Code.Bgt_Un);
+			branches.Set (Code.Bgt_Un_S);
+			branches.Set (Code.Ble);
+			branches.Set (Code.Ble_S);
+			branches.Set (Code.Ble_Un);
+			branches.Set (Code.Ble_Un_S);
+			branches.Set (Code.Blt);
+			branches.Set (Code.Blt_S);
+			branches.Set (Code.Blt_Un);
+			branches.Set (Code.Blt_Un_S);
+			branches.Set (Code.Bne_Un);
+			branches.Set (Code.Bne_Un_S);
+			branches.Set (Code.Br);
+			branches.Set (Code.Br_S);
+			branches.Set (Code.Brfalse);
+			branches.Set (Code.Brfalse_S);
+			branches.Set (Code.Brtrue);
+			branches.Set (Code.Brtrue_S);
+			Console.WriteLine (branches);
+		}
+#endif
 	}
 }
diff --git a/gendarme/rules/Gendarme.Rules.Exceptions/DoNotThrowInNonCatchClausesRule.cs b/gendarme/rules/Gendarme.Rules.Exceptions/DoNotThrowInNonCatchClausesRule.cs
new file mode 100644
index 0000000..f237349
--- /dev/null
+++ b/gendarme/rules/Gendarme.Rules.Exceptions/DoNotThrowInNonCatchClausesRule.cs
@@ -0,0 +1,113 @@
+//
+// Gendarme.Rules.Exceptions.DoNotThrowInNonCatchClausesRule
+//
+// Authors:
+//	Sebastien Pouliot <sebastien@ximian.com>
+//
+// Copyright (C) 2011 Novell, Inc (http://www.novell.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using Mono.Cecil;
+using Mono.Cecil.Cil;
+
+using Gendarme.Framework;
+using Gendarme.Framework.Engines;
+using Gendarme.Framework.Rocks;
+
+namespace Gendarme.Rules.Exceptions {
+
+	/// <summary>
+	/// This rule detects exceptions that are throw in <c>fault</c>, <c>filter</c> or 
+	/// <c>finally</c> clauses. Such exceptions will make it much harder to debug your 
+	/// applications since it will hide the original exception.
+	/// </summary>
+	/// <example>
+	/// Bad example:
+	/// <code>
+	/// int err = 0;
+	/// try {
+	///	err = Initialize ();
+	/// }
+	/// finally {
+	///	Cleanup ();
+	///	if (err != 0)
+	///		throw new NotSupportedException ();
+	/// }
+	/// </code>
+	/// </example>
+	/// <example>
+	/// Good example:
+	/// <code>
+	/// try {
+	///	if (Initialize () != 0)
+	///		throw new NotSupportedException ();
+	/// }
+	/// finally {
+	///	Cleanup ();
+	/// }
+	/// </code>
+	/// </example>
+	[Problem ("An exception is thrown in a fault, filter or finally clause.")]
+	[Solution ("Remove the exception or move it inside the try or catch clause.")]
+	[FxCopCompatibility ("Microsoft.Usage", "CA2219:DoNotRaiseExceptionsInExceptionClauses")]
+	[EngineDependency (typeof (OpCodeEngine))]
+	public class DoNotThrowInNonCatchClausesRule : Rule, IMethodRule {
+
+		void CheckBlock (MethodDefinition method, Instruction start, Instruction end)
+		{
+			Instruction ins = start;
+			while (ins != end) {
+				if (ins.Is (Code.Throw))
+					Runner.Report (method, ins, Severity.High, Confidence.High);
+				ins = ins.Next;
+			}
+		}
+
+		public RuleResult CheckMethod (MethodDefinition method)
+		{
+			// rule only applies to methods with IL...
+			if (!method.HasBody)
+				return RuleResult.DoesNotApply;
+
+			// ... and exceptions handlers
+			MethodBody body = method.Body;
+			if (!body.HasExceptionHandlers)
+				return RuleResult.DoesNotApply;
+
+			// and when the IL contains a Throw instruction (Rethrow is fine)
+			if (!OpCodeEngine.GetBitmask (method).Get (Code.Throw))
+				return RuleResult.DoesNotApply;
+
+			foreach (ExceptionHandler eh in body.ExceptionHandlers) {
+				// throwing in catch handler is fine
+				if (eh.HandlerType == ExceptionHandlerType.Catch)
+					continue;
+
+				CheckBlock (method, eh.HandlerStart, eh.HandlerEnd);
+				if (eh.FilterStart != null)
+					CheckBlock (method, eh.FilterStart, eh.HandlerStart);
+			}
+
+			return Runner.CurrentRuleResult;
+		}
+	}
+}
diff --git a/gendarme/rules/Gendarme.Rules.Exceptions/DoNotThrowInUnexpectedLocationRule.cs b/gendarme/rules/Gendarme.Rules.Exceptions/DoNotThrowInUnexpectedLocationRule.cs
index 88e4379..cd7ad5b 100644
--- a/gendarme/rules/Gendarme.Rules.Exceptions/DoNotThrowInUnexpectedLocationRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Exceptions/DoNotThrowInUnexpectedLocationRule.cs
@@ -28,6 +28,9 @@
 // WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 //
 
+using System.Globalization;
+using System.Text;
+
 using Mono.Cecil;
 using Mono.Cecil.Cil;
 
@@ -160,10 +163,27 @@ namespace Gendarme.Rules.Exceptions {
 		private static readonly OpCodeBitmask OverflowThrowers = new OpCodeBitmask (0x0, 0x8000000000000000, 0x3FC07F8000001FF, 0x0);
 		private static readonly OpCodeBitmask Casts = new OpCodeBitmask (0x0, 0x48000000000000, 0x400000000, 0x0);
 
-		private static readonly string [] GetterExceptions = new string [] {"System.InvalidOperationException", "System.NotSupportedException"};
-		private static readonly string [] IndexerExceptions = new string [] {"System.InvalidOperationException", "System.NotSupportedException", "System.ArgumentException", "System.Collections.Generic.KeyNotFoundException"};
-		private static readonly string [] EventExceptions = new string [] {"System.InvalidOperationException", "System.NotSupportedException", "System.ArgumentException"};
-		private static readonly string [] HashCodeExceptions = new string [] {"System.ArgumentException"};
+		private static readonly string [][] GetterExceptions = new string [][] {
+			new string [] { "System", "InvalidOperationException" },
+			new string [] { "System", "NotSupportedException"}
+		};
+
+		private static readonly string [][] IndexerExceptions = new string [][] {
+			new string [] { "System", "InvalidOperationException" }, 
+			new string [] { "System", "NotSupportedException" }, 
+			new string [] { "System", "ArgumentException" }, 
+			new string [] { "System.Collections.Generic", "KeyNotFoundException" }
+		};
+
+		private static readonly string [][] EventExceptions = new string [][] {
+			new string [] { "System", "InvalidOperationException" }, 
+			new string [] { "System", "NotSupportedException" }, 
+			new string [] { "System", "ArgumentException" }
+		};
+
+		private static readonly string [][] HashCodeExceptions = new string [][] {
+			new string [] { "System", "ArgumentException" }
+		};
 
 		private static bool CheckAttributes (MethodReference method, MethodAttributes attrs)
 		{
@@ -180,7 +200,7 @@ namespace Gendarme.Rules.Exceptions {
 		
 		private MethodSignature equals_signature;
 		private MethodSignature hashcode_signature;
-		private string [] allowedExceptions;
+		private string [][] allowedExceptions;
 		private Severity severity;
 		private bool is_equals;
 
@@ -189,7 +209,7 @@ namespace Gendarme.Rules.Exceptions {
 			base.Initialize (runner);
 
 			Runner.AnalyzeType += delegate (object sender, RunnerEventArgs e) {
-				if (e.CurrentType.Implements ("System.Collections.Generic.IEqualityComparer`1")) {
+				if (e.CurrentType.Implements ("System.Collections.Generic", "IEqualityComparer`1")) {
 					equals_signature = EqualityComparer_Equals;
 					hashcode_signature = EqualityComparer_GetHashCode;
 				} else {
@@ -220,7 +240,7 @@ namespace Gendarme.Rules.Exceptions {
 				return PreflightVirtualMethod (method);
 			} else if (method.HasParameters && (method.Name == "Dispose")) {
 				IList<ParameterDefinition> pdc = method.Parameters;
-				if ((pdc.Count == 1) && (pdc [0].ParameterType.FullName == "System.Boolean"))
+				if ((pdc.Count == 1) && pdc [0].ParameterType.IsNamed ("System", "Boolean"))
 					return "Dispose (bool)";
 			} else if (MethodSignatures.TryParse.Matches (method)) {
 				return "TryParse";
@@ -269,7 +289,7 @@ namespace Gendarme.Rules.Exceptions {
 			} else if (MethodSignatures.Finalize.Matches (method)) {
 				return "Finalizers";
 			} else if (MethodSignatures.Dispose.Matches (method) || MethodSignatures.DisposeExplicit.Matches (method)) {
-				if (method.DeclaringType.Implements ("System.IDisposable"))
+				if (method.DeclaringType.Implements ("System", "IDisposable"))
 					return "IDisposable.Dispose";
 			} else if (equals_signature != null && equals_signature.Matches (method)) {
 				return "IEqualityComparer<T>.Equals";
@@ -288,14 +308,16 @@ namespace Gendarme.Rules.Exceptions {
 		{
 			switch (ins.OpCode.Code) {
 			case Code.Castclass:
-				return string.Format (" (cast to {0})", ((TypeReference) ins.Operand).Name);
+				return String.Format (CultureInfo.InvariantCulture, " (cast to {0})", 
+					((TypeReference) ins.Operand).Name);
 
 			case Code.Throw:					// this one is obvious
 				return string.Empty;
 
 			case Code.Unbox:
 			case Code.Unbox_Any:
-				return string.Format (" (unbox from {0})", ((TypeReference) ins.Operand).Name);
+				return String.Format (CultureInfo.InvariantCulture, " (unbox from {0})", 
+					((TypeReference) ins.Operand).Name);
 				
 			case Code.Ckfinite:
 				return " (the expression will throw if the value is a NAN or an infinity)";
@@ -360,7 +382,7 @@ namespace Gendarme.Rules.Exceptions {
 						if (ins.Previous.Is (Code.Newobj)) {
 							MethodReference mr = (MethodReference) ins.Previous.Operand;
 							TypeReference tr = mr.DeclaringType;
-							if (tr.FullName == "System.NotImplementedException" || tr.Inherits ("System.NotImplementedException"))
+							if (tr.IsNamed ("System", "NotImplementedException") || tr.Inherits ("System", "NotImplementedException"))
 								continue;
 						}	
 					
@@ -372,13 +394,22 @@ namespace Gendarme.Rules.Exceptions {
 						// If the throw does not one of the enumerated exceptions  (or 
 						// a subclass) then we have a problem.
 						else if (ins.Previous.Is (Code.Newobj)) {
-							MethodReference mr = (MethodReference) ins.Previous.Operand;
-							string name = mr.DeclaringType.FullName;
-							if (Array.IndexOf (allowedExceptions, name) < 0) {
-								if (!allowedExceptions.Any (e => mr.DeclaringType.Inherits (e))) {
-									Report (method, ins, methodLabel);
+							TypeReference type = (ins.Previous.Operand as MethodReference ).DeclaringType;
+							bool allowed = false;
+							foreach (string[] entry in allowedExceptions) {
+								if (type.IsNamed (entry [0], entry [1]))
+									allowed = true;
+							}
+							if (!allowed) {
+								foreach (string [] entry in allowedExceptions) {
+									if (type.Inherits (entry [0], entry [1])) {
+										allowed = true;
+										break;
+									}
 								}
 							}
+							if (!allowed)
+								Report (method, ins, methodLabel);
 						}	
 					}
 				}
@@ -388,10 +419,21 @@ namespace Gendarme.Rules.Exceptions {
 		private void Report (MethodDefinition method, Instruction ins, string methodLabel)
 		{
 			string mesg;
-			if (allowedExceptions == null)
-				mesg = string.Format ("{0} should not throw{1}.", methodLabel, ExplainThrow (ins));
-			else
-				mesg = string.Format ("{0} should only throw {1} or a subclass{2}.", methodLabel, string.Join (", ", allowedExceptions), ExplainThrow (ins));
+			if (allowedExceptions == null) {
+				mesg = String.Format (CultureInfo.InvariantCulture,
+					"{0} should not throw{1}.", methodLabel, ExplainThrow (ins));
+			} else {
+				StringBuilder sb = new StringBuilder ();
+				sb.Append (methodLabel).Append (" should only throw ");
+				for (int i = 0; i < allowedExceptions.Length; i++) {
+					string [] entry = allowedExceptions [i];
+					sb.Append (entry [0]).Append ('.').Append (entry [1]);
+					if (i < allowedExceptions.Length - 1)
+						sb.Append (", ");
+				}
+				sb.Append (" or a subclass").Append (ExplainThrow (ins)).Append ('.');
+				mesg = sb.ToString ();
+			}
 
 			Log.WriteLine (this, "{0:X4}: {1}", ins.Offset, mesg);
 			Runner.Report (method, ins, severity, Confidence.High, mesg);
diff --git a/gendarme/rules/Gendarme.Rules.Exceptions/DoNotThrowReservedExceptionRule.cs b/gendarme/rules/Gendarme.Rules.Exceptions/DoNotThrowReservedExceptionRule.cs
index c69fc7c..a7d989b 100644
--- a/gendarme/rules/Gendarme.Rules.Exceptions/DoNotThrowReservedExceptionRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Exceptions/DoNotThrowReservedExceptionRule.cs
@@ -24,6 +24,7 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
+using Mono.Cecil;
 using Gendarme.Framework;
 
 namespace Gendarme.Rules.Exceptions {
@@ -65,16 +66,20 @@ namespace Gendarme.Rules.Exceptions {
 	[FxCopCompatibility ("Microsoft.Usage", "CA2201:DoNotRaiseReservedExceptionTypes")]
 	public class DoNotThrowReservedExceptionRule : NewExceptionsRule {
 
-		static string [] ReservedExceptions = { 
-			"System.ExecutionEngineException", 
-			"System.IndexOutOfRangeException", 
-			"System.NullReferenceException", 
-			"System.OutOfMemoryException" 
-		};
-
-		protected override string [] GetExceptionTypes ()
+		protected override bool CheckException (TypeReference type)
 		{
-			return ReservedExceptions;
+			if (type == null)
+				return false;
+
+			switch (type.Name) {
+			case "ExecutionEngineException":
+			case "IndexOutOfRangeException":
+			case "NullReferenceException":
+			case "OutOfMemoryException":
+				return (type.Namespace == "System");
+			default:
+				return false;
+			}
 		}
 
 		protected override Severity Severity {
diff --git a/gendarme/rules/Gendarme.Rules.Exceptions/DontSwallowErrorsCatchingNonspecificExceptionsRule.cs b/gendarme/rules/Gendarme.Rules.Exceptions/DontSwallowErrorsCatchingNonspecificExceptionsRule.cs
index fce1269..903f5a6 100644
--- a/gendarme/rules/Gendarme.Rules.Exceptions/DontSwallowErrorsCatchingNonspecificExceptionsRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Exceptions/DontSwallowErrorsCatchingNonspecificExceptionsRule.cs
@@ -91,16 +91,13 @@ namespace Gendarme.Rules.Exceptions {
 		//}
 		//catch {
 		//}
-		private static bool IsForbiddenTypeInCatches (string typeName)
+		private static bool IsForbiddenTypeInCatches (TypeReference type)
 		{
-			switch (typeName) {
-			case "System.Exception":
-			case "System.SystemException":
-			case "System.Object":
-				return true;
-			default:
+			if (type.Namespace != "System")
 				return false;
-			}
+
+			string name = type.Name;
+			return ((name == "Exception") || (name == "SystemException") || (name == "Object"));
 		}
 
 		// will always return exceptionHandler.HandlerStart if there's no 'rethrow' inside the method
@@ -127,8 +124,7 @@ namespace Gendarme.Rules.Exceptions {
 			bool has_rethrow = OpCodeEngine.GetBitmask (method).Get (Code.Rethrow);
 			foreach (ExceptionHandler exceptionHandler in body.ExceptionHandlers) {
 				if (exceptionHandler.HandlerType == ExceptionHandlerType.Catch) {
-					string catchTypeName = exceptionHandler.CatchType.FullName;
-					if (IsForbiddenTypeInCatches (catchTypeName)) {
+					if (IsForbiddenTypeInCatches (exceptionHandler.CatchType)) {
 						// quickly find 'throw_instruction' if there's no 'rethrow' used in this method
 						Instruction throw_instruction = has_rethrow ?
 							ThrowsGeneralException (exceptionHandler) :
diff --git a/gendarme/rules/Gendarme.Rules.Exceptions/ExceptionShouldBeVisibleRule.cs b/gendarme/rules/Gendarme.Rules.Exceptions/ExceptionShouldBeVisibleRule.cs
index 284e5e7..1cce0b2 100644
--- a/gendarme/rules/Gendarme.Rules.Exceptions/ExceptionShouldBeVisibleRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Exceptions/ExceptionShouldBeVisibleRule.cs
@@ -74,18 +74,16 @@ namespace Gendarme.Rules.Exceptions {
 
 		public RuleResult CheckType (TypeDefinition type)
 		{
-			if (type.BaseType == null)
+			TypeReference btype = type.BaseType;
+			if (btype == null)
 				return RuleResult.DoesNotApply;
 
 			// rule apply only to type that inherits from the base exceptions
-			switch (type.BaseType.FullName) {
-			case "System.Exception":
-			case "System.SystemException":
-			case "System.ApplicationException":
-				break;
-			default:
+			if (btype.Namespace != "System")
+				return RuleResult.DoesNotApply;
+			string name = btype.Name;
+			if ((name != "Exception") && (name != "SystemException") && (name != "ApplicationException"))
 				return RuleResult.DoesNotApply;
-			}
 
 			if (type.IsAbstract || type.IsVisible ())
 				return RuleResult.Success;
diff --git a/gendarme/rules/Gendarme.Rules.Exceptions/Gendarme.Rules.Exceptions.csproj b/gendarme/rules/Gendarme.Rules.Exceptions/Gendarme.Rules.Exceptions.csproj
index 179882b..db66ede 100644
--- a/gendarme/rules/Gendarme.Rules.Exceptions/Gendarme.Rules.Exceptions.csproj
+++ b/gendarme/rules/Gendarme.Rules.Exceptions/Gendarme.Rules.Exceptions.csproj
@@ -1,5 +1,5 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
-<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="3.5">
+<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="4.0">
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
     <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
@@ -12,9 +12,11 @@
     <AssemblyName>Gendarme.Rules.Exceptions</AssemblyName>
     <FileUpgradeFlags>
     </FileUpgradeFlags>
-    <OldToolsVersion>2.0</OldToolsVersion>
+    <OldToolsVersion>3.5</OldToolsVersion>
     <UpgradeBackupLocation>
     </UpgradeBackupLocation>
+    <IsWebBootstrapper>true</IsWebBootstrapper>
+    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
     <PublishUrl>http://localhost/Gendarme.Rules.Exceptions/</PublishUrl>
     <Install>true</Install>
     <InstallFrom>Web</InstallFrom>
@@ -27,10 +29,9 @@
     <MapFileExtensions>true</MapFileExtensions>
     <ApplicationRevision>0</ApplicationRevision>
     <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
-    <IsWebBootstrapper>true</IsWebBootstrapper>
     <UseApplicationTrust>false</UseApplicationTrust>
     <BootstrapperEnabled>true</BootstrapperEnabled>
-    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <TargetFrameworkProfile />
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
     <DebugSymbols>true</DebugSymbols>
@@ -43,6 +44,7 @@
     <DocumentationFile>..\..\console\bin\Debug\Gendarme.Rules.Exceptions.xml</DocumentationFile>
     <NoWarn>1591</NoWarn>
     <WarningsAsErrors>1570</WarningsAsErrors>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
     <DebugType>pdbonly</DebugType>
@@ -54,6 +56,7 @@
     <DocumentationFile>..\..\console\bin\Release\Gendarme.Rules.Exceptions.xml</DocumentationFile>
     <NoWarn>1591</NoWarn>
     <WarningsAsErrors>1570</WarningsAsErrors>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <ItemGroup>
     <Reference Include="System" />
@@ -96,14 +99,33 @@
     <None Include="ChangeLog" />
   </ItemGroup>
   <ItemGroup>
+    <BootstrapperPackage Include="Microsoft.Net.Client.3.5">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1 Client Profile</ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
     <BootstrapperPackage Include="Microsoft.Net.Framework.2.0">
       <Visible>False</Visible>
+      <ProductName>
+      </ProductName>
+      <Install>false</Install>
     </BootstrapperPackage>
     <BootstrapperPackage Include="Microsoft.Net.Framework.3.0">
       <Visible>False</Visible>
+      <ProductName>
+      </ProductName>
+      <Install>false</Install>
     </BootstrapperPackage>
     <BootstrapperPackage Include="Microsoft.Net.Framework.3.5">
       <Visible>False</Visible>
+      <ProductName>
+      </ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1</ProductName>
+      <Install>false</Install>
     </BootstrapperPackage>
   </ItemGroup>
   <Import Project="$(MSBuildBinPath)\Microsoft.CSharp.targets" />
diff --git a/gendarme/rules/Gendarme.Rules.Exceptions/InstantiateArgumentExceptionCorrectlyRule.cs b/gendarme/rules/Gendarme.Rules.Exceptions/InstantiateArgumentExceptionCorrectlyRule.cs
index b9b5dab..b085345 100644
--- a/gendarme/rules/Gendarme.Rules.Exceptions/InstantiateArgumentExceptionCorrectlyRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Exceptions/InstantiateArgumentExceptionCorrectlyRule.cs
@@ -130,7 +130,7 @@ namespace Gendarme.Rules.Exceptions {
 				return;
 
 			// OK		public ArgumentException (string message, Exception innerException)
-			if (pdc [1].ParameterType.FullName != "System.String")
+			if (!pdc [1].ParameterType.IsNamed ("System", "String"))
 				return;
 
 			// CHECK	public ArgumentException (string message, string paramName)
@@ -153,12 +153,17 @@ namespace Gendarme.Rules.Exceptions {
 			// OK		protected ArgumentNullException (SerializationInfo info, StreamingContext context)
 			// OK		public ArgumentNullException (string message, Exception innerException)
 			IList<ParameterDefinition> pdc = constructor.Parameters;
-			if ((pdc.Count == 2) && (pdc [1].ParameterType.FullName != "System.String"))
+			if ((pdc.Count == 2) && !pdc [1].ParameterType.IsNamed ("System", "String"))
 				return;
 
 			// CHECK	public ArgumentNullException (string paramName)
 			// CHECK	public ArgumentNullException (string paramName, string message)
 			Instruction call = ins.TraceBack (method, 0);
+			
+			// call will be null if there is branching logic in the selection of a message - just fon't check in this case
+			if (call == null)
+				return;
+
 			string name = call.Operand as string;
 			if (MatchesAnyParameter (method, name))
 				return;
@@ -187,18 +192,19 @@ namespace Gendarme.Rules.Exceptions {
 					continue;
 
 				MethodReference ctor = (current.Operand as MethodReference);
+				TypeReference type = ctor.DeclaringType;
+				if (type.Namespace != "System")
+					continue;
 
-				switch (ctor.DeclaringType.FullName) {
-				case "System.ArgumentException":
+				switch (type.Name) {
+				case "ArgumentException":
 					CheckArgumentException (ctor, current, method);
 					break;
-				case "System.ArgumentNullException":
-				case "System.ArgumentOutOfRangeException":
-				case "System.DuplicateWaitObjectException":
+				case "ArgumentNullException":
+				case "ArgumentOutOfRangeException":
+				case "DuplicateWaitObjectException":
 					CheckOtherExceptions (ctor, current, method);
 					break;
-				default:
-					continue;
 				}
 			}
 
diff --git a/gendarme/rules/Gendarme.Rules.Exceptions/Makefile.am b/gendarme/rules/Gendarme.Rules.Exceptions/Makefile.am
index 071342b..30c2b74 100644
--- a/gendarme/rules/Gendarme.Rules.Exceptions/Makefile.am
+++ b/gendarme/rules/Gendarme.Rules.Exceptions/Makefile.am
@@ -4,6 +4,7 @@ rules_sources =  \
 	AvoidArgumentExceptionDefaultConstructorRule.cs \
 	AvoidThrowingBasicExceptionsRule.cs \
 	DoNotDestroyStackTraceRule.cs \
+	DoNotThrowInNonCatchClausesRule.cs \
 	DoNotThrowInUnexpectedLocationRule.cs \
 	DoNotThrowReservedExceptionRule.cs \
 	DontSwallowErrorsCatchingNonspecificExceptionsRule.cs \
@@ -19,6 +20,7 @@ rules_sources =  \
 tests_sources = \
 	AvoidArgumentExceptionDefaultConstructorTest.cs \
 	AvoidThrowingBasicExceptionsTest.cs \
+	DoNotThrowInNonCatchClausesTest.cs \
 	DoNotThrowInUnexpectedLocationTest.cs \
 	DontDestroyStackTraceTest.cs \
 	DontSwallowErrorsCatchingNonspecificExceptionsTest.cs \
diff --git a/gendarme/rules/Gendarme.Rules.Exceptions/MissingExceptionConstructorsRule.cs b/gendarme/rules/Gendarme.Rules.Exceptions/MissingExceptionConstructorsRule.cs
index 32663e5..d4d86af 100644
--- a/gendarme/rules/Gendarme.Rules.Exceptions/MissingExceptionConstructorsRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Exceptions/MissingExceptionConstructorsRule.cs
@@ -26,6 +26,7 @@
 
 using System;
 using System.Collections.Generic;
+using System.Globalization;
 
 using Mono.Cecil;
 
@@ -86,9 +87,6 @@ namespace Gendarme.Rules.Exceptions {
 	[FxCopCompatibility ("Microsoft.Design", "CA1032:ImplementStandardExceptionConstructors")]
 	public class MissingExceptionConstructorsRule : Rule, ITypeRule {
 
-		// non-localizable
-		private const string Exception = "System.Exception";
-
 		// localizable
 		private const string MissingConstructor = "Exception is missing '{0} {1}{2}' constructor.";
 
@@ -97,15 +95,15 @@ namespace Gendarme.Rules.Exceptions {
 			if (!ctor.IsPublic)
 				return false;
 
-			return (ctor.Parameters [0].ParameterType.FullName == "System.String");
+			return (ctor.Parameters [0].ParameterType.IsNamed ("System", "String"));
 		}
 
 		private static bool CheckForInnerExceptionConstructor (IMethodSignature ctor)
 		{
 			IList<ParameterDefinition> pdc = ctor.Parameters;
-			string first = pdc [0].ParameterType.FullName;
-			string last = pdc [pdc.Count - 1].ParameterType.FullName;
-			return ((first == "System.String") && (last == Exception));
+			if (!pdc [0].ParameterType.IsNamed ("System", "String"))
+				return false;
+			return pdc [pdc.Count - 1].ParameterType.IsNamed ("System", "Exception");
 		}
 
 		private static bool CheckForSerializationConstructor (MethodDefinition ctor)
@@ -119,7 +117,7 @@ namespace Gendarme.Rules.Exceptions {
 		public RuleResult CheckType (TypeDefinition type)
 		{
 			// rule apply only to type that inherits from System.Exception
-			if (!type.Inherits (Exception))
+			if (!type.Inherits ("System", "Exception"))
 				return RuleResult.DoesNotApply;
 
 			// rule applies, only Success or Failure from the point on
@@ -166,21 +164,24 @@ namespace Gendarme.Rules.Exceptions {
 			}
 
 			if (!empty_ctor) {
-				string s = String.Format (MissingConstructor, "public", type.Name, "()");
+				string s = String.Format (CultureInfo.InvariantCulture, MissingConstructor, "public", 
+					type.Name, "()");
 				Runner.Report (type, Severity.High, Confidence.Total, s);
 			}
 			if (!string_ctor) {
-				string s = String.Format (MissingConstructor, "public", type.Name, "(string message)");
+				string s = String.Format (CultureInfo.InvariantCulture, MissingConstructor, "public", 
+					type.Name, "(string message)");
 				Runner.Report (type, Severity.High, Confidence.Total, s);
 			}
 			if (!inner_exception_ctor) {
-				string s = String.Format (MissingConstructor, "public", type.Name,
-					"(string message, Exception innerException)");
+				string s = String.Format (CultureInfo.InvariantCulture, MissingConstructor, "public", 
+					type.Name, "(string message, Exception innerException)");
 				Runner.Report (type, Severity.High, Confidence.Total, s);
 			}
 			if (!serialization_ctor) {
-				string s = String.Format (MissingConstructor, (type.IsSealed) ? "private" : "protected",
-					type.Name, "(SerializationInfo info, StreamingContext context)");
+				string s = String.Format (CultureInfo.InvariantCulture, MissingConstructor, 
+					(type.IsSealed) ? "private" : "protected", type.Name, 
+					"(SerializationInfo info, StreamingContext context)");
 				Runner.Report (type, Severity.High, Confidence.Total, s);
 			}
 
diff --git a/gendarme/rules/Gendarme.Rules.Exceptions/NewExceptionRule.cs b/gendarme/rules/Gendarme.Rules.Exceptions/NewExceptionRule.cs
index f2d3f75..22605f2 100644
--- a/gendarme/rules/Gendarme.Rules.Exceptions/NewExceptionRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Exceptions/NewExceptionRule.cs
@@ -46,12 +46,14 @@ namespace Gendarme.Rules.Exceptions {
 			// if the module does not reference any of these types, don't analyze it
 			// (unless this is corlib itself since they're defined in it :-)
 			Runner.AnalyzeModule += delegate (object o, RunnerEventArgs e) {
-				Active = (e.CurrentAssembly.Name.Name == "mscorlib") ||
-					e.CurrentModule.HasAnyTypeReference (GetExceptionTypes ());
+				Active = (e.CurrentAssembly.Name.Name == "mscorlib" ||
+					e.CurrentModule.AnyTypeReference ((TypeReference tr) => {
+						return CheckException (tr);
+					}));
 			};
 		}
 
-		abstract protected string [] GetExceptionTypes ();
+		abstract protected bool CheckException (TypeReference type);
 		abstract protected Severity Severity { get; }
 
 		public RuleResult CheckMethod (MethodDefinition method)
@@ -69,18 +71,12 @@ namespace Gendarme.Rules.Exceptions {
 				if (ins.OpCode.Code != Code.Newobj)
 					continue;
 
-				// obtain a reference to constructor
-				MethodReference ctor = (ins.Operand as MethodReference);
+				// obtain a reference to the constructor's type
+				TypeReference ctype = (ins.Operand as MethodReference).DeclaringType;
 
-				// what type is it?
-				string name = ctor.DeclaringType.FullName;
-				foreach (string exception_type in GetExceptionTypes ()) {
-					if (name == exception_type) {
-						// report a defect including the offending exception type found
-						Runner.Report (method, ins, Severity, Confidence.High, name);
-						break;
-					}
-				}
+				// report a defect if an offending exception type is found
+				if (CheckException (ctype))
+					Runner.Report (method, ins, Severity, Confidence.High, ctype.Name);
 			}
 
 			return Runner.CurrentRuleResult;
diff --git a/gendarme/rules/Gendarme.Rules.Exceptions/README.md b/gendarme/rules/Gendarme.Rules.Exceptions/README.md
new file mode 100644
index 0000000..110e852
--- /dev/null
+++ b/gendarme/rules/Gendarme.Rules.Exceptions/README.md
@@ -0,0 +1,9 @@
+# Gendarme.Rules.Exceptions Rules
+
+You can access the latest rules documentation from our [[wiki|https://github.com/spouliot/gendarme/wiki/Gendarme.Rules.Exceptions(git)]] pages.
+
+
+## Feedback
+
+Please report any documentation errors, typos or suggestions to the [[Gendarme Mailing List|https://groups.google.com/forum/?fromgroups#!forum/gendarme]]. Thanks!
+
diff --git a/gendarme/rules/Gendarme.Rules.Exceptions/Test/DoNotThrowInNonCatchClausesTest.cs b/gendarme/rules/Gendarme.Rules.Exceptions/Test/DoNotThrowInNonCatchClausesTest.cs
new file mode 100644
index 0000000..9bb6ddd
--- /dev/null
+++ b/gendarme/rules/Gendarme.Rules.Exceptions/Test/DoNotThrowInNonCatchClausesTest.cs
@@ -0,0 +1,136 @@
+//
+// Unit Tests for DoNotThrowInNonCatchClausesRule
+//
+// Authors:
+//	Sebastien Pouliot <sebastien@ximian.com>
+//
+// Copyright (C) 2011 Novell, Inc (http://www.novell.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using Gendarme.Rules.Exceptions;
+
+using NUnit.Framework;
+using Test.Rules.Definitions;
+using Test.Rules.Fixtures;
+
+namespace Test.Rules.Exceptions {
+
+	[TestFixture]
+	public class DoNotThrowInNonCatchClausesTest : MethodRuleTestFixture<DoNotThrowInNonCatchClausesRule> {
+
+		[Test]
+		public void DoesNotApply ()
+		{
+			AssertRuleDoesNotApply (SimpleMethods.ExternalMethod);
+			AssertRuleDoesNotApply (SimpleMethods.EmptyMethod);
+		}
+
+		void ThrowInTry ()
+		{
+			try {
+				throw new NotImplementedException ("no luck");
+			}
+			finally {
+				Console.WriteLine ();
+			}
+		}
+
+		void ThrowInCatch ()
+		{
+			try {
+				Console.WriteLine ();
+			}
+			catch (Exception e) {
+				throw new NotImplementedException ("no luck", e);
+			}
+		}
+
+		// copied from DontDestroyStackTraceTest since CSC compiles the HandlerEnd as past the method offset
+		void ThrowCatchThrowNew ()
+		{
+			try {
+				throw new NotImplementedException ();
+			}
+			catch (Exception) {
+				throw new NotImplementedException ();
+			}
+		}
+
+		[Test]
+		public void Success ()
+		{
+			AssertRuleSuccess<DoNotThrowInNonCatchClausesTest> ("ThrowInTry");
+			AssertRuleSuccess<DoNotThrowInNonCatchClausesTest> ("ThrowInCatch");
+			AssertRuleSuccess<DoNotThrowInNonCatchClausesTest> ("ThrowCatchThrowNew");
+		}
+
+		void RethrowInCatch ()
+		{
+			try {
+				Console.WriteLine ();
+			}
+			catch (Exception) {
+				throw; // rethrow in IL which is seen only in catch clauses
+			}
+		}
+
+		[Test]
+		public void Rethrow ()
+		{
+			AssertRuleDoesNotApply<DoNotThrowInNonCatchClausesTest> ("RethrowInCatch");
+		}
+
+		void ThrowInFinally ()
+		{
+			try {
+				Console.WriteLine ();
+			}
+			finally {
+				throw new NotImplementedException ("no luck");
+			}
+		}
+
+		void ThrowInFinallyToo ()
+		{
+			try {
+				throw new NotImplementedException ("no luck");
+			}
+			catch (Exception e) {
+				throw new NotImplementedException ("no more luck", e);
+			}
+			finally {
+				if (GetType ().IsSealed)
+					throw new NotImplementedException ("never any luck");
+				else
+					throw new NotSupportedException ("stop playing cards");
+			}
+		}
+
+		[Test]
+		public void Failure ()
+		{
+			AssertRuleFailure<DoNotThrowInNonCatchClausesTest> ("ThrowInFinally", 1);
+			AssertRuleFailure<DoNotThrowInNonCatchClausesTest> ("ThrowInFinallyToo", 2);
+		}
+	}
+}
diff --git a/gendarme/rules/Gendarme.Rules.Exceptions/Test/InstantiateArgumentExceptionCorrectlyTest.cs b/gendarme/rules/Gendarme.Rules.Exceptions/Test/InstantiateArgumentExceptionCorrectlyTest.cs
index 8727b8b..d53501d 100644
--- a/gendarme/rules/Gendarme.Rules.Exceptions/Test/InstantiateArgumentExceptionCorrectlyTest.cs
+++ b/gendarme/rules/Gendarme.Rules.Exceptions/Test/InstantiateArgumentExceptionCorrectlyTest.cs
@@ -777,5 +777,49 @@ namespace Test.Rules.Exceptions {
 			AssertRuleSuccess<InstantiateArgumentExceptionCorrectlyTest> ("get_Item");
 			AssertRuleSuccess<InstantiateArgumentExceptionCorrectlyTest> ("set_Item");
 		}
+
+		public void ArgumentNullExceptionWithBranchInMessageSelectionAndIncorrectParameterName(int parameter)
+		{
+			throw new ArgumentNullException("asdf", parameter > 0 ? "little parameter " : "big parameter");
+		}
+
+		public void ArgumentOutOfRangeExceptionWithBranchInMessageSelectionAndIncorrectParameterName(int parameter)
+		{
+			throw new ArgumentOutOfRangeException("asdf", parameter > 0 ? "little parameter " : "big parameter");
+		}
+
+		public void DuplicateWaitObjectExceptionWithBranchInMessageSelectionAndIncorrectParameterName(int parameter)
+		{
+			throw new DuplicateWaitObjectException("asdf", parameter > 0 ? "little parameter " : "big parameter");
+		}
+
+		public void ArgumentNullExceptionWithBranchInMessageSelectionAndCorrectParameterName(int parameter)
+		{
+			throw new ArgumentNullException("parameter", parameter > 0 ? "little parameter " : "big parameter");
+		}
+
+		public void ArgumentOutOfRangeExceptionWithBranchInMessageSelectionAndCorrectParameterName(int parameter)
+		{
+			throw new ArgumentOutOfRangeException("parameter", parameter > 0 ? "little parameter " : "big parameter");
+		}
+
+		public void DuplicateWaitObjectExceptionWithBranchInMessageSelectionAndCorrectParameterName(int parameter)
+		{
+			throw new DuplicateWaitObjectException("parameter", parameter > 0 ? "little parameter " : "big parameter");
+		}
+
+		[Test]
+		public void ArgumentExceptionsWithBranchInMessageSelectionDoesNotThrow()
+		{
+			AssertRuleSuccess<InstantiateArgumentExceptionCorrectlyTest>("ArgumentNullExceptionWithBranchInMessageSelectionAndCorrectParameterName");
+			AssertRuleSuccess<InstantiateArgumentExceptionCorrectlyTest>("ArgumentOutOfRangeExceptionWithBranchInMessageSelectionAndCorrectParameterName");
+			AssertRuleSuccess<InstantiateArgumentExceptionCorrectlyTest>("DuplicateWaitObjectExceptionWithBranchInMessageSelectionAndCorrectParameterName");
+
+			//Ideally the rules below would be AssertRuleFailure - but better to incorrectly pass than to throw an unhandled exception
+			// If the handling code is changed a better resolution here may be possible
+			AssertRuleSuccess<InstantiateArgumentExceptionCorrectlyTest>("ArgumentNullExceptionWithBranchInMessageSelectionAndIncorrectParameterName");
+			AssertRuleSuccess<InstantiateArgumentExceptionCorrectlyTest>("ArgumentOutOfRangeExceptionWithBranchInMessageSelectionAndIncorrectParameterName");
+			AssertRuleSuccess<InstantiateArgumentExceptionCorrectlyTest>("DuplicateWaitObjectExceptionWithBranchInMessageSelectionAndIncorrectParameterName");
+		}
 	}
 }
diff --git a/gendarme/rules/Gendarme.Rules.Exceptions/Test/Tests.Rules.Exceptions.csproj b/gendarme/rules/Gendarme.Rules.Exceptions/Test/Tests.Rules.Exceptions.csproj
index d37db89..2e31f25 100644
--- a/gendarme/rules/Gendarme.Rules.Exceptions/Test/Tests.Rules.Exceptions.csproj
+++ b/gendarme/rules/Gendarme.Rules.Exceptions/Test/Tests.Rules.Exceptions.csproj
@@ -1,5 +1,5 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
-<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="3.5">
+<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="4.0">
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
     <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
@@ -12,9 +12,11 @@
     <AssemblyName>Tests.Rules.Exceptions</AssemblyName>
     <FileUpgradeFlags>
     </FileUpgradeFlags>
-    <OldToolsVersion>2.0</OldToolsVersion>
+    <OldToolsVersion>3.5</OldToolsVersion>
     <UpgradeBackupLocation>
     </UpgradeBackupLocation>
+    <IsWebBootstrapper>true</IsWebBootstrapper>
+    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
     <PublishUrl>http://localhost/Tests.Rules.Exceptions/</PublishUrl>
     <Install>true</Install>
     <InstallFrom>Web</InstallFrom>
@@ -27,10 +29,9 @@
     <MapFileExtensions>true</MapFileExtensions>
     <ApplicationRevision>0</ApplicationRevision>
     <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
-    <IsWebBootstrapper>true</IsWebBootstrapper>
     <UseApplicationTrust>false</UseApplicationTrust>
     <BootstrapperEnabled>true</BootstrapperEnabled>
-    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <TargetFrameworkProfile />
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
     <DebugSymbols>true</DebugSymbols>
@@ -40,6 +41,7 @@
     <DefineConstants>DEBUG;TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
     <DebugType>pdbonly</DebugType>
@@ -48,6 +50,7 @@
     <DefineConstants>TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <ItemGroup>
     <Reference Include="nunit.framework, Version=2.4.8.0, Culture=neutral, PublicKeyToken=96d09a1eb7f44a77, processorArchitecture=MSIL">
@@ -95,14 +98,33 @@
     <None Include="ChangeLog" />
   </ItemGroup>
   <ItemGroup>
+    <BootstrapperPackage Include="Microsoft.Net.Client.3.5">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1 Client Profile</ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
     <BootstrapperPackage Include="Microsoft.Net.Framework.2.0">
       <Visible>False</Visible>
+      <ProductName>
+      </ProductName>
+      <Install>false</Install>
     </BootstrapperPackage>
     <BootstrapperPackage Include="Microsoft.Net.Framework.3.0">
       <Visible>False</Visible>
+      <ProductName>
+      </ProductName>
+      <Install>false</Install>
     </BootstrapperPackage>
     <BootstrapperPackage Include="Microsoft.Net.Framework.3.5">
       <Visible>False</Visible>
+      <ProductName>
+      </ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1</ProductName>
+      <Install>false</Install>
     </BootstrapperPackage>
   </ItemGroup>
   <Import Project="$(MSBuildBinPath)\Microsoft.CSharp.targets" />
diff --git a/gendarme/rules/Gendarme.Rules.Exceptions/UseObjectDisposedExceptionRule.cs b/gendarme/rules/Gendarme.Rules.Exceptions/UseObjectDisposedExceptionRule.cs
index fbb1f0f..8636091 100644
--- a/gendarme/rules/Gendarme.Rules.Exceptions/UseObjectDisposedExceptionRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Exceptions/UseObjectDisposedExceptionRule.cs
@@ -150,7 +150,9 @@ namespace Gendarme.Rules.Exceptions {
 		
 		private void CheckBody (MethodDefinition method)
 		{
-			string fullname = method.DeclaringType.FullName;
+			TypeReference type = method.DeclaringType;
+			string nspace = type.Namespace;
+			string name = type.Name;
 			foreach (Instruction ins in method.Body.Instructions) {
 				switch (ins.OpCode.Code) {
 				case Code.Call:
@@ -160,7 +162,7 @@ namespace Gendarme.Rules.Exceptions {
 						MethodDefinition callee = target.Resolve ();
 						if (callee != null) {
 							if (!callee.IsPublic && !callee.IsStatic) {
-								if (callee.DeclaringType.FullName == fullname) {
+								if (callee.DeclaringType.IsNamed (nspace, name)) {
 									Instruction instance = ins.TraceBack (method);
 									if (instance != null && instance.OpCode.Code == Code.Ldarg_0) {
 										Log.WriteLine (this, "found non-public this call at {0:X4}", ins.Offset);
@@ -187,7 +189,7 @@ namespace Gendarme.Rules.Exceptions {
 				case Code.Ldflda:
 					if (!field_access_using_this) {
 						FieldReference field = (FieldReference) ins.Operand;
-						if (field.DeclaringType.FullName == fullname) {
+						if (field.DeclaringType.IsNamed (nspace, name)) {
 							Instruction instance = ins.TraceBack (method);
 							if (instance != null && instance.OpCode.Code == Code.Ldarg_0) {
 								Log.WriteLine (this, "found field access at {0:X4}", ins.Offset);
@@ -200,7 +202,7 @@ namespace Gendarme.Rules.Exceptions {
 				case Code.Newobj:
 					if (!creates_exception) {
 						MethodReference ctor = (MethodReference) ins.Operand;
-						if (ctor.DeclaringType.FullName == "System.ObjectDisposedException") {
+						if (ctor.DeclaringType.IsNamed ("System", "ObjectDisposedException")) {
 							Log.WriteLine (this, "creates exception at {0:X4}", ins.Offset);
 							creates_exception = true;
 						}
@@ -220,7 +222,7 @@ namespace Gendarme.Rules.Exceptions {
 			
 			if (method.IsPublic) {
 				if (OpCodeEngine.GetBitmask (method).Intersect (CallsAndFields)) {
-					if (method.DeclaringType.Implements ("System.IDisposable")) {
+					if (method.DeclaringType.Implements ("System", "IDisposable")) {
 						if (AllowedToThrow (method)) {
 							needs = true;
 						}
diff --git a/gendarme/rules/Gendarme.Rules.Gendarme/DefectsMustBeReportedRule.cs b/gendarme/rules/Gendarme.Rules.Gendarme/DefectsMustBeReportedRule.cs
index ab02b90..9376fc6 100644
--- a/gendarme/rules/Gendarme.Rules.Gendarme/DefectsMustBeReportedRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Gendarme/DefectsMustBeReportedRule.cs
@@ -75,11 +75,11 @@ namespace Gendarme.Rules.Gendarme {
 	public class DefectsMustBeReportedRule : GendarmeRule, ITypeRule {
 		public RuleResult CheckType (TypeDefinition type)
 		{
-			if (type.IsAbstract || !type.Implements ("Gendarme.Framework.IRule") || !type.HasMethods)
+			if (type.IsAbstract || !type.HasMethods || !type.Implements ("Gendarme.Framework", "IRule"))
 				return RuleResult.DoesNotApply;
 
 			foreach (MethodDefinition method in type.Methods) {
-				if (!method.HasBody || !OpCodeBitmask.Calls.Intersect (OpCodeEngine.GetBitmask (method)) || method.IsConstructor)
+				if (method.IsConstructor || !method.HasBody || !OpCodeBitmask.Calls.Intersect (OpCodeEngine.GetBitmask (method)))
 					continue;
 
 				foreach (Instruction instruction in method.Body.Instructions) {
@@ -87,9 +87,9 @@ namespace Gendarme.Rules.Gendarme {
 						continue;
 					
 					MethodReference m = (instruction.Operand as MethodReference);
-					if (m == null || m.DeclaringType.FullName != "Gendarme.Framework.IRunner")
+					if (m == null || (m.Name != "Report"))
 						continue;
-					if (m.Name == "Report")
+					if (m.DeclaringType.IsNamed ("Gendarme.Framework", "IRunner"))
 						return RuleResult.Success;
 				}
 				
diff --git a/gendarme/rules/Gendarme.Rules.Gendarme/DoNotThrowExceptionRule.cs b/gendarme/rules/Gendarme.Rules.Gendarme/DoNotThrowExceptionRule.cs
index 271e793..78ae7a7 100644
--- a/gendarme/rules/Gendarme.Rules.Gendarme/DoNotThrowExceptionRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Gendarme/DoNotThrowExceptionRule.cs
@@ -74,7 +74,7 @@ namespace Gendarme.Rules.Gendarme {
 
 			Runner.AnalyzeType += (object sender, RunnerEventArgs e) =>
 			{
-				Active = e.CurrentType.Implements ("Gendarme.Framework.IRule");
+				Active = e.CurrentType.Implements ("Gendarme.Framework", "IRule");
 			};
 		}
 
@@ -89,7 +89,7 @@ namespace Gendarme.Rules.Gendarme {
 
 			if (method.IsSetter && method.IsPublic) {
 				PropertyDefinition property = method.GetPropertyByAccessor ();
-				if (property != null && property.HasCustomAttributes && property.HasAttribute ("System.ComponentModel.DescriptionAttribute"))
+				if (property.HasAttribute ("System.ComponentModel", "DescriptionAttribute"))
 					return RuleResult.Success;
 			}
 
@@ -105,7 +105,7 @@ namespace Gendarme.Rules.Gendarme {
 					continue;
 
 				TypeReference type = m.DeclaringType;
-				if (type.FullName != "System.NotImplementedException" && !type.Inherits ("System.NotImplementedException"))
+				if (type.Inherits ("System", "Exception"))
 					Runner.Report (method, instruction, Severity.Medium, Confidence.High);
 			}
 
diff --git a/gendarme/rules/Gendarme.Rules.Gendarme/Gendarme.Rules.Gendarme.csproj b/gendarme/rules/Gendarme.Rules.Gendarme/Gendarme.Rules.Gendarme.csproj
index 0201472..77396b1 100755
--- a/gendarme/rules/Gendarme.Rules.Gendarme/Gendarme.Rules.Gendarme.csproj
+++ b/gendarme/rules/Gendarme.Rules.Gendarme/Gendarme.Rules.Gendarme.csproj
@@ -1,73 +1,112 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <PropertyGroup>
-    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
-    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
-    <ProductVersion>9.0.30729</ProductVersion>
-    <SchemaVersion>2.0</SchemaVersion>
-    <ProjectGuid>{619CDBD4-D89E-47E1-9A82-0F194A665D48}</ProjectGuid>
-    <OutputType>Library</OutputType>
-    <AppDesignerFolder>Properties</AppDesignerFolder>
-    <RootNamespace>Gendarme.Rules.Gendarme</RootNamespace>
-    <AssemblyName>Gendarme.Rules.Gendarme</AssemblyName>
-    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
-    <FileAlignment>512</FileAlignment>
-  </PropertyGroup>
-  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
-    <DebugSymbols>true</DebugSymbols>
-    <DebugType>full</DebugType>
-    <Optimize>false</Optimize>
-    <OutputPath>..\..\console\bin\Debug\</OutputPath>
-    <DefineConstants>DEBUG;TRACE</DefineConstants>
-    <ErrorReport>prompt</ErrorReport>
-    <WarningLevel>4</WarningLevel>
-    <DocumentationFile>..\..\console\bin\Debug\Gendarme.Rules.Gendarme.xml</DocumentationFile>
-  </PropertyGroup>
-  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
-    <DebugType>pdbonly</DebugType>
-    <Optimize>true</Optimize>
-    <OutputPath>..\..\console\bin\Release\</OutputPath>
-    <DefineConstants>TRACE;RELEASE</DefineConstants>
-    <ErrorReport>prompt</ErrorReport>
-    <WarningLevel>4</WarningLevel>
-    <DocumentationFile>..\..\console\bin\Release\Gendarme.Rules.Gendarme.xml</DocumentationFile>
-  </PropertyGroup>
-  <ItemGroup>
-    <Reference Include="System" />
-    <Reference Include="System.Core">
-      <RequiredTargetFramework>3.5</RequiredTargetFramework>
-    </Reference>
-  </ItemGroup>
-  <ItemGroup>
-    <Compile Include="..\..\AssemblyStaticInfo.cs">
-      <Link>AssemblyStaticInfo.cs</Link>
-    </Compile>
-    <Compile Include="DefectsMustBeReportedRule.cs" />
-    <Compile Include="DoNotThrowExceptionRule.cs" />
-    <Compile Include="GendarmeRule.cs" />
-    <Compile Include="MissingEngineDependencyRule.cs" />
-    <Compile Include="ReviewAttributesOnRulesRule.cs" />
-    <Compile Include="UseCorrectSuffixRule.cs" />
-  </ItemGroup>
-  <ItemGroup>
-    <ProjectReference Include="..\..\..\..\cecil\Mono.Cecil.csproj">
-      <Project>{D68133BD-1E63-496E-9EDE-4FBDBF77B486}</Project>
-      <Name>Mono.Cecil</Name>
-    </ProjectReference>
-    <ProjectReference Include="..\..\framework\Gendarme.Framework.csproj">
-      <Project>{CD6818D5-B398-486C-B180-92A07B143AFD}</Project>
-      <Name>Gendarme.Framework</Name>
-    </ProjectReference>
-  </ItemGroup>
-  <ItemGroup>
-    <Folder Include="Properties\" />
-  </ItemGroup>
-  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
+    <ProductVersion>9.0.30729</ProductVersion>
+    <SchemaVersion>2.0</SchemaVersion>
+    <ProjectGuid>{619CDBD4-D89E-47E1-9A82-0F194A665D48}</ProjectGuid>
+    <OutputType>Library</OutputType>
+    <AppDesignerFolder>Properties</AppDesignerFolder>
+    <RootNamespace>Gendarme.Rules.Gendarme</RootNamespace>
+    <AssemblyName>Gendarme.Rules.Gendarme</AssemblyName>
+    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
+    <FileAlignment>512</FileAlignment>
+    <FileUpgradeFlags>
+    </FileUpgradeFlags>
+    <OldToolsVersion>3.5</OldToolsVersion>
+    <UpgradeBackupLocation />
+    <PublishUrl>publish\</PublishUrl>
+    <Install>true</Install>
+    <InstallFrom>Disk</InstallFrom>
+    <UpdateEnabled>false</UpdateEnabled>
+    <UpdateMode>Foreground</UpdateMode>
+    <UpdateInterval>7</UpdateInterval>
+    <UpdateIntervalUnits>Days</UpdateIntervalUnits>
+    <UpdatePeriodically>false</UpdatePeriodically>
+    <UpdateRequired>false</UpdateRequired>
+    <MapFileExtensions>true</MapFileExtensions>
+    <ApplicationRevision>0</ApplicationRevision>
+    <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
+    <IsWebBootstrapper>false</IsWebBootstrapper>
+    <UseApplicationTrust>false</UseApplicationTrust>
+    <BootstrapperEnabled>true</BootstrapperEnabled>
+    <TargetFrameworkProfile />
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
+    <DebugSymbols>true</DebugSymbols>
+    <DebugType>full</DebugType>
+    <Optimize>false</Optimize>
+    <OutputPath>..\..\console\bin\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+    <DocumentationFile>..\..\console\bin\Debug\Gendarme.Rules.Gendarme.xml</DocumentationFile>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
+    <DebugType>pdbonly</DebugType>
+    <Optimize>true</Optimize>
+    <OutputPath>..\..\console\bin\Release\</OutputPath>
+    <DefineConstants>TRACE;RELEASE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+    <DocumentationFile>..\..\console\bin\Release\Gendarme.Rules.Gendarme.xml</DocumentationFile>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
+  </PropertyGroup>
+  <ItemGroup>
+    <Reference Include="System" />
+    <Reference Include="System.Core">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+  </ItemGroup>
+  <ItemGroup>
+    <Compile Include="..\..\AssemblyStaticInfo.cs">
+      <Link>AssemblyStaticInfo.cs</Link>
+    </Compile>
+    <Compile Include="DefectsMustBeReportedRule.cs" />
+    <Compile Include="DoNotThrowExceptionRule.cs" />
+    <Compile Include="GendarmeRule.cs" />
+    <Compile Include="MissingEngineDependencyRule.cs" />
+    <Compile Include="ReviewAttributesOnRulesRule.cs" />
+    <Compile Include="UseCorrectSuffixRule.cs" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\..\..\..\cecil\Mono.Cecil.csproj">
+      <Project>{D68133BD-1E63-496E-9EDE-4FBDBF77B486}</Project>
+      <Name>Mono.Cecil</Name>
+    </ProjectReference>
+    <ProjectReference Include="..\..\framework\Gendarme.Framework.csproj">
+      <Project>{CD6818D5-B398-486C-B180-92A07B143AFD}</Project>
+      <Name>Gendarme.Framework</Name>
+    </ProjectReference>
+  </ItemGroup>
+  <ItemGroup>
+    <Folder Include="Properties\" />
+  </ItemGroup>
+  <ItemGroup>
+    <BootstrapperPackage Include="Microsoft.Net.Client.3.5">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1 Client Profile</ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Windows.Installer.3.1">
+      <Visible>False</Visible>
+      <ProductName>Windows Installer 3.1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+  </ItemGroup>
+  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
   <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
        Other similar extension points exist, see Microsoft.Common.targets.
   <Target Name="BeforeBuild">
   </Target>
   <Target Name="AfterBuild">
   </Target>
-  -->
+  -->
 </Project>
\ No newline at end of file
diff --git a/gendarme/rules/Gendarme.Rules.Gendarme/MissingEngineDependencyRule.cs b/gendarme/rules/Gendarme.Rules.Gendarme/MissingEngineDependencyRule.cs
index 7024d4f..07fb46a 100644
--- a/gendarme/rules/Gendarme.Rules.Gendarme/MissingEngineDependencyRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Gendarme/MissingEngineDependencyRule.cs
@@ -80,12 +80,14 @@ namespace Gendarme.Rules.Gendarme {
 			"Gendarme.Framework.Engines.NamespaceEngine"
 		};
 
+		private HashSet<string> declaredEngines = new HashSet<string> ();
+
 		public RuleResult CheckType (TypeDefinition type)
 		{
 			if (!type.HasMethods)
 				return RuleResult.DoesNotApply;
 
-			HashSet<string> declaredEngines = GetEngineDependencyValue (type);
+			GetEngineDependencyValue (type);
 
 			foreach (MethodDefinition method in type.Methods) {
 				if (!method.HasBody || !OpCodeBitmask.Calls.Intersect (OpCodeEngine.GetBitmask (method)))
@@ -95,8 +97,14 @@ namespace Gendarme.Rules.Gendarme {
 					MethodReference m = (instruction.Operand as MethodReference);
 					if (m == null)
 						continue;
-					string declaringType = m.DeclaringType.FullName;
-					if (!engines.Contains (declaringType) || declaredEngines.Contains(declaringType))
+
+					TypeReference dtype = m.DeclaringType;
+					// short-cut to avoid FullName - will work as long as all Engines comes from the same namespace (otherwise remove it)
+					if (dtype.Namespace != "Gendarme.Framework.Engines")
+						continue;
+
+					string declaringType = dtype.GetFullName ();
+					if (!engines.Contains (declaringType) || declaredEngines.Contains (declaringType))
 						continue;
 					Runner.Report (method, instruction, Severity.High, Confidence.High, 
 						"An engine " + declaringType + " is being used without type being subscribed to it with EngineDependency attribute.");
@@ -107,27 +115,28 @@ namespace Gendarme.Rules.Gendarme {
 			return Runner.CurrentRuleResult;
 		}
 
-		private HashSet<string> GetEngineDependencyValue (TypeDefinition type)
+		private void GetEngineDependencyValue (TypeDefinition type)
 		{
-			HashSet<string> retval = new HashSet<string> ();
+			declaredEngines.Clear ();
 			TypeDefinition td = type;
-			while (retval.Count < engines.Count) {
+			while (declaredEngines.Count < engines.Count) {
 				if (td.HasCustomAttributes)
 					foreach (CustomAttribute attribute in td.CustomAttributes) {
 						if (!attribute.HasConstructorArguments ||
-							attribute.AttributeType.FullName != "Gendarme.Framework.EngineDependencyAttribute")
+							!attribute.AttributeType.IsNamed ("Gendarme.Framework", "EngineDependencyAttribute"))
 							continue;
-						// ToString for both constuctors (Type and String) will return the type name we need
-						retval.Add (attribute.ConstructorArguments [0].Value.ToString ());
+
+						object value = attribute.ConstructorArguments [0].Value;
+						MemberReference mr = (value as MemberReference);
+						declaredEngines.Add (mr == null ? value.ToString () : mr.GetFullName ());
 					}
 				if (td.BaseType == null)
 					break;
-				TypeDefinition baseType = td.BaseType.Resolve();
+				TypeDefinition baseType = td.BaseType.Resolve ();
 				if (baseType == null)
 					break;
 				td = baseType;
 			}
-			return retval;
 		}
 	}
 }
diff --git a/gendarme/rules/Gendarme.Rules.Gendarme/README.md b/gendarme/rules/Gendarme.Rules.Gendarme/README.md
new file mode 100644
index 0000000..fe4ec4e
--- /dev/null
+++ b/gendarme/rules/Gendarme.Rules.Gendarme/README.md
@@ -0,0 +1,9 @@
+# Gendarme.Rules.Gendarme Rules
+
+You can access the latest rules documentation from our [[wiki|https://github.com/spouliot/gendarme/wiki/Gendarme.Rules.Gendarme(git)]] pages.
+
+
+## Feedback
+
+Please report any documentation errors, typos or suggestions to the [[Gendarme Mailing List|https://groups.google.com/forum/?fromgroups#!forum/gendarme]]. Thanks!
+
diff --git a/gendarme/rules/Gendarme.Rules.Gendarme/ReviewAttributesOnRulesRule.cs b/gendarme/rules/Gendarme.Rules.Gendarme/ReviewAttributesOnRulesRule.cs
index 7bb8b35..3a15245 100644
--- a/gendarme/rules/Gendarme.Rules.Gendarme/ReviewAttributesOnRulesRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Gendarme/ReviewAttributesOnRulesRule.cs
@@ -122,10 +122,14 @@ namespace Gendarme.Rules.Gendarme {
 				while (!foundSolution || !foundProblem) {
 					if (td.HasCustomAttributes)
 						foreach (CustomAttribute attribute in td.CustomAttributes) {
-							var attributeTypeName = attribute.AttributeType.FullName;
-							if (attributeTypeName == "Gendarme.Framework.SolutionAttribute")
+							TypeReference atype = attribute.AttributeType;
+							if (atype.Namespace != "Gendarme.Framework")
+								continue;
+
+							string name = atype.Name;
+							if (name == "SolutionAttribute")
 								foundSolution = true;
-							if (attributeTypeName == "Gendarme.Framework.ProblemAttribute")
+							else if (name == "ProblemAttribute")
 								foundProblem = true;
 						}
 
@@ -149,19 +153,19 @@ namespace Gendarme.Rules.Gendarme {
 				return;
 
 			foreach (CustomAttribute attribute in provider.CustomAttributes) {
-				var attributeTypeName = attribute.AttributeType.FullName;
+				var attributeTypeName = attribute.AttributeType.GetFullName ();
 				Action<CustomAttribute, ICustomAttributeProvider> f;
-				if (attributes.TryGetValue(attributeTypeName, out f))
+				if (attributes.TryGetValue (attributeTypeName, out f))
 					f (attribute, provider);
 			}
 		}
 
 		private bool IsRule (TypeReference type)
 		{
-			var typeName = type.FullName;
+			var typeName = type.GetFullName ();
 			bool result;
 			if (!typeIsRule.TryGetValue (typeName, out result)) {
-				result = type.Implements ("Gendarme.Framework.IRule");
+				result = type.Implements ("Gendarme.Framework", "IRule");
 				typeIsRule [typeName] = result;
 			}
 			return result;
@@ -182,7 +186,7 @@ namespace Gendarme.Rules.Gendarme {
 			// check if second argument has correct format
 			if (!attribute.HasConstructorArguments)
 				return;
-			var attributeTypeName = attribute.AttributeType.FullName;
+			var attributeTypeName = attribute.AttributeType.GetFullName ();
 			var argumentValue = attribute.ConstructorArguments [1].Value.ToString ();
 			var length = argumentValue.Length;
 			if (!((length == 6 || (length > 8 && argumentValue [6] == ':')) && 
@@ -199,7 +203,7 @@ namespace Gendarme.Rules.Gendarme {
 		private void CheckEngineDependencyAttribute (CustomAttribute attribute, ICustomAttributeProvider provider)
 		{
 			TypeDefinition td = (provider as TypeDefinition);
-			if (td == null || !(IsRule (td) || td.Implements ("Gendarme.Framework.IRunner")))
+			if (td == null || !(IsRule (td) || td.Implements ("Gendarme.Framework", "IRunner")))
 				Runner.Report (td, Severity.Medium, Confidence.High, "[EngineDependency] can only be used on rules and runners");
 
 			CheckIfStringArgumentsAreNotNullOrEmpty (attribute, provider);
@@ -209,9 +213,9 @@ namespace Gendarme.Rules.Gendarme {
 			var argument = attribute.ConstructorArguments [0];
 
 			// if possible, check if argument type implements IEngine
-			if (argument.Type.FullName == "System.Type") {
+			if (argument.Type.IsNamed ("System", "Type")) {
 				TypeReference tr = (argument.Value as TypeReference);
-				if (tr == null || !tr.Inherits ("Gendarme.Framework.Engine")) // IEngine does not exist yet
+				if (tr == null || !tr.Inherits ("Gendarme.Framework", "Engine")) // IEngine does not exist yet
 					Runner.Report (provider, Severity.Medium, Confidence.High,
 						"EngineDependency attribute argument should implement IEngine interface");
 
@@ -229,7 +233,7 @@ namespace Gendarme.Rules.Gendarme {
 			TypeDefinition td = (provider as TypeDefinition);
 			if (td == null || !IsRule (td))
 				Runner.Report (td, Severity.Medium, Confidence.High,
-					attribute.AttributeType.FullName + " can be used on rules only");
+					attribute.AttributeType.GetFullName () + " can be used on rules only");
 		}
 
 		private void CheckIfAttributeUsedOnRulesProperty (ICustomAttribute attribute, ICustomAttributeProvider provider)
@@ -238,7 +242,7 @@ namespace Gendarme.Rules.Gendarme {
 			if (property == null || !IsRule (property.DeclaringType) || 
 				!property.GetMethod.IsPublic || !property.SetMethod.IsPublic)
 				Runner.Report (provider, Severity.High, Confidence.High,
-					attribute.AttributeType.FullName + " should be used only on rules' public properties");
+					attribute.AttributeType.GetFullName () + " should be used only on rules' public properties");
 		}
 
 		// returns true when all arguments are fine, false otherwise
@@ -247,11 +251,11 @@ namespace Gendarme.Rules.Gendarme {
 			if (!attribute.HasConstructorArguments)
 				return true;
 			foreach (CustomAttributeArgument argument in attribute.ConstructorArguments) {
-				if (argument.Type.FullName != "System.String")
+				if (!argument.Type.IsNamed ("System", "String"))
 					continue;
 				if (String.IsNullOrEmpty ((string) argument.Value)) {
 					Runner.Report (provider, Severity.Medium, Confidence.High,
-						attribute.AttributeType.FullName + " argument cannot be null or empty");
+						attribute.AttributeType.GetFullName () + " argument cannot be null or empty");
 					return false;
 				}
 			}
diff --git a/gendarme/rules/Gendarme.Rules.Gendarme/Test/Tests.Rules.Gendarme.csproj b/gendarme/rules/Gendarme.Rules.Gendarme/Test/Tests.Rules.Gendarme.csproj
index fd9873f..877d2b7 100755
--- a/gendarme/rules/Gendarme.Rules.Gendarme/Test/Tests.Rules.Gendarme.csproj
+++ b/gendarme/rules/Gendarme.Rules.Gendarme/Test/Tests.Rules.Gendarme.csproj
@@ -1,79 +1,118 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <PropertyGroup>
-    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
-    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
-    <ProductVersion>9.0.30729</ProductVersion>
-    <SchemaVersion>2.0</SchemaVersion>
-    <ProjectGuid>{C329FF89-4C07-4D72-AF5B-70B10670CB36}</ProjectGuid>
-    <OutputType>Library</OutputType>
-    <AppDesignerFolder>Properties</AppDesignerFolder>
-    <RootNamespace>Tests.Rules.Gendarme</RootNamespace>
-    <AssemblyName>Tests.Rules.Gendarme</AssemblyName>
-    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
-    <FileAlignment>512</FileAlignment>
-  </PropertyGroup>
-  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
-    <DebugSymbols>true</DebugSymbols>
-    <DebugType>full</DebugType>
-    <Optimize>false</Optimize>
-    <OutputPath>bin\Debug\</OutputPath>
-    <DefineConstants>DEBUG;TRACE</DefineConstants>
-    <ErrorReport>prompt</ErrorReport>
-    <WarningLevel>4</WarningLevel>
-  </PropertyGroup>
-  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
-    <DebugType>pdbonly</DebugType>
-    <Optimize>true</Optimize>
-    <OutputPath>bin\Release\</OutputPath>
-    <DefineConstants>TRACE</DefineConstants>
-    <ErrorReport>prompt</ErrorReport>
-    <WarningLevel>4</WarningLevel>
-  </PropertyGroup>
-  <ItemGroup>
-    <Reference Include="nunit.framework, Version=2.4.8.0, Culture=neutral, PublicKeyToken=96d09a1eb7f44a77, processorArchitecture=MSIL">
-      <SpecificVersion>False</SpecificVersion>
-      <HintPath>..\..\..\..\..\cecil\Test\libs\nunit-2.4.8\nunit.framework.dll</HintPath>
-    </Reference>
-    <Reference Include="System" />
-    <Reference Include="System.Core">
-      <RequiredTargetFramework>3.5</RequiredTargetFramework>
-    </Reference>
-  </ItemGroup>
-  <ItemGroup>
-    <Compile Include="DefectsMustBeReportedTest.cs" />
-    <Compile Include="DoNotThrowExceptionTest.cs" />
-    <Compile Include="MissingEngineDependencyTest.cs" />
-    <Compile Include="ReviewAttributesOnRulesTest.cs" />
-    <Compile Include="UseCorrectSuffixTest.cs" />
-  </ItemGroup>
-  <ItemGroup>
-    <ProjectReference Include="..\..\..\..\..\cecil\Mono.Cecil.csproj">
-      <Project>{D68133BD-1E63-496E-9EDE-4FBDBF77B486}</Project>
-      <Name>Mono.Cecil</Name>
-    </ProjectReference>
-    <ProjectReference Include="..\..\..\framework\Gendarme.Framework.csproj">
-      <Project>{CD6818D5-B398-486C-B180-92A07B143AFD}</Project>
-      <Name>Gendarme.Framework</Name>
-    </ProjectReference>
-    <ProjectReference Include="..\..\Test.Rules\Test.Rules.csproj">
-      <Project>{069148AF-86AB-4EE3-BFB9-429AE722461F}</Project>
-      <Name>Test.Rules</Name>
-    </ProjectReference>
-    <ProjectReference Include="..\Gendarme.Rules.Gendarme.csproj">
-      <Project>{619CDBD4-D89E-47E1-9A82-0F194A665D48}</Project>
-      <Name>Gendarme.Rules.Gendarme</Name>
-    </ProjectReference>
-  </ItemGroup>
-  <ItemGroup>
-    <Folder Include="Properties\" />
-  </ItemGroup>
-  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
+    <ProductVersion>9.0.30729</ProductVersion>
+    <SchemaVersion>2.0</SchemaVersion>
+    <ProjectGuid>{C329FF89-4C07-4D72-AF5B-70B10670CB36}</ProjectGuid>
+    <OutputType>Library</OutputType>
+    <AppDesignerFolder>Properties</AppDesignerFolder>
+    <RootNamespace>Tests.Rules.Gendarme</RootNamespace>
+    <AssemblyName>Tests.Rules.Gendarme</AssemblyName>
+    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
+    <FileAlignment>512</FileAlignment>
+    <FileUpgradeFlags>
+    </FileUpgradeFlags>
+    <OldToolsVersion>3.5</OldToolsVersion>
+    <UpgradeBackupLocation />
+    <PublishUrl>publish\</PublishUrl>
+    <Install>true</Install>
+    <InstallFrom>Disk</InstallFrom>
+    <UpdateEnabled>false</UpdateEnabled>
+    <UpdateMode>Foreground</UpdateMode>
+    <UpdateInterval>7</UpdateInterval>
+    <UpdateIntervalUnits>Days</UpdateIntervalUnits>
+    <UpdatePeriodically>false</UpdatePeriodically>
+    <UpdateRequired>false</UpdateRequired>
+    <MapFileExtensions>true</MapFileExtensions>
+    <ApplicationRevision>0</ApplicationRevision>
+    <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
+    <IsWebBootstrapper>false</IsWebBootstrapper>
+    <UseApplicationTrust>false</UseApplicationTrust>
+    <BootstrapperEnabled>true</BootstrapperEnabled>
+    <TargetFrameworkProfile />
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
+    <DebugSymbols>true</DebugSymbols>
+    <DebugType>full</DebugType>
+    <Optimize>false</Optimize>
+    <OutputPath>bin\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
+    <DebugType>pdbonly</DebugType>
+    <Optimize>true</Optimize>
+    <OutputPath>bin\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
+  </PropertyGroup>
+  <ItemGroup>
+    <Reference Include="nunit.framework, Version=2.4.8.0, Culture=neutral, PublicKeyToken=96d09a1eb7f44a77, processorArchitecture=MSIL">
+      <SpecificVersion>False</SpecificVersion>
+      <HintPath>..\..\..\..\..\cecil\Test\libs\nunit-2.4.8\nunit.framework.dll</HintPath>
+    </Reference>
+    <Reference Include="System" />
+    <Reference Include="System.Core">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+  </ItemGroup>
+  <ItemGroup>
+    <Compile Include="DefectsMustBeReportedTest.cs" />
+    <Compile Include="DoNotThrowExceptionTest.cs" />
+    <Compile Include="MissingEngineDependencyTest.cs" />
+    <Compile Include="ReviewAttributesOnRulesTest.cs" />
+    <Compile Include="UseCorrectSuffixTest.cs" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\..\..\..\..\cecil\Mono.Cecil.csproj">
+      <Project>{D68133BD-1E63-496E-9EDE-4FBDBF77B486}</Project>
+      <Name>Mono.Cecil</Name>
+    </ProjectReference>
+    <ProjectReference Include="..\..\..\framework\Gendarme.Framework.csproj">
+      <Project>{CD6818D5-B398-486C-B180-92A07B143AFD}</Project>
+      <Name>Gendarme.Framework</Name>
+    </ProjectReference>
+    <ProjectReference Include="..\..\Test.Rules\Test.Rules.csproj">
+      <Project>{069148AF-86AB-4EE3-BFB9-429AE722461F}</Project>
+      <Name>Test.Rules</Name>
+    </ProjectReference>
+    <ProjectReference Include="..\Gendarme.Rules.Gendarme.csproj">
+      <Project>{619CDBD4-D89E-47E1-9A82-0F194A665D48}</Project>
+      <Name>Gendarme.Rules.Gendarme</Name>
+    </ProjectReference>
+  </ItemGroup>
+  <ItemGroup>
+    <Folder Include="Properties\" />
+  </ItemGroup>
+  <ItemGroup>
+    <BootstrapperPackage Include="Microsoft.Net.Client.3.5">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1 Client Profile</ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Windows.Installer.3.1">
+      <Visible>False</Visible>
+      <ProductName>Windows Installer 3.1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+  </ItemGroup>
+  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
   <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
        Other similar extension points exist, see Microsoft.Common.targets.
   <Target Name="BeforeBuild">
   </Target>
   <Target Name="AfterBuild">
   </Target>
-  -->
+  -->
 </Project>
\ No newline at end of file
diff --git a/gendarme/rules/Gendarme.Rules.Gendarme/UseCorrectSuffixRule.cs b/gendarme/rules/Gendarme.Rules.Gendarme/UseCorrectSuffixRule.cs
index 18da8c3..5c4bf7d 100644
--- a/gendarme/rules/Gendarme.Rules.Gendarme/UseCorrectSuffixRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Gendarme/UseCorrectSuffixRule.cs
@@ -71,7 +71,7 @@ namespace Gendarme.Rules.Gendarme {
 		public RuleResult CheckType (TypeDefinition type)
 		{
 			bool endsWithRule = type.Name.EndsWith ("Rule", StringComparison.Ordinal);
-			bool implementsIRule = type.Implements ("Gendarme.Framework.IRule");
+			bool implementsIRule = type.Implements ("Gendarme.Framework", "IRule");
 
 			if (implementsIRule && !endsWithRule)
 				Runner.Report (type, Severity.Medium, Confidence.High, "Type implements IRule but does not end with the 'Rule'");
diff --git a/gendarme/rules/Gendarme.Rules.Globalization/AvoidUnusedInternalResourceRule.cs b/gendarme/rules/Gendarme.Rules.Globalization/AvoidUnusedInternalResourceRule.cs
index 937be0b..b29cbdc 100644
--- a/gendarme/rules/Gendarme.Rules.Globalization/AvoidUnusedInternalResourceRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Globalization/AvoidUnusedInternalResourceRule.cs
@@ -44,12 +44,6 @@ namespace Gendarme.Rules.Globalization {
 	[Solution ("Remove the unused resource or add code to call it.")]
 	public class AvoidUnusedInternalResourceRule : Rule, IMethodRule {
 
-		private static readonly string [] resXAttributes = {
-			"System.CodeDom.Compiler.GeneratedCodeAttribute",
-			"System.Diagnostics.DebuggerNonUserCodeAttribute",
-			"System.Runtime.CompilerServices.CompilerGeneratedAttribute"
-		};
-
 		static private bool Applicable (MethodDefinition method)
 		{
 			// only internal resources
@@ -71,11 +65,14 @@ namespace Gendarme.Rules.Globalization {
 			if (!typeDefinition.HasCustomAttributes)
 				return false;
 
-			var attributes = typeDefinition.CustomAttributes;
-			if (!resXAttributes.All (a => attributes.ContainsType (a)))
-				return false;
+			if (typeDefinition.HasAttribute ("System.CodeDom.Compiler", "GeneratedCodeAttribute"))
+				return true;
+			if (typeDefinition.HasAttribute ("System.Diagnostics", "DebuggerNonUserCodeAttribute"))
+				return true;
+			if (typeDefinition.HasAttribute ("System.Runtime.CompilerServices", "CompilerGeneratedAttribute"))
+				return true;
 
-			return true;
+			return false;
 		}
 
 		public RuleResult CheckMethod (MethodDefinition method)
@@ -167,7 +164,7 @@ namespace Gendarme.Rules.Globalization {
 					continue;
 
 				TypeReference type = mr.DeclaringType;
-				if (!(type is ArrayType)) {
+				if (!type.IsArray) {
 					// if (type.GetElementType ().HasGenericParameters)
 					// the simpler ^^^ does not work under Mono but works on MS
 					type = type.Resolve ();
diff --git a/gendarme/rules/Gendarme.Rules.Globalization/Gendarme.Rules.Globalization.csproj b/gendarme/rules/Gendarme.Rules.Globalization/Gendarme.Rules.Globalization.csproj
index 55a74d3..f99c3b8 100644
--- a/gendarme/rules/Gendarme.Rules.Globalization/Gendarme.Rules.Globalization.csproj
+++ b/gendarme/rules/Gendarme.Rules.Globalization/Gendarme.Rules.Globalization.csproj
@@ -1,5 +1,5 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
     <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
@@ -10,8 +10,28 @@
     <AppDesignerFolder>Properties</AppDesignerFolder>
     <RootNamespace>Gendarme.Rules.Globalization</RootNamespace>
     <AssemblyName>Gendarme.Rules.Globalization</AssemblyName>
-    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
     <FileAlignment>512</FileAlignment>
+    <FileUpgradeFlags>
+    </FileUpgradeFlags>
+    <OldToolsVersion>3.5</OldToolsVersion>
+    <UpgradeBackupLocation />
+    <PublishUrl>publish\</PublishUrl>
+    <Install>true</Install>
+    <InstallFrom>Disk</InstallFrom>
+    <UpdateEnabled>false</UpdateEnabled>
+    <UpdateMode>Foreground</UpdateMode>
+    <UpdateInterval>7</UpdateInterval>
+    <UpdateIntervalUnits>Days</UpdateIntervalUnits>
+    <UpdatePeriodically>false</UpdatePeriodically>
+    <UpdateRequired>false</UpdateRequired>
+    <MapFileExtensions>true</MapFileExtensions>
+    <ApplicationRevision>0</ApplicationRevision>
+    <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
+    <IsWebBootstrapper>false</IsWebBootstrapper>
+    <UseApplicationTrust>false</UseApplicationTrust>
+    <BootstrapperEnabled>true</BootstrapperEnabled>
+    <TargetFrameworkProfile />
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
     <DebugSymbols>true</DebugSymbols>
@@ -22,6 +42,7 @@
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
     <DocumentationFile>..\..\console\bin\Debug\Gendarme.Rules.Globalization.xml</DocumentationFile>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
     <DebugType>pdbonly</DebugType>
@@ -31,6 +52,7 @@
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
     <DocumentationFile>..\..\console\bin\Release\Gendarme.Rules.Globalization.xml</DocumentationFile>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <ItemGroup>
     <Reference Include="System" />
@@ -58,6 +80,23 @@
   <ItemGroup>
     <Folder Include="Properties\" />
   </ItemGroup>
+  <ItemGroup>
+    <BootstrapperPackage Include="Microsoft.Net.Client.3.5">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1 Client Profile</ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Windows.Installer.3.1">
+      <Visible>False</Visible>
+      <ProductName>Windows Installer 3.1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+  </ItemGroup>
   <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
   <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
        Other similar extension points exist, see Microsoft.Common.targets.
diff --git a/gendarme/rules/Gendarme.Rules.Globalization/Makefile.am b/gendarme/rules/Gendarme.Rules.Globalization/Makefile.am
index 18c47d0..d1c1daa 100644
--- a/gendarme/rules/Gendarme.Rules.Globalization/Makefile.am
+++ b/gendarme/rules/Gendarme.Rules.Globalization/Makefile.am
@@ -2,6 +2,9 @@ include ../common.make
 
 rules_sources =  \
 	AvoidUnusedInternalResourceRule.cs \
+	PreferIFormatProviderOverrideRule.cs \
+	PreferOverrideBaseRule.cs \
+	PreferStringComparisonOverrideRule.cs \
 	SatelliteResourceMismatchRule.cs
 
 EXTRA_TESTS_OPTIONS += -r:System.Drawing -d:DEBUG -resource:Test/Resource.resources -resource:Test/InternalResource.resources \
@@ -50,6 +53,8 @@ EXTRA_TESTS_DEPS = Test/Resource.resources Test/InternalResource.resources Test/
 
 tests_sources = \
 	AvoidUnusedInternalResourceTest.cs \
+	PreferIFormatProviderOverrideTest.cs \
+	PreferStringComparisonOverrideTest.cs \
 	SatelliteResourceMismatchTest.cs \
 	Resource.Designer.cs \
 	InternalResource.Designer.cs \
diff --git a/gendarme/rules/Gendarme.Rules.Globalization/PreferIFormatProviderOverrideRule.cs b/gendarme/rules/Gendarme.Rules.Globalization/PreferIFormatProviderOverrideRule.cs
new file mode 100644
index 0000000..6a63c4f
--- /dev/null
+++ b/gendarme/rules/Gendarme.Rules.Globalization/PreferIFormatProviderOverrideRule.cs
@@ -0,0 +1,111 @@
+//
+// Gendarme.Rules.Globalization.PreferIFormatProviderOverrideRule
+//
+// Authors:
+//	Sebastien Pouliot <sebastien@ximian.com>
+//
+// Copyright (C) 2011 Novell, Inc (http://www.novell.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Globalization;
+
+using Mono.Cecil;
+using Mono.Cecil.Cil;
+using Gendarme.Framework;
+using Gendarme.Framework.Rocks;
+
+namespace Gendarme.Rules.Globalization {
+
+	/// <summary>
+	/// This rule detects calls to method that could be changed to call an <c>override</c> accepting an
+	/// extra <c>System.IFormatProvider</c> or <c>System.Globalization.CultureInfo</c> parameter (the
+	/// later implements <c>System.IFormatProvider</c>).
+	/// Generally data displayed to the end user should be using 
+	/// <c>System.Globalization.CultureInfo.CurrentCulture</c> while other data (e.g. used internally,
+	/// stored in files/databases) should use <c>System.Globalization.CultureInfo.InvariantCulture</c>.
+	/// The rule will ignore the following special methods:
+	/// <list>
+	/// <item><c>System.Activator.CreateInstance</c></item>
+	/// <item><c>System.Resources.ResourceManager.GetObject</c></item>
+	/// <item><c>System.Resources.ResourceManager.GetString</c></item>
+	/// </list>
+	/// </summary>
+	/// <example>
+	/// Bad example:
+	/// <code>
+	/// public bool Confirm (double amount)
+	/// {
+	///	string msg = String.Format ("Accept payment of {0} ?", amount);
+	///	Transaction.Log ("{0} {1}", DateTime.Now, amount);
+	///	return Prompt (msg);
+	/// }
+	/// </code>
+	/// </example>
+	/// <example>
+	/// Good example:
+	/// <code>
+	/// public bool Confirm (double amount)
+	/// {
+	///	string msg = String.Format (CultureInfo.CurrentCulture, "Accept payment of {0} ?", amount);
+	///	Transaction.Log (CultureInfo.InvariantCulture, "{0} {1}", DateTime.Now, amount);
+	///	return Prompt (msg);
+	/// }
+	/// </code>
+	/// </example>
+	[Problem ("A call is made to a method for which an override, accepting an extra IFormatProvider or CultureInfo, is available")]
+	[Solution ("Specify how the string should be compared by adding the right IFormatProvider/CultureInfo value to the call")]
+	[FxCopCompatibility ("Microsoft.Globalization", "CA1304:SpecifyCultureInfo")]
+	[FxCopCompatibility ("Microsoft.Globalization", "CA1305:SpecifyIFormatProvider")]
+	public class PreferIFormatProviderOverrideRule : PreferOverrideBaseRule {
+
+		protected override bool CheckFirstParameter
+		{
+			get { return true; }
+		}
+
+		protected override bool IsPrefered (TypeReference type)
+		{
+			return (type.IsNamed ("System", "IFormatProvider") || type.IsNamed ("System.Globalization", "CultureInfo"));
+		}
+
+		protected override bool IsSpecialCase (MethodReference method)
+		{
+			if ((method == null) || method.IsNamed ("System", "Activator", "CreateInstance"))
+				return true;
+
+			TypeReference type = method.DeclaringType;
+			if (!type.IsNamed ("System.Resources", "ResourceManager"))
+				return false;
+
+			string name = method.Name;
+			return (name == "GetObject" || name == "GetString");
+		}
+
+		protected override void Report (MethodDefinition method, Instruction instruction, MethodReference prefered)
+		{
+			string msg = String.Format (CultureInfo.InvariantCulture,
+				"Consider using the perfered '{0}' override.", prefered.GetFullName ());
+			Runner.Report (method, instruction, Severity.Medium, Confidence.High, msg);
+		}
+	}
+}
diff --git a/gendarme/rules/Gendarme.Rules.Globalization/PreferOverrideBaseRule.cs b/gendarme/rules/Gendarme.Rules.Globalization/PreferOverrideBaseRule.cs
new file mode 100644
index 0000000..020e0e4
--- /dev/null
+++ b/gendarme/rules/Gendarme.Rules.Globalization/PreferOverrideBaseRule.cs
@@ -0,0 +1,170 @@
+//
+// Gendarme.Rules.Globalization.PreferOverrideBaseRule
+//
+// Authors:
+//	Sebastien Pouliot <sebastien@ximian.com>
+//
+// Copyright (C) 2011 Novell, Inc (http://www.novell.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Collections.Generic;
+
+using Mono.Cecil;
+using Mono.Cecil.Cil;
+using Mono.Collections.Generic;
+
+using Gendarme.Framework;
+using Gendarme.Framework.Engines;
+using Gendarme.Framework.Helpers;
+using Gendarme.Framework.Rocks;
+
+namespace Gendarme.Rules.Globalization {
+
+	[EngineDependency (typeof (OpCodeEngine))]
+	public abstract class PreferOverrideBaseRule : Rule, IMethodRule {
+
+		protected virtual bool CheckFirstParameter {
+			get { return false; }
+		}
+
+		protected abstract bool IsPrefered (TypeReference type);
+
+		protected virtual bool IsSpecialCase (MethodReference method)
+		{
+			return (method == null);
+		}
+
+		protected abstract void Report (MethodDefinition method, Instruction instruction, MethodReference prefered);
+
+		static bool MatchParameters (Collection<ParameterDefinition> pmethod, Collection<ParameterDefinition> candidate, int offset)
+		{
+			int ccount = candidate.Count - offset;
+			int count = Math.Min (pmethod.Count, ccount - offset);
+			for (int i = 0; i < count; i++) {
+				ParameterDefinition pd = candidate [i + offset];
+				if (pd.IsParams ())
+					return true;
+				TypeReference ptype = pd.ParameterType;
+				if (!pmethod [i].ParameterType.IsNamed (ptype.Namespace, ptype.Name))
+					return false;
+			}
+			return (ccount - count <= 1);
+		}
+
+		// look for a signature identical to ours but that accept an extra parameter
+		MethodReference LookForPreferredOverride (MethodReference method)
+		{
+			TypeDefinition type = method.DeclaringType.Resolve ();
+			if (type == null)
+				return null;
+
+			var methods = type.Methods;
+			// we already know that, if resolved, there's at least one method (the caller)
+			// so there's no need to call HasMethods
+			if (methods.Count == 1)
+				return null;
+
+			string name = method.Name;
+			int pcount = 0;
+			Collection<ParameterDefinition> mparams = null;
+			if (method.HasParameters) {
+				mparams = method.Parameters;
+				pcount = mparams.Count;
+			}
+
+			foreach (MethodDefinition md in methods) {
+				// has one more parameter, so non-zero
+				if (!md.HasParameters)
+					continue;
+
+				Collection<ParameterDefinition> pdc = md.Parameters;
+				if (name != md.Name)
+					continue;
+
+				// compare parameters and return value
+				TypeReference rtype = md.ReturnType;
+				if (!method.ReturnType.IsNamed (rtype.Namespace, rtype.Name))
+					continue;
+
+				// last parameter could be our "prefered" type
+				if (IsPrefered (pdc [pdc.Count - 1].ParameterType)) {
+					// special case where the method has no parameter, override has only one (the prefered)
+					if ((pcount == 0) && (mparams == null))
+						return md;
+					if (MatchParameters (mparams, pdc, 0))
+						return md;
+				} else if (CheckFirstParameter && IsPrefered (pdc [0].ParameterType)) {
+					if (MatchParameters (mparams, pdc, 1))
+						return md;
+				}
+			}
+			return null;
+		}
+
+		Dictionary<MethodReference, MethodReference> prefered_overloads = new Dictionary<MethodReference, MethodReference> ();
+
+		MethodReference GetPreferedOverride (MethodReference method)
+		{
+			MethodReference prefered = null;
+			if (!prefered_overloads.TryGetValue (method, out prefered)) {
+				prefered = LookForPreferredOverride (method);
+				prefered_overloads.Add (method, prefered);
+			}
+			return prefered;
+		}
+
+		public RuleResult CheckMethod (MethodDefinition method)
+		{
+			if (!method.HasBody)
+				return RuleResult.DoesNotApply;
+
+			// exclude methods that don't have calls
+			if (!OpCodeBitmask.Calls.Intersect (OpCodeEngine.GetBitmask (method)))
+				return RuleResult.DoesNotApply;
+
+			foreach (Instruction ins in method.Body.Instructions) {
+				MethodReference mr = ins.GetMethod ();
+				// some inheritors have special cases to deal with
+				if (IsSpecialCase (mr))
+					continue;
+
+				// check if the call starts or ends with our 'prefered' override
+				if (mr.HasParameters) {
+					Collection<ParameterDefinition> pdc = mr.Parameters;
+					if (CheckFirstParameter && IsPrefered (pdc [0].ParameterType))
+						continue;
+					if (IsPrefered (pdc [pdc.Count - 1].ParameterType))
+						continue;
+				}
+
+				// if not check if such a 'prefered' override exists to replace the called method
+				MethodReference prefered = GetPreferedOverride (mr);
+				if (prefered != null)
+					Report (method, ins, prefered);
+			}
+
+			return Runner.CurrentRuleResult;
+		}
+	}
+}
+
diff --git a/gendarme/rules/Gendarme.Rules.Globalization/PreferStringComparisonOverrideRule.cs b/gendarme/rules/Gendarme.Rules.Globalization/PreferStringComparisonOverrideRule.cs
new file mode 100644
index 0000000..3ed3dfa
--- /dev/null
+++ b/gendarme/rules/Gendarme.Rules.Globalization/PreferStringComparisonOverrideRule.cs
@@ -0,0 +1,82 @@
+//
+// Gendarme.Rules.Globalization.PreferStringComparisonOverrideRule
+//
+// Authors:
+//	Sebastien Pouliot <sebastien@ximian.com>
+//
+// Copyright (C) 2011 Novell, Inc (http://www.novell.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Globalization;
+
+using Mono.Cecil;
+using Mono.Cecil.Cil;
+using Gendarme.Framework;
+using Gendarme.Framework.Rocks;
+
+namespace Gendarme.Rules.Globalization {
+
+	/// <summary>
+	/// This rule detects calls to method that could be changed to call an <c>override</c> accepting an
+	/// extra <c>System.StringComparison</c> parameter. Using the <c>override</c> makes the code easier
+	/// to maintain since it makes the intent clear on how the string needs to be compared.
+	/// It is even more important since the default string comparison rules have changed between
+	/// .NET 2.0 and .NET 4.0.
+	/// </summary>
+	/// <example>
+	/// Bad example:
+	/// <code>
+	/// public bool Check (string name)
+	/// {
+	///	// it's not clear if the string comparison should be culture sensitive or not
+	///	return (String.Compare (name, "Software") == 0);
+	/// }
+	/// </code>
+	/// </example>
+	/// <example>
+	/// Good example:
+	/// <code>
+	/// public bool Check (string name)
+	/// {
+	///	return (String.Compare (name, "Software", StringComparison.CurrentCulture) == 0);
+	/// }
+	/// </code>
+	/// </example>
+	[Problem ("A call is made to a method for which an override, accepting an extra StringComparison, is available")]
+	[Solution ("Specify how the string should be compared by adding the right StringComparison value to the call")]
+	[FxCopCompatibility ("Microsoft.Globalization", "CA1307:SpecifyStringComparison")]
+	public class PreferStringComparisonOverrideRule : PreferOverrideBaseRule {
+
+		protected override bool IsPrefered (TypeReference type)
+		{
+			return type.IsNamed ("System", "StringComparison");
+		}
+
+		protected override void Report (MethodDefinition method, Instruction instruction, MethodReference prefered)
+		{
+			string msg = String.Format (CultureInfo.InvariantCulture, 
+				"Consider using the perfered '{0}' override.", prefered.GetFullName ());
+			Runner.Report (method, instruction, Severity.Medium, Confidence.High, msg);
+		}
+	}
+}
diff --git a/gendarme/rules/Gendarme.Rules.Globalization/README.md b/gendarme/rules/Gendarme.Rules.Globalization/README.md
new file mode 100644
index 0000000..9c08b48
--- /dev/null
+++ b/gendarme/rules/Gendarme.Rules.Globalization/README.md
@@ -0,0 +1,9 @@
+# Gendarme.Rules.Globalization Rules
+
+You can access the latest rules documentation from our [[wiki|https://github.com/spouliot/gendarme/wiki/Gendarme.Rules.Globalization(git)]] pages.
+
+
+## Feedback
+
+Please report any documentation errors, typos or suggestions to the [[Gendarme Mailing List|https://groups.google.com/forum/?fromgroups#!forum/gendarme]]. Thanks!
+
diff --git a/gendarme/rules/Gendarme.Rules.Globalization/SatelliteResourceMismatchRule.cs b/gendarme/rules/Gendarme.Rules.Globalization/SatelliteResourceMismatchRule.cs
index 86af3a4..5829b97 100644
--- a/gendarme/rules/Gendarme.Rules.Globalization/SatelliteResourceMismatchRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Globalization/SatelliteResourceMismatchRule.cs
@@ -27,6 +27,7 @@
 //
 
 using System;
+using System.Globalization;
 using System.IO;
 using System.Text;
 using System.Resources;
@@ -81,8 +82,10 @@ namespace Gendarme.Rules.Globalization {
 				EmbeddedResource mainResource;
 				string resourceName = GetNameInSatellite (resource, culture);
 				if (!mainAssemblyResourceCache.TryGetMainResourceFile (resourceName, out mainResource)) {
-					Runner.Report (satellite, Severity.Low, Confidence.High,
-						String.Format ("The resource file {0} exist in the satellite assembly but not in the main assembly", resource.Name));
+					string msg = String.Format (CultureInfo.InvariantCulture, 
+						"The resource file {0} exist in the satellite assembly but not in the main assembly", 
+						resource.Name);
+					Runner.Report (satellite, Severity.Low, Confidence.High, msg);
 					continue;
 				}
 
@@ -102,16 +105,20 @@ namespace Gendarme.Rules.Globalization {
 					object satelliteValue = entry.Value;
 					object mainValue;
 					if (!mainAssemblyResourceCache.TryGetMainResource (mainResource, resourceName, out mainValue)) {
-						Runner.Report (satelliteAssembly, Severity.Low, Confidence.High,
-							String.Format ("The resource {0} in the file {1} exist in the satellite assembly but not in the main assembly", resourceName, satelliteResource.Name));
+						string msg = String.Format (CultureInfo.InvariantCulture, 
+							"The resource {0} in the file {1} exist in the satellite assembly but not in the main assembly", 
+							resourceName, satelliteResource.Name);
+						Runner.Report (satelliteAssembly, Severity.Low, Confidence.High, msg);
 						continue;
 					}
 
 					Type satelliteType = satelliteValue.GetType ();
 					Type mainType = mainValue.GetType ();
 					if (!satelliteType.Equals (mainType)) {
-						Runner.Report (satelliteAssembly, Severity.High, Confidence.High,
-							String.Format ("The resource {0} in the file {1} is of type {2} in the satellite assembly but of type {3} in the main assembly", resourceName, satelliteResource.Name, satelliteType, mainType));
+						string msg = String.Format (CultureInfo.InvariantCulture, 
+							"The resource {0} in the file {1} is of type {2} in the satellite assembly but of type {3} in the main assembly", 
+							resourceName, satelliteResource.Name, satelliteType, mainType);
+						Runner.Report (satelliteAssembly, Severity.High, Confidence.High, msg);
 						continue;
 					}
 
@@ -119,9 +126,12 @@ namespace Gendarme.Rules.Globalization {
 						Bitmask<int> mainParameters = GetStringFormatExpectedParameters ((string) mainValue);
 						Bitmask<int> satelliteParameters = GetStringFormatExpectedParameters ((string) satelliteValue);
 
-						if (!mainParameters.Equals (satelliteParameters))
-							Runner.Report (satelliteAssembly, Severity.High, Confidence.Normal,
-								String.Format ("The string resource {0} in the file {1} does not use the same string format parameters in the satellite and main assemblies", resourceName, satelliteResource.Name));
+						if (!mainParameters.Equals (satelliteParameters)) {
+							string msg = String.Format (CultureInfo.InvariantCulture, 
+								"The string resource {0} in the file {1} does not use the same string format parameters in the satellite and main assemblies", 
+								resourceName, satelliteResource.Name);
+							Runner.Report (satelliteAssembly, Severity.High, Confidence.Normal, msg);
+						}
 					}
 				}
 			}
@@ -203,7 +213,7 @@ namespace Gendarme.Rules.Globalization {
 
 			string cultureExtension = "." + culture;
 
-			if (!nameWithoutExtension.EndsWith (cultureExtension))
+			if (!nameWithoutExtension.EndsWith (cultureExtension, StringComparison.Ordinal))
 				return name;
 
 			string nameWithoutCulture = Path.GetFileNameWithoutExtension (nameWithoutExtension);
@@ -212,7 +222,7 @@ namespace Gendarme.Rules.Globalization {
 
 		private static bool IsResXResources (Resource resource)
 		{
-			return resource.Name.EndsWith (resXResourcesExtension);
+			return resource.Name.EndsWith (resXResourcesExtension, StringComparison.Ordinal);
 		}
 
 		private sealed class AssemblyResourceCache {
diff --git a/gendarme/rules/Gendarme.Rules.Globalization/Test/InternalResource.Designer.cs b/gendarme/rules/Gendarme.Rules.Globalization/Test/InternalResource.Designer.cs
index d99d5fe..fb95375 100644
--- a/gendarme/rules/Gendarme.Rules.Globalization/Test/InternalResource.Designer.cs
+++ b/gendarme/rules/Gendarme.Rules.Globalization/Test/InternalResource.Designer.cs
@@ -1,7 +1,7 @@
-﻿//------------------------------------------------------------------------------
+//------------------------------------------------------------------------------
 // <auto-generated>
 //     This code was generated by a tool.
-//     Runtime Version:2.0.50727.4952
+//     Runtime Version:4.0.30319.1
 //
 //     Changes to this file may cause incorrect behavior and will be lost if
 //     the code is regenerated.
@@ -19,7 +19,7 @@ namespace Tests.Rules.Globalization {
     // class via a tool like ResGen or Visual Studio.
     // To add or remove a member, edit your .ResX file then rerun ResGen
     // with the /str option, or rebuild your VS project.
-    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "2.0.0.0")]
+    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
     [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
     [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
     internal class InternalResource {
diff --git a/gendarme/rules/Gendarme.Rules.Globalization/Test/PreferIFormatProviderOverrideTest.cs b/gendarme/rules/Gendarme.Rules.Globalization/Test/PreferIFormatProviderOverrideTest.cs
new file mode 100644
index 0000000..83fa855
--- /dev/null
+++ b/gendarme/rules/Gendarme.Rules.Globalization/Test/PreferIFormatProviderOverrideTest.cs
@@ -0,0 +1,219 @@
+//
+// Unit tests for PreferIFormatProviderOverrideRule
+//
+// Authors:
+//	Sebastien Pouliot <sebastien@ximian.com>
+//
+// Copyright (C) 2011 Novell, Inc (http://www.novell.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Globalization;
+using System.Reflection;
+using System.Resources;
+
+using Gendarme.Rules.Globalization;
+using NUnit.Framework;
+
+using Test.Rules.Definitions;
+using Test.Rules.Fixtures;
+
+namespace Tests.Rules.Globalization {
+
+	class IFormatProviderTestCases {
+
+		public void Empty ()
+		{
+		}
+
+		public void Empty (IFormatProvider format)
+		{
+		}
+
+		public void BadEmpty ()
+		{
+			Empty ();
+		}
+
+		public void CorrectEmpty ()
+		{
+			Empty (null);
+		}
+
+		public void First (object obj)
+		{
+		}
+
+		public void First (IFormatProvider format, object obj)
+		{
+		}
+
+		public void BadFirst ()
+		{
+			First (null);
+		}
+
+		public void CorrectFirst ()
+		{
+			First (null, null);
+		}
+
+		public void Last (object obj)
+		{
+		}
+
+		public void Last (object obj, IFormatProvider format)
+		{
+		}
+
+		public void BadLast ()
+		{
+			Last (null);
+		}
+
+		public void CorrectLast ()
+		{
+			Last (null, null);
+		}
+	}
+
+	class CultureInfoTestCases {
+
+		public void Empty ()
+		{
+		}
+
+		public void Empty (CultureInfo info)
+		{
+		}
+
+		public void BadEmpty ()
+		{
+			Empty ();
+		}
+
+		public void CorrectEmpty ()
+		{
+			Empty (null);
+		}
+
+		public void First (object obj)
+		{
+		}
+
+		public void First (CultureInfo info, object obj)
+		{
+		}
+
+		public void BadFirst ()
+		{
+			First (null);
+		}
+
+		public void CorrectFirst ()
+		{
+			First (null, null);
+		}
+
+		public void Last (object obj)
+		{
+		}
+
+		public void Last (object obj, CultureInfo info)
+		{
+		}
+
+		public void BadLast ()
+		{
+			Last (null);
+		}
+
+		public void CorrectLast ()
+		{
+			Last (null, null);
+		}
+	}
+
+	[TestFixture]
+	public class PreferIFormatProviderOverrideTest : MethodRuleTestFixture<PreferIFormatProviderOverrideRule> {
+
+		[Test]
+		public void DoesNotApply ()
+		{
+			AssertRuleDoesNotApply (SimpleMethods.EmptyMethod);
+			AssertRuleDoesNotApply (SimpleMethods.ExternalMethod);
+		}
+
+		[Test]
+		public void Success ()
+		{
+			AssertRuleSuccess<IFormatProviderTestCases> ("CorrectEmpty");
+			AssertRuleSuccess<IFormatProviderTestCases> ("CorrectFirst");
+			AssertRuleSuccess<IFormatProviderTestCases> ("CorrectLast");
+
+			AssertRuleSuccess<CultureInfoTestCases> ("CorrectEmpty");
+			AssertRuleSuccess<CultureInfoTestCases> ("CorrectFirst");
+			AssertRuleSuccess<CultureInfoTestCases> ("CorrectLast");
+		}
+
+		[Test]
+		public void Failure ()
+		{
+			AssertRuleFailure<IFormatProviderTestCases> ("BadEmpty", 1);
+			AssertRuleFailure<IFormatProviderTestCases> ("BadFirst", 1);
+			AssertRuleFailure<IFormatProviderTestCases> ("BadLast", 1);
+
+			AssertRuleFailure<CultureInfoTestCases> ("BadEmpty", 1);
+			AssertRuleFailure<CultureInfoTestCases> ("BadFirst", 1);
+			AssertRuleFailure<CultureInfoTestCases> ("BadLast", 1);
+		}
+
+		void Ignored (ResourceManager rm)
+		{
+			rm.GetObject ("a");
+			rm.GetObject ("a", CultureInfo.CurrentCulture);
+			rm.GetString ("b");
+			rm.GetString ("b", CultureInfo.InvariantCulture);
+		}
+
+		string Params ()
+		{
+			// the overload to use is: Format(IFormatProvider, string, params object []);
+			return String.Format ("{0} {1} {2}", 1, 2, 3);
+		}
+
+		void NoSimpleOverload (FieldInfo fi)
+		{
+			// the overload with a CultureInfo is SetValue (object, object, BindingFlags, Binder, CultureInfo);
+			// and is not simply an "extra" parameter
+			fi.SetValue (new object (), 1);
+		}
+
+		[Test]
+		public void SpecialCases ()
+		{
+			AssertRuleSuccess<PreferIFormatProviderOverrideTest> ("Ignored");
+			AssertRuleFailure<PreferIFormatProviderOverrideTest> ("Params", 1);
+			AssertRuleSuccess<PreferIFormatProviderOverrideTest> ("NoSimpleOverload");
+		}
+	}
+}
diff --git a/gendarme/rules/Gendarme.Rules.Globalization/Test/PreferStringComparisonOverrideTest.cs b/gendarme/rules/Gendarme.Rules.Globalization/Test/PreferStringComparisonOverrideTest.cs
new file mode 100644
index 0000000..722ff32
--- /dev/null
+++ b/gendarme/rules/Gendarme.Rules.Globalization/Test/PreferStringComparisonOverrideTest.cs
@@ -0,0 +1,366 @@
+//
+// Unit tests for PreferStringComparisonOverrideRule
+//
+// Authors:
+//	Sebastien Pouliot <sebastien@ximian.com>
+//
+// Copyright (C) 2011 Novell, Inc (http://www.novell.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+
+using Gendarme.Rules.Globalization;
+using NUnit.Framework;
+
+using Test.Rules.Definitions;
+using Test.Rules.Fixtures;
+
+namespace Tests.Rules.Globalization {
+
+	[TestFixture]
+	public class PreferStringComparisonOverrideTest : MethodRuleTestFixture<PreferStringComparisonOverrideRule> {
+
+		[Test]
+		public void DoesNotApply ()
+		{
+			AssertRuleDoesNotApply (SimpleMethods.EmptyMethod);
+			AssertRuleDoesNotApply (SimpleMethods.ExternalMethod);
+		}
+
+		public class InstanceWithoutOverride {
+
+			public bool Compare (string s1, string s2)
+			{
+				return false;
+			}
+
+			public void Test ()
+			{
+				if (Compare ("a", "b"))
+					Console.WriteLine ();
+			}
+		}
+
+		public class Base {
+
+			public bool Compare (string s1, string s2)
+			{
+				return false;
+			}
+
+			public void TestBase ()
+			{
+				if (Compare ("a", "b"))
+					Console.WriteLine ();
+			}
+		}
+
+		public class Inherited : Base {
+			public bool Compare (string s1, string s2, StringComparison comparison)
+			{
+				return true;
+			}
+
+			public void TestInherited ()
+			{
+				// from IL this is a call to Base.Compare so the override is not seen
+				// note: fxcop also miss this one
+				if (Compare ("a", "b"))
+					Console.WriteLine ();
+			}
+		}
+
+		public class StaticHelperWithoutOverride {
+
+			// no alternative
+			public static bool StaticCompare (string s1, string s2)
+			{
+				return false;
+			}
+
+			public void Test ()
+			{
+				if (StaticCompare ("a", "b"))
+					Console.WriteLine ();
+			}
+		}
+
+		public class StaticHelperWithExtraParameterInOverride {
+
+			public static bool StaticCompare (string s1, string s2)
+			{
+				return false;
+			}
+
+			// the extra parameter disqualify the override
+			public static bool StaticCompare (string s1, string s2, bool value, StringComparison comparison)
+			{
+				return value;
+			}
+
+			// the extra parameter disqualify the override
+			public static bool StaticCompare (string s1, string s2, StringComparison comparison, bool value)
+			{
+				return value;
+			}
+
+			public void Test ()
+			{
+				if (StaticCompare ("a", "b"))
+					Console.WriteLine ();
+			}
+		}
+
+		public class Weird {
+			public bool Compare (StringComparison a, StringComparison b)
+			{
+				return (a == b);
+			}
+
+			public void Test ()
+			{
+				if (Compare (StringComparison.CurrentCulture, StringComparison.CurrentCultureIgnoreCase))
+					Console.WriteLine ();
+			}
+		}
+
+		[Test]
+		public void Success ()
+		{
+			AssertRuleSuccess<InstanceWithoutOverride> ("Test");
+
+			AssertRuleSuccess<Base> ("TestBase");
+			AssertRuleSuccess<Inherited> ("TestInherited");
+
+			AssertRuleSuccess<StaticHelperWithoutOverride> ("Test");
+			AssertRuleSuccess<StaticHelperWithExtraParameterInOverride> ("Test");
+
+			AssertRuleSuccess<Weird> ("Test");
+		}
+
+		public class InstanceWithOverride {
+
+			public bool Compare (string s1, string s2)
+			{
+				return false;
+			}
+
+			public bool Compare (string s1, string s2, StringComparison comparison)
+			{
+				return true;
+			}
+
+			// bad
+			public void Test ()
+			{
+				if (Compare ("a", "b"))
+					Console.WriteLine ();
+			}
+		}
+
+		public class StaticHelper {
+
+			public static bool StaticCompare (string s1, string s2)
+			{
+				return false;
+			}
+
+			// we have an alternative
+			public static bool StaticCompare (string s1, string s2, StringComparison comparison)
+			{
+				return true;
+			}
+
+			// bad
+			public void Test ()
+			{
+				if (StaticHelper.StaticCompare ("a", "b"))
+					Console.WriteLine ();
+			}
+		}
+
+		public class NonString {
+
+			public bool Kompare (char [] s1, char [] s2)
+			{
+				return false;
+			}
+
+			public bool Kompare (char [] s1, char [] s2, StringComparison comparison)
+			{
+				return true;
+			}
+
+			// bad
+			public void TestCharArray ()
+			{
+				if (Kompare (new char [] { }, new char [] { }))
+					Console.WriteLine ();
+			}
+
+			public bool KomparInt (int a, int b)
+			{
+				return false;
+			}
+
+			public bool KomparInt (int a, int b, StringComparison comparison)
+			{
+				return true;
+			}
+
+			// bad
+			public void TestInt ()
+			{
+				if (KomparInt (0, 0))
+					Console.WriteLine ();
+			}
+		}
+
+		public class ExtraParameters {
+
+			public bool Kompare (int level, string s1, string s2)
+			{
+				return false;
+			}
+
+			public bool Kompare (int level, string s1, string s2, StringComparison comparison)
+			{
+				return true;
+			}
+
+			// bad
+			public void TestExtraFirst ()
+			{
+				if (Kompare (0, "a", "B"))
+					Console.WriteLine ();
+			}
+
+			public bool Kompar (string s1, int start, string s2)
+			{
+				return false;
+			}
+
+			public bool Kompar (string s1, int start, string s2, StringComparison comparison)
+			{
+				return true;
+			}
+
+			// bad
+			public void TestExtraMid ()
+			{
+				if (Kompar ("a", 0, "B"))
+					Console.WriteLine ();
+			}
+
+			public bool Komparz (string s1, string s2, int end)
+			{
+				return false;
+			}
+
+			// note: parameter name mismatch
+			public bool Komparz (string s1, string s2, int start, StringComparison comparison)
+			{
+				return true;
+			}
+
+			// bad
+			public void TestExtraEnd ()
+			{
+				if (Komparz ("a", "B", 0))
+					Console.WriteLine ();
+			}
+		}
+
+		public class FewParameters {
+
+			public bool Compare ()
+			{
+				return false;
+			}
+
+			public bool Compare (StringComparison comparison)
+			{
+				return true;
+			}
+
+			// bad
+			public void TestNone ()
+			{
+				if (Compare ())
+					Console.WriteLine ();
+			}
+
+			public bool Compare (object o)
+			{
+				return (o == null);
+			}
+
+			public bool Compare (object o, StringComparison comparison)
+			{
+				return true;
+			}
+
+			// bad
+			public void TestSingle ()
+			{
+				if (Compare (null))
+					Console.WriteLine ();
+			}
+
+			public bool Compare (short a, long b)
+			{
+				return (a == b);
+			}
+
+			public bool Compare (short a, long b, StringComparison comparison)
+			{
+				return true;
+			}
+
+			// bad
+			public void TestDifferent ()
+			{
+				if (Compare (1, 1))
+					Console.WriteLine ();
+			}
+		}
+
+		[Test]
+		public void Failure ()
+		{
+			AssertRuleFailure<InstanceWithOverride> ("Test");
+			
+			AssertRuleFailure<StaticHelper> ("Test");
+
+			AssertRuleFailure<NonString> ("TestCharArray");
+			AssertRuleFailure<NonString> ("TestInt");
+
+			AssertRuleFailure<ExtraParameters> ("TestExtraFirst");
+			AssertRuleFailure<ExtraParameters> ("TestExtraMid");
+			AssertRuleFailure<ExtraParameters> ("TestExtraEnd");
+
+			AssertRuleFailure<FewParameters> ("TestNone");
+			AssertRuleFailure<FewParameters> ("TestSingle");
+			AssertRuleFailure<FewParameters> ("TestDifferent");
+		}
+	}
+}
diff --git a/gendarme/rules/Gendarme.Rules.Globalization/Test/PublicResource.Designer.cs b/gendarme/rules/Gendarme.Rules.Globalization/Test/PublicResource.Designer.cs
index 435893c..369bf20 100644
--- a/gendarme/rules/Gendarme.Rules.Globalization/Test/PublicResource.Designer.cs
+++ b/gendarme/rules/Gendarme.Rules.Globalization/Test/PublicResource.Designer.cs
@@ -1,7 +1,7 @@
-﻿//------------------------------------------------------------------------------
+//------------------------------------------------------------------------------
 // <auto-generated>
 //     This code was generated by a tool.
-//     Runtime Version:2.0.50727.4952
+//     Runtime Version:4.0.30319.1
 //
 //     Changes to this file may cause incorrect behavior and will be lost if
 //     the code is regenerated.
@@ -19,7 +19,7 @@ namespace Tests.Rules.Globalization {
     // class via a tool like ResGen or Visual Studio.
     // To add or remove a member, edit your .ResX file then rerun ResGen
     // with the /str option, or rebuild your VS project.
-    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "2.0.0.0")]
+    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
     [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
     [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
     public class PublicResource {
diff --git a/gendarme/rules/Gendarme.Rules.Globalization/Test/Resource.Designer.cs b/gendarme/rules/Gendarme.Rules.Globalization/Test/Resource.Designer.cs
index 2edd1e0..8847e59 100644
--- a/gendarme/rules/Gendarme.Rules.Globalization/Test/Resource.Designer.cs
+++ b/gendarme/rules/Gendarme.Rules.Globalization/Test/Resource.Designer.cs
@@ -1,7 +1,7 @@
-﻿//------------------------------------------------------------------------------
+//------------------------------------------------------------------------------
 // <auto-generated>
 //     This code was generated by a tool.
-//     Runtime Version:2.0.50727.4952
+//     Runtime Version:4.0.30319.1
 //
 //     Changes to this file may cause incorrect behavior and will be lost if
 //     the code is regenerated.
@@ -19,7 +19,7 @@ namespace Tests.Rules.Globalization {
     // class via a tool like ResGen or Visual Studio.
     // To add or remove a member, edit your .ResX file then rerun ResGen
     // with the /str option, or rebuild your VS project.
-    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "2.0.0.0")]
+    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
     [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
     [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
     internal class Resource {
diff --git a/gendarme/rules/Gendarme.Rules.Globalization/Test/Tests.Rules.Globalization.csproj b/gendarme/rules/Gendarme.Rules.Globalization/Test/Tests.Rules.Globalization.csproj
index 063810d..d1c6107 100644
--- a/gendarme/rules/Gendarme.Rules.Globalization/Test/Tests.Rules.Globalization.csproj
+++ b/gendarme/rules/Gendarme.Rules.Globalization/Test/Tests.Rules.Globalization.csproj
@@ -1,5 +1,5 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
     <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
@@ -10,8 +10,28 @@
     <AppDesignerFolder>Properties</AppDesignerFolder>
     <RootNamespace>Tests.Rules.Globalization</RootNamespace>
     <AssemblyName>Tests.Rules.Globalization</AssemblyName>
-    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
     <FileAlignment>512</FileAlignment>
+    <FileUpgradeFlags>
+    </FileUpgradeFlags>
+    <OldToolsVersion>3.5</OldToolsVersion>
+    <UpgradeBackupLocation />
+    <PublishUrl>publish\</PublishUrl>
+    <Install>true</Install>
+    <InstallFrom>Disk</InstallFrom>
+    <UpdateEnabled>false</UpdateEnabled>
+    <UpdateMode>Foreground</UpdateMode>
+    <UpdateInterval>7</UpdateInterval>
+    <UpdateIntervalUnits>Days</UpdateIntervalUnits>
+    <UpdatePeriodically>false</UpdatePeriodically>
+    <UpdateRequired>false</UpdateRequired>
+    <MapFileExtensions>true</MapFileExtensions>
+    <ApplicationRevision>0</ApplicationRevision>
+    <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
+    <IsWebBootstrapper>false</IsWebBootstrapper>
+    <UseApplicationTrust>false</UseApplicationTrust>
+    <BootstrapperEnabled>true</BootstrapperEnabled>
+    <TargetFrameworkProfile />
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
     <DebugSymbols>true</DebugSymbols>
@@ -21,6 +41,7 @@
     <DefineConstants>DEBUG;TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
     <DebugType>pdbonly</DebugType>
@@ -29,6 +50,7 @@
     <DefineConstants>TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <ItemGroup>
     <Reference Include="nunit.framework, Version=2.4.8.0, Culture=neutral, PublicKeyToken=96d09a1eb7f44a77, processorArchitecture=MSIL">
@@ -128,6 +150,23 @@
   <ItemGroup>
     <Folder Include="Properties\" />
   </ItemGroup>
+  <ItemGroup>
+    <BootstrapperPackage Include="Microsoft.Net.Client.3.5">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1 Client Profile</ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Windows.Installer.3.1">
+      <Visible>False</Visible>
+      <ProductName>Windows Installer 3.1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+  </ItemGroup>
   <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
   <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
        Other similar extension points exist, see Microsoft.Common.targets.
diff --git a/gendarme/rules/Gendarme.Rules.Interoperability.Com/AutoLayoutTypesShouldNotBeComVisibleRule.cs b/gendarme/rules/Gendarme.Rules.Interoperability.Com/AutoLayoutTypesShouldNotBeComVisibleRule.cs
index 5de0801..e6ae04b 100644
--- a/gendarme/rules/Gendarme.Rules.Interoperability.Com/AutoLayoutTypesShouldNotBeComVisibleRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Interoperability.Com/AutoLayoutTypesShouldNotBeComVisibleRule.cs
@@ -37,9 +37,11 @@ using Gendarme.Framework.Rocks;
 namespace Gendarme.Rules.Interoperability.Com {
 
 	/// <summary>
-	///  This rule checks for ComVisible value types which have StructLayout
-	///  attribute set to LayoutKind.Auto because auto layout can change 
-	///  between Mono and .NET or even between releases of the .NET/Mono frameworks
+	/// This rule checks for <c>[System.Runtime.InteropServices.ComVisible]</c> decorated value 
+	/// types which have <c>[System.Runtime.InteropServices.StructLayout]</c> attribute set to 
+	/// <c>System.Runtime.InteropServices.LayoutKind</c>.<c>Auto</c> because auto layout can 
+	/// change between Mono and .NET or even between releases of the .NET/Mono frameworks.
+	/// Note that this does not affect <c>System.Enum</c>-based types.
 	/// </summary>
 	/// <example>
 	/// Bad example:
@@ -80,7 +82,7 @@ namespace Gendarme.Rules.Interoperability.Com {
 
 		public RuleResult CheckType (TypeDefinition type)
 		{
-			if (!type.IsValueType || !type.HasCustomAttributes || 
+			if (type.IsEnum || !type.IsValueType || !type.HasCustomAttributes || 
 				(!type.IsPublic && !type.IsNestedPublic) || type.HasGenericParameters)
 				return RuleResult.DoesNotApply;
 
diff --git a/gendarme/rules/Gendarme.Rules.Interoperability.Com/AvoidInt64ArgumentsInComVisibleMethodsRule.cs b/gendarme/rules/Gendarme.Rules.Interoperability.Com/AvoidInt64ArgumentsInComVisibleMethodsRule.cs
index 5c13b94..5ef8900 100644
--- a/gendarme/rules/Gendarme.Rules.Interoperability.Com/AvoidInt64ArgumentsInComVisibleMethodsRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Interoperability.Com/AvoidInt64ArgumentsInComVisibleMethodsRule.cs
@@ -106,7 +106,7 @@ namespace Gendarme.Rules.Interoperability.Com {
 				return RuleResult.DoesNotApply;
 
 			foreach (ParameterDefinition parameter in method.Parameters) {
-				if (parameter.ParameterType.FullName == "System.Int64")
+				if (parameter.ParameterType.IsNamed ("System", "Int64"))
 					Runner.Report (parameter, Severity.Medium, Confidence.Total);
 			}
 
diff --git a/gendarme/rules/Gendarme.Rules.Interoperability.Com/AvoidStaticMembersInComVisibleTypesRule.cs b/gendarme/rules/Gendarme.Rules.Interoperability.Com/AvoidStaticMembersInComVisibleTypesRule.cs
index 9a22d1b..be412d2 100644
--- a/gendarme/rules/Gendarme.Rules.Interoperability.Com/AvoidStaticMembersInComVisibleTypesRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Interoperability.Com/AvoidStaticMembersInComVisibleTypesRule.cs
@@ -118,7 +118,7 @@ namespace Gendarme.Rules.Interoperability.Com {
 		{
 			return !(!method.IsStatic || !method.IsPublic || method.HasGenericParameters || 
 				method.IsAddOn || method.IsRemoveOn || method.IsGetter || method.IsSetter ||
-				((method.Attributes & MethodAttributes.SpecialName) != 0 && method.Name.StartsWith ("op_")) ||
+				((method.Attributes & MethodAttributes.SpecialName) != 0 && method.Name.StartsWith ("op_", StringComparison.Ordinal)) ||
 				method.DeclaringType.HasGenericParameters || method.DeclaringType.IsEnum ||
 				method.DeclaringType.IsInterface);
 		}
diff --git a/gendarme/rules/Gendarme.Rules.Interoperability.Com/ComRocks.cs b/gendarme/rules/Gendarme.Rules.Interoperability.Com/ComRocks.cs
index e25404c..5c1de40 100644
--- a/gendarme/rules/Gendarme.Rules.Interoperability.Com/ComRocks.cs
+++ b/gendarme/rules/Gendarme.Rules.Interoperability.Com/ComRocks.cs
@@ -32,6 +32,8 @@
 
 using Mono.Cecil;
 
+using Gendarme.Framework.Rocks;
+
 namespace Gendarme.Rules.Interoperability.Com {
 
 	/// <summary>
@@ -56,7 +58,7 @@ namespace Gendarme.Rules.Interoperability.Com {
 					// any attribute without arguments can be skipped
 					if (!attribute.HasConstructorArguments)
 						continue;
-					if (attribute.Constructor.DeclaringType.FullName != "System.Runtime.InteropServices.ComVisibleAttribute")
+					if (!attribute.Constructor.DeclaringType.IsNamed ("System.Runtime.InteropServices", "ComVisibleAttribute"))
 						continue;
 					return (bool) attribute.ConstructorArguments[0].Value;
 				}
@@ -74,6 +76,10 @@ namespace Gendarme.Rules.Interoperability.Com {
 		// considering nested types, assemblies attributes and default values
 		public static bool IsTypeComVisible (this TypeDefinition self)
 		{
+			// [ComVisible] attribute will be ignored on non-visible types
+			if (!self.IsVisible ())
+				return false;
+
 			return (self.IsComVisible () ?? self.Module.Assembly.IsComVisible () ?? true);
 		}
 	}
diff --git a/gendarme/rules/Gendarme.Rules.Interoperability.Com/ComVisibleShouldInheritFromComVisibleRule.cs b/gendarme/rules/Gendarme.Rules.Interoperability.Com/ComVisibleShouldInheritFromComVisibleRule.cs
index 8e46c99..46291d5 100644
--- a/gendarme/rules/Gendarme.Rules.Interoperability.Com/ComVisibleShouldInheritFromComVisibleRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Interoperability.Com/ComVisibleShouldInheritFromComVisibleRule.cs
@@ -27,6 +27,7 @@
 //
 
 using System;
+using System.Globalization;
 using System.Runtime.InteropServices;
 
 using Mono.Cecil;
@@ -101,9 +102,9 @@ namespace Gendarme.Rules.Interoperability.Com {
 
 			TypeDefinition baseType = type.BaseType.Resolve ();
 			if ((baseType != null) && !baseType.IsTypeComVisible ()) {
-				Runner.Report (type, Severity.High, Confidence.Total,
-					String.Format ("Type is derived from invisible from COM type {0}",
-						baseType.FullName));
+				string msg = String.Format (CultureInfo.InvariantCulture, 
+					"Type is derived from invisible from COM type {0}", baseType.GetFullName ());
+				Runner.Report (type, Severity.High, Confidence.Total, msg);
 			}
 			return Runner.CurrentRuleResult;
 		}
diff --git a/gendarme/rules/Gendarme.Rules.Interoperability.Com/DoNotUseAutoDualClassInterfaceTypeRule.cs b/gendarme/rules/Gendarme.Rules.Interoperability.Com/DoNotUseAutoDualClassInterfaceTypeRule.cs
index 2272ad1..31e43a0 100644
--- a/gendarme/rules/Gendarme.Rules.Interoperability.Com/DoNotUseAutoDualClassInterfaceTypeRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Interoperability.Com/DoNotUseAutoDualClassInterfaceTypeRule.cs
@@ -111,15 +111,14 @@ namespace Gendarme.Rules.Interoperability.Com {
 		private static ClassInterfaceType? GetClassInterfaceAttributeValue (ICustomAttributeProvider obj)
 		{
 			foreach (CustomAttribute attribute in obj.CustomAttributes) {
-				// ClassInterfaceAttribute has a two ctors each taking an argument (ClassInterfaceType or short)
 				// http://msdn.microsoft.com/en-us/library/system.runtime.interopservices.classinterfaceattribute.aspx
 				// any attribute without arguments can be skipped
 				if (!attribute.HasConstructorArguments)
 					continue;
-				if (attribute.AttributeType.FullName != "System.Runtime.InteropServices.ClassInterfaceAttribute")
+				if (!attribute.AttributeType.IsNamed ("System.Runtime.InteropServices", "ClassInterfaceAttribute"))
 					continue;
 				var ctorArgs = attribute.ConstructorArguments;
-				if (ctorArgs [0].Type.FullName == "System.Int16")
+				if (ctorArgs [0].Type.IsNamed ("System", "Int16"))
 					return (ClassInterfaceType)(short)ctorArgs [0].Value;
 				return (ClassInterfaceType)(int)ctorArgs [0].Value;
 			}
diff --git a/gendarme/rules/Gendarme.Rules.Interoperability.Com/Gendarme.Rules.Interoperability.Com.csproj b/gendarme/rules/Gendarme.Rules.Interoperability.Com/Gendarme.Rules.Interoperability.Com.csproj
index d39ca71..b0fbc53 100755
--- a/gendarme/rules/Gendarme.Rules.Interoperability.Com/Gendarme.Rules.Interoperability.Com.csproj
+++ b/gendarme/rules/Gendarme.Rules.Interoperability.Com/Gendarme.Rules.Interoperability.Com.csproj
@@ -1,78 +1,117 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <PropertyGroup>
-    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
-    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
-    <ProductVersion>9.0.30729</ProductVersion>
-    <SchemaVersion>2.0</SchemaVersion>
-    <ProjectGuid>{468F7043-C0D5-480F-88A1-A262EC324E5E}</ProjectGuid>
-    <OutputType>Library</OutputType>
-    <AppDesignerFolder>Properties</AppDesignerFolder>
-    <RootNamespace>Gendarme.Rules.Interoperability.Com</RootNamespace>
-    <AssemblyName>Gendarme.Rules.Interoperability.Com</AssemblyName>
-    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
-    <FileAlignment>512</FileAlignment>
-  </PropertyGroup>
-  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
-    <DebugSymbols>true</DebugSymbols>
-    <DebugType>full</DebugType>
-    <Optimize>false</Optimize>
-    <OutputPath>..\..\console\bin\Debug\</OutputPath>
-    <DefineConstants>DEBUG;TRACE</DefineConstants>
-    <ErrorReport>prompt</ErrorReport>
-    <WarningLevel>4</WarningLevel>
-    <DocumentationFile>..\..\console\bin\Debug\Gendarme.Rules.Interoperability.Com.xml</DocumentationFile>
-  </PropertyGroup>
-  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
-    <DebugType>pdbonly</DebugType>
-    <Optimize>true</Optimize>
-    <OutputPath>..\..\console\bin\Release\</OutputPath>
-    <DefineConstants>TRACE;RELEASE</DefineConstants>
-    <ErrorReport>prompt</ErrorReport>
-    <WarningLevel>4</WarningLevel>
-    <DocumentationFile>..\..\console\bin\Release\Gendarme.Rules.Interoperability.Com.xml</DocumentationFile>
-  </PropertyGroup>
-  <ItemGroup>
-    <Reference Include="System" />
-    <Reference Include="System.Core">
-      <RequiredTargetFramework>3.5</RequiredTargetFramework>
-    </Reference>
-  </ItemGroup>
-  <ItemGroup>
-    <ProjectReference Include="..\..\..\..\cecil\Mono.Cecil.csproj">
-      <Project>{D68133BD-1E63-496E-9EDE-4FBDBF77B486}</Project>
-      <Name>Mono.Cecil</Name>
-    </ProjectReference>
-    <ProjectReference Include="..\..\framework\Gendarme.Framework.csproj">
-      <Project>{CD6818D5-B398-486C-B180-92A07B143AFD}</Project>
-      <Name>Gendarme.Framework</Name>
-    </ProjectReference>
-  </ItemGroup>
-  <ItemGroup>
-    <Compile Include="..\..\AssemblyStaticInfo.cs">
-      <Link>AssemblyStaticInfo.cs</Link>
-    </Compile>
-    <Compile Include="AutoLayoutTypesShouldNotBeComVisibleRule.cs" />
-    <Compile Include="AvoidInt64ArgumentsInComVisibleMethodsRule.cs" />
-    <Compile Include="AvoidNonPublicFieldsInComVisibleValueTypesRule.cs" />
-    <Compile Include="AvoidOverloadsInComVisibleInterfacesRule.cs" />
-    <Compile Include="AvoidStaticMembersInComVisibleTypesRule.cs" />
-    <Compile Include="ComRocks.cs" />
-    <Compile Include="ComVisibleShouldInheritFromComVisibleRule.cs" />
-    <Compile Include="ComVisibleTypesShouldBeCreatableRule.cs" />
-    <Compile Include="DoNotUseAutoDualClassInterfaceTypeRule.cs" />
-    <Compile Include="MarkComSourceInterfacesAsIDispatchRule.cs" />
-    <Compile Include="ReviewComRegistrationMethodsRule.cs" />
-  </ItemGroup>
-  <ItemGroup>
-    <Folder Include="Properties\" />
-  </ItemGroup>
-  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
+    <ProductVersion>9.0.30729</ProductVersion>
+    <SchemaVersion>2.0</SchemaVersion>
+    <ProjectGuid>{468F7043-C0D5-480F-88A1-A262EC324E5E}</ProjectGuid>
+    <OutputType>Library</OutputType>
+    <AppDesignerFolder>Properties</AppDesignerFolder>
+    <RootNamespace>Gendarme.Rules.Interoperability.Com</RootNamespace>
+    <AssemblyName>Gendarme.Rules.Interoperability.Com</AssemblyName>
+    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
+    <FileAlignment>512</FileAlignment>
+    <FileUpgradeFlags>
+    </FileUpgradeFlags>
+    <OldToolsVersion>3.5</OldToolsVersion>
+    <UpgradeBackupLocation />
+    <PublishUrl>publish\</PublishUrl>
+    <Install>true</Install>
+    <InstallFrom>Disk</InstallFrom>
+    <UpdateEnabled>false</UpdateEnabled>
+    <UpdateMode>Foreground</UpdateMode>
+    <UpdateInterval>7</UpdateInterval>
+    <UpdateIntervalUnits>Days</UpdateIntervalUnits>
+    <UpdatePeriodically>false</UpdatePeriodically>
+    <UpdateRequired>false</UpdateRequired>
+    <MapFileExtensions>true</MapFileExtensions>
+    <ApplicationRevision>0</ApplicationRevision>
+    <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
+    <IsWebBootstrapper>false</IsWebBootstrapper>
+    <UseApplicationTrust>false</UseApplicationTrust>
+    <BootstrapperEnabled>true</BootstrapperEnabled>
+    <TargetFrameworkProfile />
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
+    <DebugSymbols>true</DebugSymbols>
+    <DebugType>full</DebugType>
+    <Optimize>false</Optimize>
+    <OutputPath>..\..\console\bin\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+    <DocumentationFile>..\..\console\bin\Debug\Gendarme.Rules.Interoperability.Com.xml</DocumentationFile>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
+    <DebugType>pdbonly</DebugType>
+    <Optimize>true</Optimize>
+    <OutputPath>..\..\console\bin\Release\</OutputPath>
+    <DefineConstants>TRACE;RELEASE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+    <DocumentationFile>..\..\console\bin\Release\Gendarme.Rules.Interoperability.Com.xml</DocumentationFile>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
+  </PropertyGroup>
+  <ItemGroup>
+    <Reference Include="System" />
+    <Reference Include="System.Core">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\..\..\..\cecil\Mono.Cecil.csproj">
+      <Project>{D68133BD-1E63-496E-9EDE-4FBDBF77B486}</Project>
+      <Name>Mono.Cecil</Name>
+    </ProjectReference>
+    <ProjectReference Include="..\..\framework\Gendarme.Framework.csproj">
+      <Project>{CD6818D5-B398-486C-B180-92A07B143AFD}</Project>
+      <Name>Gendarme.Framework</Name>
+    </ProjectReference>
+  </ItemGroup>
+  <ItemGroup>
+    <Compile Include="..\..\AssemblyStaticInfo.cs">
+      <Link>AssemblyStaticInfo.cs</Link>
+    </Compile>
+    <Compile Include="AutoLayoutTypesShouldNotBeComVisibleRule.cs" />
+    <Compile Include="AvoidInt64ArgumentsInComVisibleMethodsRule.cs" />
+    <Compile Include="AvoidNonPublicFieldsInComVisibleValueTypesRule.cs" />
+    <Compile Include="AvoidOverloadsInComVisibleInterfacesRule.cs" />
+    <Compile Include="AvoidStaticMembersInComVisibleTypesRule.cs" />
+    <Compile Include="ComRocks.cs" />
+    <Compile Include="ComVisibleShouldInheritFromComVisibleRule.cs" />
+    <Compile Include="ComVisibleTypesShouldBeCreatableRule.cs" />
+    <Compile Include="DoNotUseAutoDualClassInterfaceTypeRule.cs" />
+    <Compile Include="MarkComSourceInterfacesAsIDispatchRule.cs" />
+    <Compile Include="ReviewComRegistrationMethodsRule.cs" />
+  </ItemGroup>
+  <ItemGroup>
+    <Folder Include="Properties\" />
+  </ItemGroup>
+  <ItemGroup>
+    <BootstrapperPackage Include="Microsoft.Net.Client.3.5">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1 Client Profile</ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Windows.Installer.3.1">
+      <Visible>False</Visible>
+      <ProductName>Windows Installer 3.1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+  </ItemGroup>
+  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
   <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
        Other similar extension points exist, see Microsoft.Common.targets.
   <Target Name="BeforeBuild">
   </Target>
   <Target Name="AfterBuild">
   </Target>
-  -->
+  -->
 </Project>
\ No newline at end of file
diff --git a/gendarme/rules/Gendarme.Rules.Interoperability.Com/MarkComSourceInterfacesAsIDispatchRule.cs b/gendarme/rules/Gendarme.Rules.Interoperability.Com/MarkComSourceInterfacesAsIDispatchRule.cs
index 8bfc88f..46d932a 100644
--- a/gendarme/rules/Gendarme.Rules.Interoperability.Com/MarkComSourceInterfacesAsIDispatchRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Interoperability.Com/MarkComSourceInterfacesAsIDispatchRule.cs
@@ -63,7 +63,7 @@ namespace Gendarme.Rules.Interoperability.Com {
 	[Solution ("Add an InterfaceTypeAttribute set to InterfaceIsIDispatch for all specified interfaces.")]
 	[FxCopCompatibility ("Microsoft.Interoperability", "CA1412:MarkComSourceInterfacesAsIDispatch")]
 	public class MarkComSourceInterfacesAsIDispatchRule : Rule, ITypeRule {
-		private List<TypeDefinition> interfaces = new List<TypeDefinition> ();
+		private SortedDictionary<string, TypeDefinition> interfaces = new SortedDictionary<string, TypeDefinition> ();
 
 		// Iterate through all assemblies and add the interfaces found to a list.
 		private void FindInterfaces ()
@@ -73,33 +73,17 @@ namespace Gendarme.Rules.Interoperability.Com {
 					foreach (TypeDefinition type in module.GetAllTypes ()) {
 						if (!type.IsInterface)
 							continue;
-						interfaces.Add (type);
+						interfaces.Add (type.GetFullName (), type);
 					}
 				}
 			}
 		}
 
-		// Find a TypeDefinition for an interface with the given name.
-		private TypeDefinition FindInterfaceDefinition (string fullName)
-		{
-			foreach (var def in interfaces)
-				if (fullName == def.FullName)
-					return def;
-			return null;
-		}
-
 		// Finds a CustomAttribute on a type from the given name.
-		private static CustomAttribute FindComAttribute (ICustomAttributeProvider type, string name)
+		private static CustomAttribute FindCustomAttribute (ICustomAttributeProvider type, string nameSpace, string name)
 		{
 			foreach (var attribute in type.CustomAttributes) {
-				if (!attribute.HasConstructorArguments)
-					continue;
-
-				TypeReference atype = attribute.AttributeType;
-				if (atype.Namespace != "System.Runtime.InteropServices")
-					continue;
-
-				if (atype.Name == name)
+				if (attribute.AttributeType.IsNamed (nameSpace, name))
 					return attribute;
 			}
 			return null;
@@ -115,7 +99,8 @@ namespace Gendarme.Rules.Interoperability.Com {
 				Runner.Report (def, Severity.High, Confidence.Total, "No attributes are present on a specified interface");
 				return;
 			}
-			var attribute = FindComAttribute (def, "InterfaceTypeAttribute");
+
+			var attribute = FindCustomAttribute (def, "System.Runtime.InteropServices", "InterfaceTypeAttribute");
 			if (attribute == null) {
 				Runner.Report (def, Severity.High, Confidence.Total, "No [InterfaceType] attribute is present on a specified interface");
 				return;
@@ -129,7 +114,9 @@ namespace Gendarme.Rules.Interoperability.Com {
 
 		private void CheckInterface (string interface_name)
 		{
-			CheckInterface (FindInterfaceDefinition (interface_name));
+			TypeDefinition td;
+			if (interfaces.TryGetValue (interface_name, out td))
+				CheckInterface (td);
 		}
 
 		public override void Initialize (IRunner runner)
@@ -145,7 +132,7 @@ namespace Gendarme.Rules.Interoperability.Com {
 			if (!type.IsClass || !type.HasCustomAttributes)
 				return RuleResult.DoesNotApply;
 
-			var attribute = FindComAttribute (type, "ComSourceInterfacesAttribute");
+			var attribute = FindCustomAttribute (type, "System.Runtime.InteropServices", "ComSourceInterfacesAttribute");
 			if (attribute == null)
 				return RuleResult.DoesNotApply;
 			// The attribute's paramemters may be a single null-delimited string, or up to four System.Types.
diff --git a/gendarme/rules/Gendarme.Rules.Interoperability.Com/README.md b/gendarme/rules/Gendarme.Rules.Interoperability.Com/README.md
new file mode 100644
index 0000000..af988cb
--- /dev/null
+++ b/gendarme/rules/Gendarme.Rules.Interoperability.Com/README.md
@@ -0,0 +1,9 @@
+# Gendarme.Rules.Interoperability.Com Rules
+
+You can access the latest rules documentation from our [[wiki|https://github.com/spouliot/gendarme/wiki/Gendarme.Rules.Interoperability.Com(git)]] pages.
+
+
+## Feedback
+
+Please report any documentation errors, typos or suggestions to the [[Gendarme Mailing List|https://groups.google.com/forum/?fromgroups#!forum/gendarme]]. Thanks!
+
diff --git a/gendarme/rules/Gendarme.Rules.Interoperability.Com/ReviewComRegistrationMethodsRule.cs b/gendarme/rules/Gendarme.Rules.Interoperability.Com/ReviewComRegistrationMethodsRule.cs
index b46b390..2a5679d 100644
--- a/gendarme/rules/Gendarme.Rules.Interoperability.Com/ReviewComRegistrationMethodsRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Interoperability.Com/ReviewComRegistrationMethodsRule.cs
@@ -94,9 +94,6 @@ namespace Gendarme.Rules.Interoperability.Com {
 	[FxCopCompatibility ("Microsoft.Interoperability", "CA1411:ComRegistrationMethodsShouldNotBeVisible")]
 	public class ReviewComRegistrationMethodsRule : Rule, ITypeRule {
 
-		const string comRegister = "System.Runtime.InteropServices.ComRegisterFunctionAttribute";
-		const string comUnregister = "System.Runtime.InteropServices.ComUnregisterFunctionAttribute";
-
 		public RuleResult CheckType (TypeDefinition type)
 		{
 			if (type.HasGenericParameters || !type.IsVisible () || !type.IsTypeComVisible ())
@@ -111,12 +108,12 @@ namespace Gendarme.Rules.Interoperability.Com {
 
 				bool foundRegisterUnregisterMethod = false; // method level variable
 				foreach (CustomAttribute attribute in method.CustomAttributes) {
-					var name = attribute.AttributeType.FullName;
-					if (!foundRegister && name == comRegister) {
+					TypeReference atype = attribute.AttributeType;
+					if (!foundRegister && atype.IsNamed ("System.Runtime.InteropServices", "ComRegisterFunctionAttribute")) {
 						foundRegister = true;
 						foundRegisterUnregisterMethod = true;
 					}
-					if (!foundUnregister && name == comUnregister) {
+					if (!foundUnregister && atype.IsNamed ("System.Runtime.InteropServices", "ComUnregisterFunctionAttribute")) {
 						foundUnregister = true;
 						foundRegisterUnregisterMethod = true;
 					}
diff --git a/gendarme/rules/Gendarme.Rules.Interoperability.Com/Test/AutoLayoutTypesShouldNotBeComVisibleTest.cs b/gendarme/rules/Gendarme.Rules.Interoperability.Com/Test/AutoLayoutTypesShouldNotBeComVisibleTest.cs
index 5cf9e05..3e8e282 100644
--- a/gendarme/rules/Gendarme.Rules.Interoperability.Com/Test/AutoLayoutTypesShouldNotBeComVisibleTest.cs
+++ b/gendarme/rules/Gendarme.Rules.Interoperability.Com/Test/AutoLayoutTypesShouldNotBeComVisibleTest.cs
@@ -137,5 +137,23 @@ namespace Test.Rules.Interoperability.Com {
 			AssertRuleDoesNotApply (SimpleTypes.Structure);
 
 		}
+
+		[ComVisible (true)]
+		public enum Enum {
+			Zero = 0
+		}
+
+		[Flags]
+		[ComVisible (true)]
+		public enum Flags {
+			One = 1
+		}
+
+		[Test]
+		public void SpecialCases ()
+		{
+			AssertRuleDoesNotApply<Enum> ();
+			AssertRuleDoesNotApply<Flags> ();
+		}
 	}
 }
diff --git a/gendarme/rules/Gendarme.Rules.Interoperability.Com/Test/AvoidStaticMembersInComVisibleTypesTest.cs b/gendarme/rules/Gendarme.Rules.Interoperability.Com/Test/AvoidStaticMembersInComVisibleTypesTest.cs
index 191eb2a..a4dbbc2 100644
--- a/gendarme/rules/Gendarme.Rules.Interoperability.Com/Test/AvoidStaticMembersInComVisibleTypesTest.cs
+++ b/gendarme/rules/Gendarme.Rules.Interoperability.Com/Test/AvoidStaticMembersInComVisibleTypesTest.cs
@@ -42,7 +42,7 @@ namespace Test.Rules.Interoperability.Com {
 	public class AvoidStaticMembersInComVisibleTypesTest : MethodRuleTestFixture<AvoidStaticMembersInComVisibleTypesRule> {
 
 		[ComVisible (true)]
-		class ComVisibleClass {
+		public class ComVisibleClass {
 			public static void Bad ()
 			{
 			}
@@ -103,20 +103,20 @@ namespace Test.Rules.Interoperability.Com {
 		}
 
 		[ComVisible (false)]
-		class ComInvisibleClass {
+		public class ComInvisibleClass {
 			public static void DoesNotApply ()
 			{
 			}
 		}
 
-		class NoAttributesClass {
+		public class NoAttributesClass {
 			public static void DoesNotApply ()
 			{
 			}
 		}
 
 		[ComVisible (true)]
-		interface Interface {
+		public interface Interface {
 			void DoesNotApply ();
 		}
 
diff --git a/gendarme/rules/Gendarme.Rules.Interoperability.Com/Test/ComVisibleShouldInheritFromComVisibleTest.cs b/gendarme/rules/Gendarme.Rules.Interoperability.Com/Test/ComVisibleShouldInheritFromComVisibleTest.cs
index 4613f87..ec721ad 100644
--- a/gendarme/rules/Gendarme.Rules.Interoperability.Com/Test/ComVisibleShouldInheritFromComVisibleTest.cs
+++ b/gendarme/rules/Gendarme.Rules.Interoperability.Com/Test/ComVisibleShouldInheritFromComVisibleTest.cs
@@ -27,6 +27,7 @@
 //
 
 using System;
+using System.Collections;
 using System.Runtime.InteropServices;
 
 using Mono.Cecil;
@@ -57,6 +58,10 @@ namespace Test.Rules.Interoperability.Com {
 		public class ComVisibleInheritsFromInvisibleClass : ComInvisibleClass {
 		}
 
+		[ComVisible (true)]
+		class NotReallyComVisibleInheritsFromInvisibleClass : ComInvisibleClass {
+		}
+
 		[ComVisible (false)]
 		public class ComInvisibleInheritsFromVisibleClass : ComVisibleClass {
 		}
@@ -64,9 +69,6 @@ namespace Test.Rules.Interoperability.Com {
 		[Test]
 		public void Good ()
 		{
-			// no ComVisible attributes in inheritance chain
-			AssertRuleSuccess (SimpleTypes.Class);
-
 			AssertRuleSuccess<ComVisibleClass> ();
 		}
 
@@ -79,8 +81,15 @@ namespace Test.Rules.Interoperability.Com {
 		[Test]
 		public void DoesNotApply ()
 		{
+			// BaseType is null
+			AssertRuleDoesNotApply<ICollection> ();
+
+			// not visible / no ComVisible attributes in inheritance chain
+			AssertRuleDoesNotApply (SimpleTypes.Class);
+
 			AssertRuleDoesNotApply<ComInvisibleClass> ();
 			AssertRuleDoesNotApply<ComInvisibleInheritsFromVisibleClass> ();
+			AssertRuleDoesNotApply<NotReallyComVisibleInheritsFromInvisibleClass> ();
 		}
 	}
 }
diff --git a/gendarme/rules/Gendarme.Rules.Interoperability.Com/Test/DoNotUseAutoDualClassInterfaceTypeTest.cs b/gendarme/rules/Gendarme.Rules.Interoperability.Com/Test/DoNotUseAutoDualClassInterfaceTypeTest.cs
index ad6b8f3..b68c36a 100644
--- a/gendarme/rules/Gendarme.Rules.Interoperability.Com/Test/DoNotUseAutoDualClassInterfaceTypeTest.cs
+++ b/gendarme/rules/Gendarme.Rules.Interoperability.Com/Test/DoNotUseAutoDualClassInterfaceTypeTest.cs
@@ -43,30 +43,30 @@ namespace Test.Rules.Interoperability.Com {
 
 		[ComVisible (true)]
 		[ClassInterface (ClassInterfaceType.AutoDual)]
-		class BadClass {
+		public class BadClass {
 			// do something
 		}
 
 		[ComVisible (true)]
 		[ClassInterface (2)]
-		class BadClassShortConstuctor {
+		public class BadClassShortConstuctor {
 			// do something
 		}
 
 		[ComVisible (false)]
 		[ClassInterface (ClassInterfaceType.AutoDual)]
-		class DoesNotApplyInvisible {
+		public class DoesNotApplyInvisible {
 			// do something
 		}
 
 		[ComVisible (true)]
-		class GoodNoInterfaceAttribute {
+		public class GoodNoInterfaceAttribute {
 			// do something
 		}
 
 		[ComVisible (true)]
 		[ClassInterface (ClassInterfaceType.None)]
-		class GoodClassNone : ICloneable {
+		public class GoodClassNone : ICloneable {
 			public object Clone ()
 			{
 				return new object ();
@@ -75,7 +75,7 @@ namespace Test.Rules.Interoperability.Com {
 
 		[ComVisible (true)]
 		[ClassInterface ((short)0)]
-		class GoodClassNoneShortConstructor : ICloneable {
+		public class GoodClassNoneShortConstructor : ICloneable {
 			public object Clone ()
 			{
 				return new object ();
diff --git a/gendarme/rules/Gendarme.Rules.Interoperability.Com/Test/Tests.Rules.Interoperability.Com.csproj b/gendarme/rules/Gendarme.Rules.Interoperability.Com/Test/Tests.Rules.Interoperability.Com.csproj
index 0b77953..7f21629 100755
--- a/gendarme/rules/Gendarme.Rules.Interoperability.Com/Test/Tests.Rules.Interoperability.Com.csproj
+++ b/gendarme/rules/Gendarme.Rules.Interoperability.Com/Test/Tests.Rules.Interoperability.Com.csproj
@@ -1,85 +1,124 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <PropertyGroup>
-    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
-    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
-    <ProductVersion>9.0.30729</ProductVersion>
-    <SchemaVersion>2.0</SchemaVersion>
-    <ProjectGuid>{393FCDDA-6AAF-4DBA-BB75-6BD85DAC84EE}</ProjectGuid>
-    <OutputType>Library</OutputType>
-    <AppDesignerFolder>Properties</AppDesignerFolder>
-    <RootNamespace>Tests.Rules.Interoperability.Com</RootNamespace>
-    <AssemblyName>Tests.Rules.Interoperability.Com</AssemblyName>
-    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
-    <FileAlignment>512</FileAlignment>
-  </PropertyGroup>
-  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
-    <DebugSymbols>true</DebugSymbols>
-    <DebugType>full</DebugType>
-    <Optimize>false</Optimize>
-    <OutputPath>bin\Debug\</OutputPath>
-    <DefineConstants>DEBUG;TRACE</DefineConstants>
-    <ErrorReport>prompt</ErrorReport>
-    <WarningLevel>4</WarningLevel>
-  </PropertyGroup>
-  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
-    <DebugType>pdbonly</DebugType>
-    <Optimize>true</Optimize>
-    <OutputPath>bin\Release\</OutputPath>
-    <DefineConstants>TRACE</DefineConstants>
-    <ErrorReport>prompt</ErrorReport>
-    <WarningLevel>4</WarningLevel>
-  </PropertyGroup>
-  <ItemGroup>
-    <Reference Include="nunit.framework, Version=2.4.8.0, Culture=neutral, PublicKeyToken=96d09a1eb7f44a77, processorArchitecture=MSIL">
-      <SpecificVersion>False</SpecificVersion>
-      <HintPath>..\..\..\..\..\cecil\Test\libs\nunit-2.4.8\nunit.framework.dll</HintPath>
-    </Reference>
-    <Reference Include="System" />
-    <Reference Include="System.Core">
-      <RequiredTargetFramework>3.5</RequiredTargetFramework>
-    </Reference>
-  </ItemGroup>
-  <ItemGroup>
-    <ProjectReference Include="..\..\..\..\..\cecil\Mono.Cecil.csproj">
-      <Project>{D68133BD-1E63-496E-9EDE-4FBDBF77B486}</Project>
-      <Name>Mono.Cecil</Name>
-    </ProjectReference>
-    <ProjectReference Include="..\..\..\framework\Gendarme.Framework.csproj">
-      <Project>{CD6818D5-B398-486C-B180-92A07B143AFD}</Project>
-      <Name>Gendarme.Framework</Name>
-    </ProjectReference>
-    <ProjectReference Include="..\..\Test.Rules\Test.Rules.csproj">
-      <Project>{069148AF-86AB-4EE3-BFB9-429AE722461F}</Project>
-      <Name>Test.Rules</Name>
-    </ProjectReference>
-    <ProjectReference Include="..\Gendarme.Rules.Interoperability.Com.csproj">
-      <Project>{468F7043-C0D5-480F-88A1-A262EC324E5E}</Project>
-      <Name>Gendarme.Rules.Interoperability.Com</Name>
-    </ProjectReference>
-  </ItemGroup>
-  <ItemGroup>
-    <Compile Include="AutoLayoutTypesShouldNotBeComVisibleTest.cs" />
-    <Compile Include="AvoidInt64ArgumentsInComVisibleMethodsTest.cs" />
-    <Compile Include="AvoidNonPublicFieldsInComVisibleValueTypesTest.cs" />
-    <Compile Include="AvoidOverloadsInComVisibleInterfacesTest.cs" />
-    <Compile Include="AvoidStaticMembersInComVisibleTypesTest.cs" />
-    <Compile Include="ComRocksTest.cs" />
-    <Compile Include="ComVisibleShouldInheritFromComVisibleTest.cs" />
-    <Compile Include="ComVisibleTypesShouldBeCreatableTest.cs" />
-    <Compile Include="DoNotUseAutoDualClassInterfaceTypeTest.cs" />
-    <Compile Include="MarkComSourceInterfacesAsIDispatchTest.cs" />
-    <Compile Include="ReviewComRegistrationMethodsTest.cs" />
-  </ItemGroup>
-  <ItemGroup>
-    <Folder Include="Properties\" />
-  </ItemGroup>
-  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
+    <ProductVersion>9.0.30729</ProductVersion>
+    <SchemaVersion>2.0</SchemaVersion>
+    <ProjectGuid>{393FCDDA-6AAF-4DBA-BB75-6BD85DAC84EE}</ProjectGuid>
+    <OutputType>Library</OutputType>
+    <AppDesignerFolder>Properties</AppDesignerFolder>
+    <RootNamespace>Tests.Rules.Interoperability.Com</RootNamespace>
+    <AssemblyName>Tests.Rules.Interoperability.Com</AssemblyName>
+    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
+    <FileAlignment>512</FileAlignment>
+    <FileUpgradeFlags>
+    </FileUpgradeFlags>
+    <OldToolsVersion>3.5</OldToolsVersion>
+    <UpgradeBackupLocation />
+    <PublishUrl>publish\</PublishUrl>
+    <Install>true</Install>
+    <InstallFrom>Disk</InstallFrom>
+    <UpdateEnabled>false</UpdateEnabled>
+    <UpdateMode>Foreground</UpdateMode>
+    <UpdateInterval>7</UpdateInterval>
+    <UpdateIntervalUnits>Days</UpdateIntervalUnits>
+    <UpdatePeriodically>false</UpdatePeriodically>
+    <UpdateRequired>false</UpdateRequired>
+    <MapFileExtensions>true</MapFileExtensions>
+    <ApplicationRevision>0</ApplicationRevision>
+    <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
+    <IsWebBootstrapper>false</IsWebBootstrapper>
+    <UseApplicationTrust>false</UseApplicationTrust>
+    <BootstrapperEnabled>true</BootstrapperEnabled>
+    <TargetFrameworkProfile />
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
+    <DebugSymbols>true</DebugSymbols>
+    <DebugType>full</DebugType>
+    <Optimize>false</Optimize>
+    <OutputPath>bin\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
+    <DebugType>pdbonly</DebugType>
+    <Optimize>true</Optimize>
+    <OutputPath>bin\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
+  </PropertyGroup>
+  <ItemGroup>
+    <Reference Include="nunit.framework, Version=2.4.8.0, Culture=neutral, PublicKeyToken=96d09a1eb7f44a77, processorArchitecture=MSIL">
+      <SpecificVersion>False</SpecificVersion>
+      <HintPath>..\..\..\..\..\cecil\Test\libs\nunit-2.4.8\nunit.framework.dll</HintPath>
+    </Reference>
+    <Reference Include="System" />
+    <Reference Include="System.Core">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\..\..\..\..\cecil\Mono.Cecil.csproj">
+      <Project>{D68133BD-1E63-496E-9EDE-4FBDBF77B486}</Project>
+      <Name>Mono.Cecil</Name>
+    </ProjectReference>
+    <ProjectReference Include="..\..\..\framework\Gendarme.Framework.csproj">
+      <Project>{CD6818D5-B398-486C-B180-92A07B143AFD}</Project>
+      <Name>Gendarme.Framework</Name>
+    </ProjectReference>
+    <ProjectReference Include="..\..\Test.Rules\Test.Rules.csproj">
+      <Project>{069148AF-86AB-4EE3-BFB9-429AE722461F}</Project>
+      <Name>Test.Rules</Name>
+    </ProjectReference>
+    <ProjectReference Include="..\Gendarme.Rules.Interoperability.Com.csproj">
+      <Project>{468F7043-C0D5-480F-88A1-A262EC324E5E}</Project>
+      <Name>Gendarme.Rules.Interoperability.Com</Name>
+    </ProjectReference>
+  </ItemGroup>
+  <ItemGroup>
+    <Compile Include="AutoLayoutTypesShouldNotBeComVisibleTest.cs" />
+    <Compile Include="AvoidInt64ArgumentsInComVisibleMethodsTest.cs" />
+    <Compile Include="AvoidNonPublicFieldsInComVisibleValueTypesTest.cs" />
+    <Compile Include="AvoidOverloadsInComVisibleInterfacesTest.cs" />
+    <Compile Include="AvoidStaticMembersInComVisibleTypesTest.cs" />
+    <Compile Include="ComRocksTest.cs" />
+    <Compile Include="ComVisibleShouldInheritFromComVisibleTest.cs" />
+    <Compile Include="ComVisibleTypesShouldBeCreatableTest.cs" />
+    <Compile Include="DoNotUseAutoDualClassInterfaceTypeTest.cs" />
+    <Compile Include="MarkComSourceInterfacesAsIDispatchTest.cs" />
+    <Compile Include="ReviewComRegistrationMethodsTest.cs" />
+  </ItemGroup>
+  <ItemGroup>
+    <Folder Include="Properties\" />
+  </ItemGroup>
+  <ItemGroup>
+    <BootstrapperPackage Include="Microsoft.Net.Client.3.5">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1 Client Profile</ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Windows.Installer.3.1">
+      <Visible>False</Visible>
+      <ProductName>Windows Installer 3.1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+  </ItemGroup>
+  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
   <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
        Other similar extension points exist, see Microsoft.Common.targets.
   <Target Name="BeforeBuild">
   </Target>
   <Target Name="AfterBuild">
   </Target>
-  -->
+  -->
 </Project>
\ No newline at end of file
diff --git a/gendarme/rules/Gendarme.Rules.Interoperability/CentralizePInvokesIntoNativeMethodsTypeRule.cs b/gendarme/rules/Gendarme.Rules.Interoperability/CentralizePInvokesIntoNativeMethodsTypeRule.cs
index fbadfc9..26d1dca 100644
--- a/gendarme/rules/Gendarme.Rules.Interoperability/CentralizePInvokesIntoNativeMethodsTypeRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Interoperability/CentralizePInvokesIntoNativeMethodsTypeRule.cs
@@ -27,6 +27,7 @@
 //
 
 using System;
+using System.Globalization;
 
 using Mono.Cecil;
 
@@ -91,20 +92,22 @@ namespace Gendarme.Rules.Interoperability {
 		{
 			// *NativeMethods types should never be visible outside the assembly
 			if (type.IsVisible ()) {
-				string msg = String.Format ("'{0}' should not be visible outside the assembly.", type);
+				string msg = String.Format (CultureInfo.InvariantCulture, 
+					"'{0}' should not be visible outside the assembly.", type.GetFullName ());
 				Runner.Report (type, Severity.High, Confidence.Total, msg);
 			}
 
 			if (CanInstantiateType (type)) {
-				string msg = String.Format ("'{0}' should not be static or sealed with no visible constructor.", type);
+				string msg = String.Format (CultureInfo.InvariantCulture, 
+					"'{0}' should not be static or sealed with no visible constructor.", type.GetFullName ());
 				Runner.Report (type, Severity.High, Confidence.Total, msg);
 			}
 		}
 
-		private void CheckSuppressUnmanagedCodeSecurity (TypeDefinition type, bool required)
+		private void CheckSuppressUnmanagedCodeSecurity (ICustomAttributeProvider type, bool required)
 		{
 			string msg = null;
-			if (type.HasCustomAttributes && type.CustomAttributes.ContainsType ("System.Security.SuppressUnmanagedCodeSecurityAttribute")) {
+			if (type.HasAttribute ("System.Security", "SuppressUnmanagedCodeSecurityAttribute")) {
 				if (!required)
 					 msg = "Remove [SuppressUnmanagedCodeSecurity] attribute on the type declaration.";
 			} else {
diff --git a/gendarme/rules/Gendarme.Rules.Interoperability/DelegatesPassedToNativeCodeMustIncludeExceptionHandlingRule.cs b/gendarme/rules/Gendarme.Rules.Interoperability/DelegatesPassedToNativeCodeMustIncludeExceptionHandlingRule.cs
index a407980..72b8ffc 100644
--- a/gendarme/rules/Gendarme.Rules.Interoperability/DelegatesPassedToNativeCodeMustIncludeExceptionHandlingRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Interoperability/DelegatesPassedToNativeCodeMustIncludeExceptionHandlingRule.cs
@@ -32,6 +32,7 @@
 using System;
 using System.Collections.Generic;
 using System.Diagnostics;
+using System.Globalization;
 
 using Mono.Cecil;
 using Mono.Cecil.Cil;
@@ -259,7 +260,7 @@ namespace Gendarme.Rules.Interoperability {
 				// Pending implementation of "analysis warnings", as mentioned here (post #21):
 				// http://groups.google.com/group/gendarme/browse_frm/thread/c37d157ae0c9682/57f89f3abf14f2fd?tvc=1&q=Gendarme+2.6+Preview+1+is+ready+for+download#57f89f3abf14f2fd
 				Runner.Report (method, Severity.Low, Confidence.Low,
-					string.Format ("An exception occurred while verifying this method. " +
+					String.Format (CultureInfo.CurrentCulture, "An exception occurred while verifying this method. " +
 					"This failure can probably be ignored, it's most likely due to an " + 
 					"uncommon code sequence in the method the rule didn't understand. {0}", ex.Message));
 				return RuleResult.Failure;
@@ -271,14 +272,14 @@ namespace Gendarme.Rules.Interoperability {
 			locals.Clear ();
 			stack.Clear ();
 			
-			Log.WriteLine (this, "\n\nChecking method: {0} on type: {1}", method.Name, method.DeclaringType.FullName);
+			Log.WriteLine (this, "\n\nChecking method: {0} on type: {1}", method.Name, method.DeclaringType.GetFullName ());
 			Log.WriteLine (this, method);
 
 			MethodBody body = method.Body;
 #if DEBUG
 			foreach (ExceptionHandler e in body.ExceptionHandlers)
-				Log.WriteLine (this, " HandlerType: {7}, TryStart: {4:X}, TryEnd: {5:X}, HandlerStart: {0:X}, HandlerEnd: {1:X}, FilterStart: {2:X}, FilterEnd: {3:X}, CatchType: {6}", 
-				                   e.HandlerStart.GetOffset (), e.HandlerEnd.GetOffset (), e.FilterStart.GetOffset (), e.FilterEnd.GetOffset (), 
+				Log.WriteLine (this, " HandlerType: {6}, TryStart: {3:X}, TryEnd: {4:X}, HandlerStart: {0:X}, HandlerEnd: {1:X}, FilterStart: {2:X}, CatchType: {5}", 
+				                   e.HandlerStart.GetOffset (), e.HandlerEnd.GetOffset (), e.FilterStart.GetOffset (),  
 				                   e.TryStart.GetOffset (), e.TryEnd.GetOffset (), e.CatchType, e.HandlerType);
 #endif
 			
@@ -493,12 +494,12 @@ namespace Gendarme.Rules.Interoperability {
 						continue;
 					
 					// no 'Catch ... When <condition>' clause. C# doesn't support it, VB does
-					if (eh.FilterStart != null || eh.FilterEnd != null)
+					if (eh.FilterStart != null)
 						continue;
 					
 					// check for catch all clauses
-					string exception_typename = eh.CatchType == null ? null : eh.CatchType.FullName;
-					if (!(exception_typename == null || exception_typename == "System.Object" || exception_typename == "System.Exception"))
+					TypeReference ctype = eh.CatchType;
+					if (!(ctype == null || ctype.IsNamed ("System", "Object") || ctype.IsNamed ("System", "Exception")))
 						continue;
 					
 					// Mark the code this exception handler handles as safe.
@@ -521,8 +522,8 @@ namespace Gendarme.Rules.Interoperability {
 				// Console.ResetColor ();
 			}
 			foreach (ExceptionHandler e in body.ExceptionHandlers)
-				Log.WriteLine (this, " HandlerType: {7}, TryStart: {4}, TryEnd: {5}, HandlerStart: {0}, HandlerEnd: {1}, FilterStart: {2}, FilterEnd: {3}, CatchType: {6}", 
-				                   e.HandlerStart.GetOffset (), e.HandlerEnd.GetOffset (), e.FilterStart.GetOffset (), e.FilterEnd.GetOffset (), 
+				Log.WriteLine (this, " HandlerType: {6}, TryStart: {3}, TryEnd: {4}, HandlerStart: {0}, HandlerEnd: {1}, FilterStart: {2}, CatchType: {5}", 
+				                   e.HandlerStart.GetOffset (), e.HandlerEnd.GetOffset (), e.FilterStart.GetOffset (),
 				                   e.TryStart.GetOffset (), e.TryEnd.GetOffset (), e.CatchType, e.HandlerType);
 #endif
 			
@@ -665,7 +666,8 @@ namespace Gendarme.Rules.Interoperability {
 			case Code.Ldloca_S:
 			case Code.Ldloc_S: return ((VariableDefinition) ins.Operand).Index;
 			default:
-				throw new ArgumentException (string.Format ("Invalid opcode: {0}", ins.OpCode.Name));
+				string msg = String.Format (CultureInfo.InvariantCulture, "Invalid opcode: {0}", ins.OpCode.Name);
+				throw new ArgumentException (msg);
 			}
 		}
 		
@@ -681,7 +683,8 @@ namespace Gendarme.Rules.Interoperability {
 			case Code.Stloc: // Untested for stloc
 			case Code.Stloc_S: return ((VariableDefinition) ins.Operand).Index;
 			default:
-				throw new ArgumentException (string.Format ("Invalid opcode: {0}", ins.OpCode.Name));
+				string msg = String.Format (CultureInfo.InvariantCulture, "Invalid opcode: {0}", ins.OpCode.Name);
+				throw new ArgumentException (msg);
 			}
 		}
 	}
diff --git a/gendarme/rules/Gendarme.Rules.Interoperability/DoNotCastIntPtrToInt32Rule.cs b/gendarme/rules/Gendarme.Rules.Interoperability/DoNotCastIntPtrToInt32Rule.cs
index 908fb83..6e2f0d6 100644
--- a/gendarme/rules/Gendarme.Rules.Interoperability/DoNotCastIntPtrToInt32Rule.cs
+++ b/gendarme/rules/Gendarme.Rules.Interoperability/DoNotCastIntPtrToInt32Rule.cs
@@ -27,6 +27,7 @@
 //
 
 using System;
+using System.Globalization;
 
 using Mono.Cecil;
 using Mono.Cecil.Cil;
@@ -87,7 +88,7 @@ namespace Gendarme.Rules.Interoperability {
 
 		private void Report (MethodDefinition method, Instruction ins, string typeName)
 		{
-			string msg = String.Format ("Type cast to '{0}'.", typeName);
+			string msg = String.Format (CultureInfo.InvariantCulture, "Type cast to '{0}'.", typeName);
 			Runner.Report (method, ins, Severity.High, Confidence.Normal, msg);
 		}
 
@@ -130,7 +131,7 @@ namespace Gendarme.Rules.Interoperability {
 			} else if (uintptr && (name == "ToUInt32")) {
 				Runner.Report (method, ins, Severity.High, Confidence.Normal, "Call to 'UIntPtr.ToUInt32()'.");
 			} else if (name == "op_Explicit") {
-				string rtfullname = mr.ReturnType.FullName;
+				string rtfullname = mr.ReturnType.GetFullName ();
 				switch (rtfullname) {
 				case "System.Int64":
 				case "System.UInt64":
@@ -165,8 +166,9 @@ namespace Gendarme.Rules.Interoperability {
 				if (m.Name != "op_Explicit")
 					return;
 
-				string msg = String.Format ("A '{0}' value is casted into an '{1}' when reading marshalled memory.",
-					mr.ReturnType.FullName, m.Parameters [0].ParameterType.FullName);
+				string msg = String.Format (CultureInfo.InvariantCulture,
+					"A '{0}' value is casted into an '{1}' when reading marshalled memory.",
+					mr.ReturnType.GetFullName (), m.Parameters [0].ParameterType.GetFullName ());
 				Runner.Report (method, ins, Severity.High, Confidence.Normal, msg);
 			}
 		}
@@ -190,12 +192,14 @@ namespace Gendarme.Rules.Interoperability {
 					continue;
 
 				// look for both IntPtr and the (less known) UIntPtr
-				string type = mr.DeclaringType.FullName;
-				bool intptr = (type == "System.IntPtr");
-				bool uintptr = (type == "System.UIntPtr");
-				if (intptr || uintptr) {
-					CheckCastOnIntPtr (method, ins, mr, intptr, uintptr);
-				} else if (type == "System.Runtime.InteropServices.Marshal") {
+				TypeReference type = mr.DeclaringType;
+				if (type.Namespace == "System") {
+					string name = type.Name;
+					bool intptr = (name == "IntPtr");
+					bool uintptr = (name == "UIntPtr");
+					if (intptr || uintptr)
+						CheckCastOnIntPtr (method, ins, mr, intptr, uintptr);
+				} else if (type.IsNamed ("System.Runtime.InteropServices", "Marshal")) {
 					CheckCastOnMarshal (method, ins, mr);
 				}
 			}
diff --git a/gendarme/rules/Gendarme.Rules.Interoperability/Gendarme.Rules.Interoperability.csproj b/gendarme/rules/Gendarme.Rules.Interoperability/Gendarme.Rules.Interoperability.csproj
index 04cd1c6..1b0a126 100755
--- a/gendarme/rules/Gendarme.Rules.Interoperability/Gendarme.Rules.Interoperability.csproj
+++ b/gendarme/rules/Gendarme.Rules.Interoperability/Gendarme.Rules.Interoperability.csproj
@@ -1,5 +1,5 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
     <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
@@ -10,8 +10,28 @@
     <AppDesignerFolder>Properties</AppDesignerFolder>
     <RootNamespace>Gendarme.Rules.Interoperability</RootNamespace>
     <AssemblyName>Gendarme.Rules.Interoperability</AssemblyName>
-    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
     <FileAlignment>512</FileAlignment>
+    <FileUpgradeFlags>
+    </FileUpgradeFlags>
+    <OldToolsVersion>3.5</OldToolsVersion>
+    <UpgradeBackupLocation />
+    <PublishUrl>publish\</PublishUrl>
+    <Install>true</Install>
+    <InstallFrom>Disk</InstallFrom>
+    <UpdateEnabled>false</UpdateEnabled>
+    <UpdateMode>Foreground</UpdateMode>
+    <UpdateInterval>7</UpdateInterval>
+    <UpdateIntervalUnits>Days</UpdateIntervalUnits>
+    <UpdatePeriodically>false</UpdatePeriodically>
+    <UpdateRequired>false</UpdateRequired>
+    <MapFileExtensions>true</MapFileExtensions>
+    <ApplicationRevision>0</ApplicationRevision>
+    <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
+    <IsWebBootstrapper>false</IsWebBootstrapper>
+    <UseApplicationTrust>false</UseApplicationTrust>
+    <BootstrapperEnabled>true</BootstrapperEnabled>
+    <TargetFrameworkProfile />
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
     <DebugSymbols>true</DebugSymbols>
@@ -24,6 +44,7 @@
     <NoWarn>1591</NoWarn>
     <WarningsAsErrors>1570</WarningsAsErrors>
     <DocumentationFile>..\..\console\bin\Debug\Gendarme.Rules.Interoperability.xml</DocumentationFile>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
     <DebugType>pdbonly</DebugType>
@@ -35,6 +56,7 @@
     <NoWarn>1591</NoWarn>
     <WarningsAsErrors>1570</WarningsAsErrors>
     <DocumentationFile>..\..\console\bin\Release\Gendarme.Rules.Interoperability.xml</DocumentationFile>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <ItemGroup>
     <Reference Include="System" />
@@ -65,6 +87,23 @@
       <Name>Gendarme.Framework</Name>
     </ProjectReference>
   </ItemGroup>
+  <ItemGroup>
+    <BootstrapperPackage Include="Microsoft.Net.Client.3.5">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1 Client Profile</ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Windows.Installer.3.1">
+      <Visible>False</Visible>
+      <ProductName>Windows Installer 3.1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+  </ItemGroup>
   <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
   <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
        Other similar extension points exist, see Microsoft.Common.targets.
diff --git a/gendarme/rules/Gendarme.Rules.Interoperability/GetLastErrorMustBeCalledRightAfterPInvokeRule.cs b/gendarme/rules/Gendarme.Rules.Interoperability/GetLastErrorMustBeCalledRightAfterPInvokeRule.cs
index 39cb63f..37b5dad 100644
--- a/gendarme/rules/Gendarme.Rules.Interoperability/GetLastErrorMustBeCalledRightAfterPInvokeRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Interoperability/GetLastErrorMustBeCalledRightAfterPInvokeRule.cs
@@ -98,9 +98,9 @@ namespace Gendarme.Rules.Interoperability {
 				return false;
 			}
 
-			public bool Equals (Branch branch)
+			public bool Equals (Branch other)
 			{
-				return (Instruction == branch.Instruction) && (DirtyMethodCalled == branch.DirtyMethodCalled);
+				return (Instruction == other.Instruction) && (DirtyMethodCalled == other.DirtyMethodCalled);
 			}
 
 			public override int GetHashCode ()
@@ -135,13 +135,18 @@ namespace Gendarme.Rules.Interoperability {
 
 					//check if a method is called
 					if (ins.OpCode.FlowControl == FlowControl.Call) {
+					    MethodReference mRef = ins.Operand as MethodReference;
 
-						MethodDefinition mDef = (ins.Operand as MethodReference).Resolve ();
+                        if (mRef == null) {
+                            continue;
+                        }
+
+					    MethodDefinition mDef = mRef.Resolve();
 						if (mDef != null && mDef.IsPInvokeImpl) { //check if another pinvoke method is called, this counts as "GetLastError not called"
 							break;
 						}
-
-						string s = (mDef == null) ? String.Empty : mDef.DeclaringType.FullName;
+                        
+						string s = (mDef == null) ? String.Empty : mDef.DeclaringType.GetFullName ();
 						switch (s) {
 						case "System.Runtime.InteropServices.Marshal":
 							getLastErrorFound = (mDef.Name == "GetLastWin32Error");
diff --git a/gendarme/rules/Gendarme.Rules.Interoperability/MarshalBooleansInPInvokeDeclarationsRule.cs b/gendarme/rules/Gendarme.Rules.Interoperability/MarshalBooleansInPInvokeDeclarationsRule.cs
index 588748a..acf7156 100644
--- a/gendarme/rules/Gendarme.Rules.Interoperability/MarshalBooleansInPInvokeDeclarationsRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Interoperability/MarshalBooleansInPInvokeDeclarationsRule.cs
@@ -64,13 +64,13 @@ namespace Gendarme.Rules.Interoperability {
 	[FxCopCompatibility ("Microsoft.Interoperability", "CA1414:MarkBooleanPInvokeArgumentsWithMarshalAs")]
 	public class MarshalBooleansInPInvokeDeclarationsRule : Rule, IMethodRule {
 
-		static bool CheckBooleanMarshalling (IMarshalInfoProvider spec, MemberReference type)
+		static bool CheckBooleanMarshalling (IMarshalInfoProvider spec, TypeReference type)
 		{
 			// is marshalling information provided
 			if (spec.MarshalInfo != null)
 				return true;
 			// using StartsWith to catch references (ref)
-			return !type.FullName.StartsWith ("System.Boolean", StringComparison.Ordinal);
+			return !(type.Namespace == "System" && type.Name.StartsWith ("Boolean", StringComparison.Ordinal));
 		}
 
 		public RuleResult CheckMethod (MethodDefinition method)
diff --git a/gendarme/rules/Gendarme.Rules.Interoperability/MarshalStringsInPInvokeDeclarationsRule.cs b/gendarme/rules/Gendarme.Rules.Interoperability/MarshalStringsInPInvokeDeclarationsRule.cs
index 442dd74..7edf597 100644
--- a/gendarme/rules/Gendarme.Rules.Interoperability/MarshalStringsInPInvokeDeclarationsRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Interoperability/MarshalStringsInPInvokeDeclarationsRule.cs
@@ -27,9 +27,11 @@
 //
 
 using System;
+using System.Globalization;
 
 using Mono.Cecil;
 using Gendarme.Framework;
+using Gendarme.Framework.Rocks;
 
 namespace Gendarme.Rules.Interoperability {
 
@@ -69,13 +71,8 @@ namespace Gendarme.Rules.Interoperability {
 
 		private static bool IsStringOrSBuilder (TypeReference reference)
 		{
-			switch (reference.GetElementType ().FullName) {
-			case "System.String":
-			case "System.Text.StringBuilder":
-				return true;
-			default:
-				return false;
-			}
+			TypeReference type = reference.GetElementType ();
+			return (type.IsNamed ("System", "String") || type.IsNamed ("System.Text", "StringBuilder"));
 		}
 
 		public RuleResult CheckMethod (MethodDefinition method)
@@ -93,7 +90,8 @@ namespace Gendarme.Rules.Interoperability {
 
 			foreach (ParameterDefinition parameter in method.Parameters) {
 				if (IsStringOrSBuilder (parameter.ParameterType) && (parameter.MarshalInfo == null)) {
-					string text = string.Format ("Parameter '{0}', of type '{1}', does not have [MarshalAs] attribute, yet no [DllImport CharSet=] is set for the method '{2}'.",
+					string text = String.Format (CultureInfo.InvariantCulture, 
+						"Parameter '{0}', of type '{1}', does not have [MarshalAs] attribute, yet no [DllImport CharSet=] is set for the method '{2}'.",
 						parameter.Name, parameter.ParameterType.Name, method.Name);
 					Runner.Report (parameter, Severity.High, Confidence.Total, text);
 				}
diff --git a/gendarme/rules/Gendarme.Rules.Interoperability/README.md b/gendarme/rules/Gendarme.Rules.Interoperability/README.md
new file mode 100644
index 0000000..7932c1e
--- /dev/null
+++ b/gendarme/rules/Gendarme.Rules.Interoperability/README.md
@@ -0,0 +1,9 @@
+# Gendarme.Rules.Interoperability Rules
+
+You can access the latest rules documentation from our [[wiki|https://github.com/spouliot/gendarme/wiki/Gendarme.Rules.Interoperability(git)]] pages.
+
+
+## Feedback
+
+Please report any documentation errors, typos or suggestions to the [[Gendarme Mailing List|https://groups.google.com/forum/?fromgroups#!forum/gendarme]]. Thanks!
+
diff --git a/gendarme/rules/Gendarme.Rules.Interoperability/Test/Tests.Rules.Interoperability.csproj b/gendarme/rules/Gendarme.Rules.Interoperability/Test/Tests.Rules.Interoperability.csproj
index 8f6896b..ce293e7 100755
--- a/gendarme/rules/Gendarme.Rules.Interoperability/Test/Tests.Rules.Interoperability.csproj
+++ b/gendarme/rules/Gendarme.Rules.Interoperability/Test/Tests.Rules.Interoperability.csproj
@@ -1,5 +1,5 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
     <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
@@ -10,8 +10,28 @@
     <AppDesignerFolder>Properties</AppDesignerFolder>
     <RootNamespace>Tests.Rules.Interoperability</RootNamespace>
     <AssemblyName>Tests.Rules.Interoperability</AssemblyName>
-    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
     <FileAlignment>512</FileAlignment>
+    <FileUpgradeFlags>
+    </FileUpgradeFlags>
+    <OldToolsVersion>3.5</OldToolsVersion>
+    <UpgradeBackupLocation />
+    <PublishUrl>publish\</PublishUrl>
+    <Install>true</Install>
+    <InstallFrom>Disk</InstallFrom>
+    <UpdateEnabled>false</UpdateEnabled>
+    <UpdateMode>Foreground</UpdateMode>
+    <UpdateInterval>7</UpdateInterval>
+    <UpdateIntervalUnits>Days</UpdateIntervalUnits>
+    <UpdatePeriodically>false</UpdatePeriodically>
+    <UpdateRequired>false</UpdateRequired>
+    <MapFileExtensions>true</MapFileExtensions>
+    <ApplicationRevision>0</ApplicationRevision>
+    <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
+    <IsWebBootstrapper>false</IsWebBootstrapper>
+    <UseApplicationTrust>false</UseApplicationTrust>
+    <BootstrapperEnabled>true</BootstrapperEnabled>
+    <TargetFrameworkProfile />
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
     <DebugSymbols>true</DebugSymbols>
@@ -22,6 +42,7 @@
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
     <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
     <DebugType>pdbonly</DebugType>
@@ -31,6 +52,7 @@
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
     <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <ItemGroup>
     <Reference Include="nunit.framework, Version=2.4.8.0, Culture=neutral, PublicKeyToken=96d09a1eb7f44a77, processorArchitecture=MSIL">
@@ -73,6 +95,23 @@
   <ItemGroup>
     <Folder Include="Properties\" />
   </ItemGroup>
+  <ItemGroup>
+    <BootstrapperPackage Include="Microsoft.Net.Client.3.5">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1 Client Profile</ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Windows.Installer.3.1">
+      <Visible>False</Visible>
+      <ProductName>Windows Installer 3.1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+  </ItemGroup>
   <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
   <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
        Other similar extension points exist, see Microsoft.Common.targets.
diff --git a/gendarme/rules/Gendarme.Rules.Interoperability/UseManagedAlternativesToPInvokeRule.cs b/gendarme/rules/Gendarme.Rules.Interoperability/UseManagedAlternativesToPInvokeRule.cs
index 4f502cb..27c7d8f 100644
--- a/gendarme/rules/Gendarme.Rules.Interoperability/UseManagedAlternativesToPInvokeRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Interoperability/UseManagedAlternativesToPInvokeRule.cs
@@ -29,8 +29,9 @@
 //
 
 using System;
-using System.Linq;
 using System.Collections.Generic;
+using System.Globalization;
+using System.Linq;
 
 using Gendarme.Framework;
 using Mono.Cecil;
@@ -129,7 +130,8 @@ namespace Gendarme.Rules.Interoperability {
 			if (alternatives == null)
 				return RuleResult.Success;
 
-			string message = string.Format ("Try to replace the platform-dependent call '{0}' by (one of) the following alternative(s): {1}.",
+			string message = String.Format (CultureInfo.InvariantCulture, 
+				"Try to replace the platform-dependent call '{0}' by (one of) the following alternative(s): {1}.",
 				method.Name, alternatives.Alternatives);
 			Runner.Report (method, Severity.Low, Confidence.High, message);
 			return RuleResult.Failure;
diff --git a/gendarme/rules/Gendarme.Rules.Maintainability/AvoidAlwaysNullFieldRule.cs b/gendarme/rules/Gendarme.Rules.Maintainability/AvoidAlwaysNullFieldRule.cs
index 8fa7eb1..ac27858 100644
--- a/gendarme/rules/Gendarme.Rules.Maintainability/AvoidAlwaysNullFieldRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Maintainability/AvoidAlwaysNullFieldRule.cs
@@ -166,6 +166,16 @@ namespace Gendarme.Rules.Maintainability {
 				}
 			};
 		}
+
+		void CheckMethods (TypeDefinition type)
+		{
+			if (!type.HasMethods)
+				return;
+
+			IList<MethodDefinition> mc = type.Methods;
+			for (int i = 0; i < mc.Count && nullFields.Count > 0; ++i)
+				CheckMethod (mc [i]);
+		}
 		
 		public RuleResult CheckType (TypeDefinition type)
 		{
@@ -175,7 +185,7 @@ namespace Gendarme.Rules.Maintainability {
 			Log.WriteLine (this);
 			Log.WriteLine (this, "----------------------------------");
 			
-			bool isWinFormControl = usesWinForms && type.Inherits("System.Windows.Forms.Control");
+			bool isWinFormControl = usesWinForms && type.Inherits ("System.Windows.Forms", "Control");
 
 			// All fields start out as always null and unused.
 			foreach (FieldDefinition field in type.Fields) {
@@ -184,10 +194,10 @@ namespace Gendarme.Rules.Maintainability {
 						nullFields.Add (field);
 			}
 
-			if (type.HasMethods) {
-				IList<MethodDefinition> mc = type.Methods;
-				for (int i = 0; i < mc.Count && nullFields.Count > 0; ++i)
-					CheckMethod (mc [i]);
+			CheckMethods (type);
+			if (type.HasNestedTypes) {
+				foreach (TypeDefinition nested in type.NestedTypes)
+					CheckMethods (nested);
 			}
 				
 			// Report a defect if:
diff --git a/gendarme/rules/Gendarme.Rules.Maintainability/AvoidComplexMethodsRule.cs b/gendarme/rules/Gendarme.Rules.Maintainability/AvoidComplexMethodsRule.cs
index 46200ab..59d780d 100644
--- a/gendarme/rules/Gendarme.Rules.Maintainability/AvoidComplexMethodsRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Maintainability/AvoidComplexMethodsRule.cs
@@ -31,6 +31,7 @@
 using System;
 using System.Collections.Generic;
 using System.ComponentModel;
+using System.Globalization;
 
 using Mono.Cecil;
 using Mono.Cecil.Cil;
@@ -127,7 +128,8 @@ namespace Gendarme.Rules.Maintainability {
 			//how's severity?
 			Severity sev = GetCyclomaticComplexitySeverity(cc);
 
-			Runner.Report (method, sev, Confidence.High, String.Format ("Method's cyclomatic complexity : {0}.", cc));
+			string msg = String.Format (CultureInfo.CurrentCulture, "Method's cyclomatic complexity : {0}.", cc);
+			Runner.Report (method, sev, Confidence.High, msg);
 			return RuleResult.Failure;
 		}
 
diff --git a/gendarme/rules/Gendarme.Rules.Maintainability/AvoidDeepInheritanceTreeRule.cs b/gendarme/rules/Gendarme.Rules.Maintainability/AvoidDeepInheritanceTreeRule.cs
index a0e2af8..010ac00 100644
--- a/gendarme/rules/Gendarme.Rules.Maintainability/AvoidDeepInheritanceTreeRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Maintainability/AvoidDeepInheritanceTreeRule.cs
@@ -28,6 +28,7 @@
 
 using System;
 using System.ComponentModel;
+using System.Globalization;
 
 using Mono.Cecil;
 
@@ -84,11 +85,12 @@ namespace Gendarme.Rules.Maintainability {
 				return RuleResult.DoesNotApply;
 
 			int depth = 0;
-			while (type.BaseType != null) {
-				type = type.BaseType.Resolve ();
-				if (type == null)
+			TypeDefinition temp = type;
+			while (temp.BaseType != null) {
+				temp = temp.BaseType.Resolve();
+				if (temp == null)
 					break;
-				if (countExternalDepth || Runner.Assemblies.Contains (type.Module.Assembly))
+				if (countExternalDepth || Runner.Assemblies.Contains(temp.Module.Assembly))
 					depth++;
 			}
 
@@ -99,7 +101,8 @@ namespace Gendarme.Rules.Maintainability {
 			// where it's possible we can't resolve up to System.Object
 			Confidence confidence = countExternalDepth ? Confidence.High : Confidence.Total;
 			// Severity is based on the depth
-			Runner.Report (type, GetSeverity (depth), confidence, String.Format ("Inheritance tree depth : {0}.", depth));
+			string msg = String.Format (CultureInfo.CurrentCulture, "Inheritance tree depth : {0}.", depth);
+			Runner.Report (type, GetSeverity (depth), confidence, msg);
 			return RuleResult.Failure;
 		}
 	}
diff --git a/gendarme/rules/Gendarme.Rules.Maintainability/AvoidLackOfCohesionOfMethodsRule.cs b/gendarme/rules/Gendarme.Rules.Maintainability/AvoidLackOfCohesionOfMethodsRule.cs
index 4a428f0..44df73b 100644
--- a/gendarme/rules/Gendarme.Rules.Maintainability/AvoidLackOfCohesionOfMethodsRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Maintainability/AvoidLackOfCohesionOfMethodsRule.cs
@@ -31,6 +31,7 @@
 using System;
 using System.Collections.Generic;
 using System.ComponentModel;
+using System.Globalization;
 
 using Mono.Cecil;
 using Mono.Cecil.Cil;
@@ -88,7 +89,8 @@ namespace Gendarme.Rules.Maintainability {
 			//how's severity?
 			Severity sev = GetCohesivenessSeverity(coh);
 
-			Runner.Report (type, sev, Confidence.Normal, String.Format ("Type cohesiveness : {0}%", (int) (coh * 100)));
+			string msg = String.Format (CultureInfo.CurrentCulture, "Type cohesiveness : {0}%", (int) (coh * 100));
+			Runner.Report (type, sev, Confidence.Normal, msg);
 			return RuleResult.Failure;
 		}
 
diff --git a/gendarme/rules/Gendarme.Rules.Maintainability/AvoidUnnecessarySpecializationRule.cs b/gendarme/rules/Gendarme.Rules.Maintainability/AvoidUnnecessarySpecializationRule.cs
index c16bfbf..a906ebd 100644
--- a/gendarme/rules/Gendarme.Rules.Maintainability/AvoidUnnecessarySpecializationRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Maintainability/AvoidUnnecessarySpecializationRule.cs
@@ -215,7 +215,7 @@ namespace Gendarme.Rules.Maintainability {
 				if (pType is GenericParameter)
 					parameters [i] = null; //TODO: constructed mapping?
 				else
-					parameters [i] = pType.FullName;
+					parameters [i] = pType.GetFullName ();
 			}
 			return new MethodSignature (name, rtype, parameters);
 		}
@@ -225,7 +225,7 @@ namespace Gendarme.Rules.Maintainability {
 			//special exception
 			if (!method.HasParameters && (method.Name == "GetEnumerator"))
 				return null;
-			return method.ReturnType.FullName;
+			return method.ReturnType.GetFullName ();
 		}
 
 		private static bool IsSystemObjectMethod (MethodReference method)
@@ -250,7 +250,7 @@ namespace Gendarme.Rules.Maintainability {
 			//HACK: BOO:
 			case "EqualityOperator" :
 				return (method.HasParameters && (method.Parameters.Count == 2) && 
-					(method.DeclaringType.FullName == "Boo.Lang.Runtime.RuntimeServices"));
+					(method.DeclaringType.IsNamed ("Boo.Lang.Runtime", "RuntimeServices")));
 			}
 			return false;
 		}
@@ -262,7 +262,7 @@ namespace Gendarme.Rules.Maintainability {
 
 		private static bool IsIgnoredSuggestionType (TypeReference type)
 		{
-			return ((type.FullName == "System.Object") || IsFromNonGenericCollectionNamespace (type.Namespace));
+			return (type.IsNamed ("System", "Object") || IsFromNonGenericCollectionNamespace (type.Namespace));
 		}
 
 		private static List<MethodSignature> GetSignatures (IEnumerable<StackEntryUsageResult> usageResults)
@@ -285,7 +285,7 @@ namespace Gendarme.Rules.Maintainability {
 
 		private void UpdateParameterLeastType (ParameterReference parameter, IEnumerable<StackEntryUsageResult> usageResults)
 		{
-			int pIndex = parameter.GetSequence () - 1;
+			int pIndex = parameter.Index;
 			int parameterDepth = GetActualTypeDepth (parameter.ParameterType);
 
 			int currentLeastDepth = 0;
@@ -366,7 +366,7 @@ namespace Gendarme.Rules.Maintainability {
 
 				ParameterDefinition parameter = ins.GetParameter (method);
 				// this is `this`, we do not care
-				if ((parameter == null) || (parameter.GetSequence () == 0))
+				if ((parameter == null) || (parameter.Index == -1))
 					continue;
 
 				// is parameter already known ?
@@ -474,7 +474,7 @@ namespace Gendarme.Rules.Maintainability {
 		{
 			foreach (ParameterDefinition parameter in method.Parameters){
 
-				int i = parameter.GetSequence () - 1;
+				int i = parameter.Index;
 				if (null == types_least [i])
 					continue; //argument is not used
 
@@ -540,7 +540,7 @@ namespace Gendarme.Rules.Maintainability {
 			else
 				nRemoveTrail = 3;
 
-			string fullname = type.FullName;
+			string fullname = type.GetFullName ();
 			sb.Append (fullname.Substring (0, fullname.Length - nRemoveTrail));
 			if (count > 0) {
 				int n = 0;
diff --git a/gendarme/rules/Gendarme.Rules.Maintainability/ConsiderUsingStopwatchRule.cs b/gendarme/rules/Gendarme.Rules.Maintainability/ConsiderUsingStopwatchRule.cs
index 17a448f..79353c1 100644
--- a/gendarme/rules/Gendarme.Rules.Maintainability/ConsiderUsingStopwatchRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Maintainability/ConsiderUsingStopwatchRule.cs
@@ -77,9 +77,6 @@ namespace Gendarme.Rules.Maintainability {
 	[EngineDependency (typeof (OpCodeEngine))]
 	public class ConsiderUsingStopwatchRule : Rule, IMethodRule {
 
-		private const string DateTime = "System.DateTime";
-		private const string GetNow = "get_Now";
-
 		public override void Initialize (IRunner runner)
 		{
 			base.Initialize (runner);
@@ -90,8 +87,11 @@ namespace Gendarme.Rules.Maintainability {
 			// did not exist back then.
 			Runner.AnalyzeModule += delegate (object o, RunnerEventArgs e) {
 				Active = (e.CurrentModule.Runtime >= TargetRuntime.Net_2_0
-					&& (e.CurrentAssembly.Name.Name == "mscorlib"
-					|| e.CurrentModule.HasTypeReference (DateTime)));
+					&& (e.CurrentAssembly.Name.Name == "mscorlib" ||
+					e.CurrentModule.AnyTypeReference ((TypeReference tr) => {
+						return tr.IsNamed ("System", "DateTime");
+					}
+				)));
 			};
 		}
 
@@ -106,7 +106,7 @@ namespace Gendarme.Rules.Maintainability {
 				return false;
 
 			MethodReference calledMethod = (MethodReference) ins.Operand;
-			return calledMethod.DeclaringType.FullName == DateTime && calledMethod.Name == GetNow;
+			return calledMethod.IsNamed ("System", "DateTime", "get_Now");
 		}
 		
 		private static bool CheckParameters (MethodDefinition method, Instruction ins)
@@ -125,14 +125,14 @@ namespace Gendarme.Rules.Maintainability {
 				ParameterDefinition p = prev.GetParameter (method);
 				if (p == null)
 					return false;
-				int arg = p.GetSequence ();
+				int arg = p.Index;
 				prev = prev.Previous;
 				while (null != prev) {
 					// look for a STOBJ instruction and compare the objects
 					if (prev.OpCode.Code == Code.Stobj) {
 						prev = prev.TraceBack (method);
 						p = prev.GetParameter (method);
-						return (p == null) ? false : (arg == p.GetSequence ());
+						return (p == null) ? false : (arg == p.Index);
 					}
 					prev = prev.Previous;
 				}
@@ -161,11 +161,10 @@ namespace Gendarme.Rules.Maintainability {
 				return RuleResult.DoesNotApply;
 
 			foreach (Instruction ins in method.Body.Instructions) {
-				if (!calls.Get (ins.OpCode.Code))
+				MethodReference calledMethod = ins.GetMethod ();
+				if (calledMethod == null)
 					continue;
-
-				MethodReference calledMethod = (MethodReference) ins.Operand;
-				if (calledMethod.DeclaringType.FullName != DateTime)
+				if (!calledMethod.DeclaringType.IsNamed ("System", "DateTime"))
 					continue;
 				if (!MethodSignatures.op_Subtraction.Matches (calledMethod))
 					continue;
diff --git a/gendarme/rules/Gendarme.Rules.Maintainability/Gendarme.Rules.Maintainability.csproj b/gendarme/rules/Gendarme.Rules.Maintainability/Gendarme.Rules.Maintainability.csproj
index 3a4fd96..261474c 100755
--- a/gendarme/rules/Gendarme.Rules.Maintainability/Gendarme.Rules.Maintainability.csproj
+++ b/gendarme/rules/Gendarme.Rules.Maintainability/Gendarme.Rules.Maintainability.csproj
@@ -1,5 +1,5 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
     <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
@@ -10,8 +10,28 @@
     <AppDesignerFolder>Properties</AppDesignerFolder>
     <RootNamespace>Gendarme.Rules.Maintainability</RootNamespace>
     <AssemblyName>Gendarme.Rules.Maintainability</AssemblyName>
-    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
     <FileAlignment>512</FileAlignment>
+    <FileUpgradeFlags>
+    </FileUpgradeFlags>
+    <OldToolsVersion>3.5</OldToolsVersion>
+    <UpgradeBackupLocation />
+    <PublishUrl>publish\</PublishUrl>
+    <Install>true</Install>
+    <InstallFrom>Disk</InstallFrom>
+    <UpdateEnabled>false</UpdateEnabled>
+    <UpdateMode>Foreground</UpdateMode>
+    <UpdateInterval>7</UpdateInterval>
+    <UpdateIntervalUnits>Days</UpdateIntervalUnits>
+    <UpdatePeriodically>false</UpdatePeriodically>
+    <UpdateRequired>false</UpdateRequired>
+    <MapFileExtensions>true</MapFileExtensions>
+    <ApplicationRevision>0</ApplicationRevision>
+    <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
+    <IsWebBootstrapper>false</IsWebBootstrapper>
+    <UseApplicationTrust>false</UseApplicationTrust>
+    <BootstrapperEnabled>true</BootstrapperEnabled>
+    <TargetFrameworkProfile />
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
     <DebugSymbols>true</DebugSymbols>
@@ -24,6 +44,7 @@
     <NoWarn>1591</NoWarn>
     <WarningsAsErrors>1570</WarningsAsErrors>
     <DocumentationFile>..\..\console\bin\Debug\Gendarme.Rules.Maintainability.xml</DocumentationFile>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
     <DebugType>pdbonly</DebugType>
@@ -35,6 +56,7 @@
     <NoWarn>1591</NoWarn>
     <WarningsAsErrors>1570</WarningsAsErrors>
     <DocumentationFile>..\..\console\bin\Release\Gendarme.Rules.Maintainability.xml</DocumentationFile>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <ItemGroup>
     <Reference Include="System" />
@@ -67,6 +89,23 @@
       <Name>Gendarme.Framework</Name>
     </ProjectReference>
   </ItemGroup>
+  <ItemGroup>
+    <BootstrapperPackage Include="Microsoft.Net.Client.3.5">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1 Client Profile</ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Windows.Installer.3.1">
+      <Visible>False</Visible>
+      <ProductName>Windows Installer 3.1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+  </ItemGroup>
   <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
   <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
        Other similar extension points exist, see Microsoft.Common.targets.
diff --git a/gendarme/rules/Gendarme.Rules.Maintainability/PreferStringIsNullOrEmptyRule.cs b/gendarme/rules/Gendarme.Rules.Maintainability/PreferStringIsNullOrEmptyRule.cs
index fc5d1f8..efe4653 100644
--- a/gendarme/rules/Gendarme.Rules.Maintainability/PreferStringIsNullOrEmptyRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Maintainability/PreferStringIsNullOrEmptyRule.cs
@@ -116,7 +116,14 @@ namespace Gendarme.Rules.Maintainability {
 			case Code.Ldloc_S:
 				return (ins.Operand as VariableDefinition).Name;
 			default:
-				return (ins.Operand == null) ? String.Empty : ins.Operand.ToString ();
+				object o = ins.Operand;
+				MemberReference mr = (o as MemberReference);
+				if (mr != null)
+					return mr.GetFullName ();
+				else if (o != null)
+					return o.ToString ();
+				else
+					return String.Empty;
 			}
 		}
 
@@ -196,7 +203,7 @@ namespace Gendarme.Rules.Maintainability {
 					continue;
 
 				MethodReference mr = (current.Operand as MethodReference);
-				if ((mr.Name == "get_Length") && (mr.DeclaringType.FullName == "System.String")) {
+				if (mr.IsNamed ("System", "String", "get_Length")) {
 					// now that we found it we check that
 					// 1 - we previously did a check null on the same value (that we already know is a string)
 					Instruction branch = PreLengthCheck (method, current.Previous);
diff --git a/gendarme/rules/Gendarme.Rules.Maintainability/README.md b/gendarme/rules/Gendarme.Rules.Maintainability/README.md
new file mode 100644
index 0000000..d843fdd
--- /dev/null
+++ b/gendarme/rules/Gendarme.Rules.Maintainability/README.md
@@ -0,0 +1,9 @@
+# Gendarme.Rules.Maintainability Rules
+
+You can access the latest rules documentation from our [[wiki|https://github.com/spouliot/gendarme/wiki/Gendarme.Rules.Maintainability(git)]] pages.
+
+
+## Feedback
+
+Please report any documentation errors, typos or suggestions to the [[Gendarme Mailing List|https://groups.google.com/forum/?fromgroups#!forum/gendarme]]. Thanks!
+
diff --git a/gendarme/rules/Gendarme.Rules.Maintainability/RemoveDependenceOnObsoleteCodeRule.cs b/gendarme/rules/Gendarme.Rules.Maintainability/RemoveDependenceOnObsoleteCodeRule.cs
index 7686b8e..31868ea 100644
--- a/gendarme/rules/Gendarme.Rules.Maintainability/RemoveDependenceOnObsoleteCodeRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Maintainability/RemoveDependenceOnObsoleteCodeRule.cs
@@ -28,6 +28,7 @@
 
 using System;
 using System.Collections.Generic;
+using System.Globalization;
 
 using Mono.Cecil;
 using Mono.Cecil.Cil;
@@ -101,8 +102,6 @@ namespace Gendarme.Rules.Maintainability {
 	[EngineDependency (typeof (OpCodeEngine))]
 	public class RemoveDependenceOnObsoleteCodeRule : Rule, ITypeRule, IMethodRule {
 
-		const string Obsolete = "System.ObsoleteAttribute";
-
 		static Dictionary<TypeReference, bool> types = new Dictionary<TypeReference, bool> ();
 		static Dictionary<MethodReference, bool> methods = new Dictionary<MethodReference, bool> ();
 		static Dictionary<FieldReference, bool> fields = new Dictionary<FieldReference, bool> ();
@@ -115,7 +114,7 @@ namespace Gendarme.Rules.Maintainability {
 			bool obsolete = false;
 			if (!types.TryGetValue (type, out obsolete)) {
 				TypeDefinition t = type.Resolve ();
-				obsolete = t == null ? false : t.HasAttribute (Obsolete);
+				obsolete = t.HasAttribute ("System", "ObsoleteAttribute");
 				types.Add (type, obsolete);
 			}
 			return obsolete;
@@ -129,7 +128,7 @@ namespace Gendarme.Rules.Maintainability {
 			bool obsolete = false;
 			if (!methods.TryGetValue (method, out obsolete)) {
 				MethodDefinition md = method.Resolve ();
-				obsolete = (md == null) ? false : md.HasAttribute (Obsolete);
+				obsolete = md.HasAttribute ("System", "ObsoleteAttribute");
 				methods.Add (method, obsolete);
 			}
 			return obsolete;
@@ -143,7 +142,7 @@ namespace Gendarme.Rules.Maintainability {
 			bool obsolete = false;
 			if (!fields.TryGetValue (field, out obsolete)) {
 				FieldDefinition fd = field.Resolve ();
-				obsolete = (fd == null) ? false : fd.HasAttribute (Obsolete);
+				obsolete = fd.HasAttribute ("System", "ObsoleteAttribute");
 				fields.Add (field, obsolete);
 			}
 			return obsolete;
@@ -154,7 +153,7 @@ namespace Gendarme.Rules.Maintainability {
 			if (!IsObsolete (type.BaseType))
 				return;
 
-			string msg = String.Format ("Inherit from obsolete type '{0}'.", type.BaseType);
+			string msg = String.Format (CultureInfo.InvariantCulture, "Inherit from obsolete type '{0}'.", type.BaseType);
 			Runner.Report (type, type.IsVisible () ? Severity.High : Severity.Medium, Confidence.Total, msg);
 		}
 
@@ -162,7 +161,7 @@ namespace Gendarme.Rules.Maintainability {
 		{
 			foreach (TypeReference intf in type.Interfaces) {
 				if (IsObsolete (intf)) {
-					string msg = String.Format ("Implement obsolete interface '{0}'.", intf);
+					string msg = String.Format (CultureInfo.InvariantCulture, "Implement obsolete interface '{0}'.", intf);
 					Runner.Report (type, type.IsVisible () ? Severity.Medium : Severity.Low, Confidence.Total, msg);
 				}
 			}
@@ -172,7 +171,7 @@ namespace Gendarme.Rules.Maintainability {
 		{
 			foreach (FieldDefinition field in type.Fields) {
 				if (IsObsolete (field.FieldType)) {
-					string msg = String.Format ("Field type '{0}' is obsolete.", field.FieldType);
+					string msg = String.Format (CultureInfo.InvariantCulture, "Field type '{0}' is obsolete.", field.FieldType);
 					Runner.Report (field, field.IsVisible () ? Severity.Medium : Severity.Low, Confidence.Total, msg);
 				}
 			}
@@ -183,7 +182,7 @@ namespace Gendarme.Rules.Maintainability {
 		{
 			foreach (PropertyDefinition property in type.Properties) {
 				if (IsObsolete (property.PropertyType)) {
-					string msg = String.Format ("Property type '{0}' is obsolete.", property.PropertyType);
+					string msg = String.Format (CultureInfo.InvariantCulture, "Property type '{0}' is obsolete.", property.PropertyType);
 					bool visible = (IsVisible (property.GetMethod) || IsVisible (property.SetMethod));
 					Runner.Report (property, visible ? Severity.High : Severity.Medium, Confidence.Total, msg);
 				}
@@ -194,7 +193,7 @@ namespace Gendarme.Rules.Maintainability {
 		{
 			foreach (EventDefinition evnt in type.Events) {
 				if (IsObsolete (evnt.EventType)) {
-					string msg = String.Format ("Event type '{0}' is obsolete.", evnt.EventType);
+					string msg = String.Format (CultureInfo.InvariantCulture, "Event type '{0}' is obsolete.", evnt.EventType);
 					bool visible = (IsVisible (evnt.AddMethod) || IsVisible (evnt.RemoveMethod) || 
 						IsVisible (evnt.InvokeMethod));
 					Runner.Report (evnt, visible ? Severity.High : Severity.Medium, Confidence.Total, msg);
@@ -220,7 +219,7 @@ namespace Gendarme.Rules.Maintainability {
 		public RuleResult CheckType (TypeDefinition type)
 		{
 			// we're not interested in the details of [Obsolete] types
-			if (type.HasAttribute (Obsolete))
+			if (type.HasAttribute ("System", "ObsoleteAttribute"))
 				return RuleResult.DoesNotApply;
 
 			// check if we inherit from an [Obsolete] class / struct / enum
@@ -249,7 +248,7 @@ namespace Gendarme.Rules.Maintainability {
 		{
 			foreach (ParameterDefinition p in method.Parameters) {
 				if (IsObsolete (p.ParameterType)) {
-					string msg = String.Format ("Parameter type '{0}' is obsolete.", p.ParameterType);
+					string msg = String.Format (CultureInfo.InvariantCulture, "Parameter type '{0}' is obsolete.", p.ParameterType);
 					Runner.Report (p, method.IsVisible () ? Severity.High : Severity.Medium, Confidence.Total, msg);
 				}
 			}
@@ -261,7 +260,7 @@ namespace Gendarme.Rules.Maintainability {
 			if (!IsObsolete (rt))
 				return;
 
-			string msg = String.Format ("Return type '{0}' is obsolete.", rt);
+			string msg = String.Format (CultureInfo.InvariantCulture, "Return type '{0}' is obsolete.", rt);
 			Runner.Report (method, method.IsVisible () ? Severity.High : Severity.Medium, Confidence.Total, msg);
 		}
 
@@ -269,7 +268,7 @@ namespace Gendarme.Rules.Maintainability {
 		{
 			foreach (VariableDefinition v in method.Body.Variables) {
 				if (IsObsolete (v.VariableType)) {
-					string msg = String.Format ("Variable type '{0}' is obsolete.", v.VariableType);
+					string msg = String.Format (CultureInfo.InvariantCulture, "Variable type '{0}' is obsolete.", v.VariableType);
 					Runner.Report (method, Severity.Low, Confidence.High, msg);
 				}
 			}
@@ -280,7 +279,7 @@ namespace Gendarme.Rules.Maintainability {
 			if (!IsObsolete (type))
 				return;
 
-			string msg = String.Format ("Type '{0}' is obsolete.", type);
+			string msg = String.Format (CultureInfo.InvariantCulture, "Type '{0}' is obsolete.", type);
 			Severity severity = type.IsVisible () ? Severity.Medium : Severity.Low;
 			Runner.Report (method, ins, severity, Confidence.High, msg);
 		}
@@ -292,11 +291,11 @@ namespace Gendarme.Rules.Maintainability {
 
 			string msg = null;
 			if (IsObsolete (call)) {
-				msg = String.Format ("Method '{0}' is obsolete.", call);
+				msg = String.Format (CultureInfo.InvariantCulture, "Method '{0}' is obsolete.", call);
 			} else {
 				TypeReference type = call.DeclaringType;
 				if (IsObsolete (type))
-					msg = String.Format ("Type '{0}' is obsolete.", type);
+					msg = String.Format (CultureInfo.InvariantCulture, "Type '{0}' is obsolete.", type);
 			}
 
 			if (msg != null) {
@@ -312,9 +311,9 @@ namespace Gendarme.Rules.Maintainability {
 
 			string msg = null;
 			if (IsObsolete (field)) {
-				msg = String.Format ("Field '{0}' is obsolete.", field.Name);
+				msg = String.Format (CultureInfo.InvariantCulture, "Field '{0}' is obsolete.", field.Name);
 			} else if (IsObsolete (field.DeclaringType)) {
-				msg = String.Format ("Field type '{0}' is obsolete.", field.FieldType);
+				msg = String.Format (CultureInfo.InvariantCulture, "Field type '{0}' is obsolete.", field.FieldType);
 			} else {
 				return;
 			}
@@ -339,7 +338,7 @@ namespace Gendarme.Rules.Maintainability {
 				return RuleResult.DoesNotApply;
 
 			// if the method is obsolete (directly or because it's type is)
-			if (method.HasAttribute (Obsolete) || method.DeclaringType.HasAttribute (Obsolete))
+			if (method.HasAttribute ("System", "ObsoleteAttribute") || method.DeclaringType.HasAttribute ("System", "ObsoleteAttribute"))
 				return RuleResult.DoesNotApply;
 
 			// check method signature (parameters, return value)
diff --git a/gendarme/rules/Gendarme.Rules.Maintainability/ReviewMisleadingFieldNamesRule.cs b/gendarme/rules/Gendarme.Rules.Maintainability/ReviewMisleadingFieldNamesRule.cs
index 12999b3..6855c77 100644
--- a/gendarme/rules/Gendarme.Rules.Maintainability/ReviewMisleadingFieldNamesRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Maintainability/ReviewMisleadingFieldNamesRule.cs
@@ -26,32 +26,32 @@
 // WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 //
 
-
+using System;
 using Mono.Cecil;
-
 using Gendarme.Framework;
 
 namespace Gendarme.Rules.Maintainability {
 
 	/// <summary>
 	/// This rule checks for fields which have misleading names, e.g. instance fields beginning with "s_"
+	/// or static fields beginning with "m_", since they can be confusing when reading source code.
 	/// </summary>
 	/// <example>
 	/// Bad example:
 	/// <code>
-	///	public class Bad {
-	///		public int s_Value;
-	///		public static int m_OtherValue;
-	///	}
+	/// public class Bad {
+	///	int s_value;
+	///	static int m_other_value;
+	/// }
 	/// </code>
 	/// </example>
 	/// <example>
 	/// Good example:
 	/// <code>
-	///	public class Good {
-	///		public int m_Value;
-	///		public static int s_OtherValue;
-	///	}
+	/// public class Good {
+	///	int value;
+	///	static int other_value;
+	/// }
 	/// </code>
 	/// </example>
 
@@ -68,7 +68,8 @@ namespace Gendarme.Rules.Maintainability {
 
 			foreach (FieldDefinition field in type.Fields) {
 				string name = field.Name;
-				if (field.IsStatic ? name.StartsWith ("m_") : name.StartsWith ("s_"))
+				string prefix = field.IsStatic ? "m_" : "s_";
+				if (name.StartsWith (prefix, StringComparison.Ordinal))
 					Runner.Report (field, Severity.Low, Confidence.Total);
 			}
 
diff --git a/gendarme/rules/Gendarme.Rules.Maintainability/Test/AvoidAlwaysNullFieldTest.cs b/gendarme/rules/Gendarme.Rules.Maintainability/Test/AvoidAlwaysNullFieldTest.cs
index 95ac856..4307c2f 100644
--- a/gendarme/rules/Gendarme.Rules.Maintainability/Test/AvoidAlwaysNullFieldTest.cs
+++ b/gendarme/rules/Gendarme.Rules.Maintainability/Test/AvoidAlwaysNullFieldTest.cs
@@ -3,8 +3,10 @@
 //
 // Authors:
 //	Jesse Jones <jesjones@mindspring.com>
+//	Sebastien Pouliot <sebastien@ximian.com>
 //
 // Copyright (C) 2008 Jesse Jones
+// Copyright (C) 2011 Novell, Inc (http://www.novell.com)
 //
 // Permission is hereby granted, free of charge, to any person obtaining
 // a copy of this software and associated documentation files (the
@@ -29,8 +31,7 @@
 using System;
 using System.Collections.Generic;
 using System.Linq;
-using System.Runtime.InteropServices;
-using System.Text;
+using System.Threading;
 
 using Gendarme.Rules.Maintainability;
 
@@ -231,5 +232,51 @@ namespace Test.Rules.Maintainability {
 			AssertRuleSuccess<Bug667692a> ();
 			AssertRuleSuccess<Bug667692b> ();
 		}
+
+		// this will create an anonymous method
+		class AnonymousDelegatesAllFields {
+
+			string file;
+
+			void Parse ()
+			{
+				ThreadPool.QueueUserWorkItem (delegate {
+					file = ""; 
+				});
+			}
+
+			void Show ()
+			{
+				Console.WriteLine (file);
+			}
+		}
+
+		// this will create a nested type with the anonymous method
+		class AnonymousDelegatesFieldsAndLocals {
+
+			string file;
+
+			void Parse ()
+			{
+				string local;
+
+				ThreadPool.QueueUserWorkItem (delegate {
+					file = "";
+					local = file;
+				});
+			}
+
+			void Show ()
+			{
+				Console.WriteLine (file);
+			}
+		}
+
+		[Test]
+		public void AnonymousDelegates ()
+		{
+			AssertRuleSuccess<AnonymousDelegatesAllFields> ();
+			AssertRuleSuccess<AnonymousDelegatesFieldsAndLocals> ();
+		}
 	}
 }
diff --git a/gendarme/rules/Gendarme.Rules.Maintainability/Test/AvoidUnnecessarySpecializationTest.cs b/gendarme/rules/Gendarme.Rules.Maintainability/Test/AvoidUnnecessarySpecializationTest.cs
index c974504..1ae36c4 100644
--- a/gendarme/rules/Gendarme.Rules.Maintainability/Test/AvoidUnnecessarySpecializationTest.cs
+++ b/gendarme/rules/Gendarme.Rules.Maintainability/Test/AvoidUnnecessarySpecializationTest.cs
@@ -25,9 +25,10 @@
 // THE SOFTWARE.
 
 using System;
-using System.Reflection;
 using System.Collections;
 using System.Collections.Generic;
+using System.Linq;
+using System.Reflection;
 
 using Mono.Cecil;
 
@@ -631,5 +632,34 @@ namespace Test.Rules.Maintainability {
 			AssertRuleSuccess<GeneralizedClass> ("OverloadNotSupportedByInterface");
 			AssertRuleFailure<SpecializedClass> ("OverloadNotSupportedByInterface", 1);
 		}
+
+		class TestCase690057 {
+			public class nauczyciel {
+				public Guid Oid;
+				public List<object> NoweGrupies = new List<object> ();
+			}
+			public List<nauczyciel> nauczyciele = new List<nauczyciel> ();
+			public void WyslijMaile (List<Guid> ListIdJ, Guid idRok)
+			{
+
+				var cmd = from c in nauczyciele
+					  where ListIdJ.Contains (c.Oid)
+					  select c;
+				foreach (var s in cmd) {
+					try {
+						foreach (var grp in s.NoweGrupies)
+							;
+					}
+					catch (Exception ex) {
+					}
+				}
+			}
+		}
+		
+		[Test]
+		public void Bug690057 ()
+		{
+			AssertRuleSuccess<TestCase690057> ("WyslijMaile");
+		}
 	}
 }
diff --git a/gendarme/rules/Gendarme.Rules.Maintainability/Test/Tests.Rules.Maintainability.csproj b/gendarme/rules/Gendarme.Rules.Maintainability/Test/Tests.Rules.Maintainability.csproj
index f72d459..5f08e85 100755
--- a/gendarme/rules/Gendarme.Rules.Maintainability/Test/Tests.Rules.Maintainability.csproj
+++ b/gendarme/rules/Gendarme.Rules.Maintainability/Test/Tests.Rules.Maintainability.csproj
@@ -1,5 +1,5 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
     <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
@@ -10,8 +10,28 @@
     <AppDesignerFolder>Properties</AppDesignerFolder>
     <RootNamespace>Tests.Rules.Maintainability</RootNamespace>
     <AssemblyName>Tests.Rules.Maintainability</AssemblyName>
-    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
     <FileAlignment>512</FileAlignment>
+    <FileUpgradeFlags>
+    </FileUpgradeFlags>
+    <OldToolsVersion>3.5</OldToolsVersion>
+    <UpgradeBackupLocation />
+    <PublishUrl>publish\</PublishUrl>
+    <Install>true</Install>
+    <InstallFrom>Disk</InstallFrom>
+    <UpdateEnabled>false</UpdateEnabled>
+    <UpdateMode>Foreground</UpdateMode>
+    <UpdateInterval>7</UpdateInterval>
+    <UpdateIntervalUnits>Days</UpdateIntervalUnits>
+    <UpdatePeriodically>false</UpdatePeriodically>
+    <UpdateRequired>false</UpdateRequired>
+    <MapFileExtensions>true</MapFileExtensions>
+    <ApplicationRevision>0</ApplicationRevision>
+    <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
+    <IsWebBootstrapper>false</IsWebBootstrapper>
+    <UseApplicationTrust>false</UseApplicationTrust>
+    <BootstrapperEnabled>true</BootstrapperEnabled>
+    <TargetFrameworkProfile />
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
     <DebugSymbols>true</DebugSymbols>
@@ -21,6 +41,7 @@
     <DefineConstants>DEBUG;TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
     <DebugType>pdbonly</DebugType>
@@ -29,6 +50,7 @@
     <DefineConstants>TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <ItemGroup>
     <Reference Include="nunit.framework, Version=2.4.8.0, Culture=neutral, PublicKeyToken=96d09a1eb7f44a77, processorArchitecture=MSIL">
@@ -76,6 +98,23 @@
   <ItemGroup>
     <Folder Include="Properties\" />
   </ItemGroup>
+  <ItemGroup>
+    <BootstrapperPackage Include="Microsoft.Net.Client.3.5">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1 Client Profile</ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Windows.Installer.3.1">
+      <Visible>False</Visible>
+      <ProductName>Windows Installer 3.1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+  </ItemGroup>
   <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
   <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
        Other similar extension points exist, see Microsoft.Common.targets.
diff --git a/gendarme/rules/Gendarme.Rules.NUnit/Gendarme.Rules.NUnit.csproj b/gendarme/rules/Gendarme.Rules.NUnit/Gendarme.Rules.NUnit.csproj
index b621be2..6ce2d1d 100755
--- a/gendarme/rules/Gendarme.Rules.NUnit/Gendarme.Rules.NUnit.csproj
+++ b/gendarme/rules/Gendarme.Rules.NUnit/Gendarme.Rules.NUnit.csproj
@@ -1,72 +1,111 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <PropertyGroup>
-    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
-    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
-    <ProductVersion>9.0.30729</ProductVersion>
-    <SchemaVersion>2.0</SchemaVersion>
-    <ProjectGuid>{54625746-D966-4BC2-A465-8F0928A767E6}</ProjectGuid>
-    <OutputType>Library</OutputType>
-    <AppDesignerFolder>Properties</AppDesignerFolder>
-    <RootNamespace>Gendarme.Rules.NUnit</RootNamespace>
-    <AssemblyName>Gendarme.Rules.NUnit</AssemblyName>
-    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
-    <FileAlignment>512</FileAlignment>
-  </PropertyGroup>
-  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
-    <DebugSymbols>true</DebugSymbols>
-    <DebugType>full</DebugType>
-    <Optimize>false</Optimize>
-    <OutputPath>..\..\console\bin\Debug\</OutputPath>
-    <DefineConstants>DEBUG;TRACE</DefineConstants>
-    <ErrorReport>prompt</ErrorReport>
-    <WarningLevel>4</WarningLevel>
-    <DocumentationFile>..\..\console\bin\Debug\Gendarme.Rules.NUnit.xml</DocumentationFile>
-  </PropertyGroup>
-  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
-    <DebugType>pdbonly</DebugType>
-    <Optimize>true</Optimize>
-    <OutputPath>..\..\console\bin\Release\</OutputPath>
-    <DefineConstants>TRACE;RELEASE</DefineConstants>
-    <ErrorReport>prompt</ErrorReport>
-    <WarningLevel>4</WarningLevel>
-    <DocumentationFile>..\..\console\bin\Release\Gendarme.Rules.NUnit.xml</DocumentationFile>
-  </PropertyGroup>
-  <ItemGroup>
-    <Reference Include="System" />
-    <Reference Include="System.Core">
-      <RequiredTargetFramework>3.5</RequiredTargetFramework>
-    </Reference>
-  </ItemGroup>
-  <ItemGroup>
-    <Compile Include="..\..\AssemblyStaticInfo.cs">
-      <Link>AssemblyStaticInfo.cs</Link>
-    </Compile>
-    <Compile Include="NUnitRocks.cs" />
-    <Compile Include="NUnitRule.cs" />
-    <Compile Include="ProvideMessageOnAssertCallsRule.cs" />
-    <Compile Include="TestMethodsMustBePublicRule.cs" />
-    <Compile Include="UnitTestsMissingTestFixtureRule.cs" />
-  </ItemGroup>
-  <ItemGroup>
-    <ProjectReference Include="..\..\..\..\cecil\Mono.Cecil.csproj">
-      <Project>{D68133BD-1E63-496E-9EDE-4FBDBF77B486}</Project>
-      <Name>Mono.Cecil</Name>
-    </ProjectReference>
-    <ProjectReference Include="..\..\framework\Gendarme.Framework.csproj">
-      <Project>{CD6818D5-B398-486C-B180-92A07B143AFD}</Project>
-      <Name>Gendarme.Framework</Name>
-    </ProjectReference>
-  </ItemGroup>
-  <ItemGroup>
-    <Folder Include="Properties\" />
-  </ItemGroup>
-  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
+    <ProductVersion>9.0.30729</ProductVersion>
+    <SchemaVersion>2.0</SchemaVersion>
+    <ProjectGuid>{54625746-D966-4BC2-A465-8F0928A767E6}</ProjectGuid>
+    <OutputType>Library</OutputType>
+    <AppDesignerFolder>Properties</AppDesignerFolder>
+    <RootNamespace>Gendarme.Rules.NUnit</RootNamespace>
+    <AssemblyName>Gendarme.Rules.NUnit</AssemblyName>
+    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
+    <FileAlignment>512</FileAlignment>
+    <FileUpgradeFlags>
+    </FileUpgradeFlags>
+    <OldToolsVersion>3.5</OldToolsVersion>
+    <UpgradeBackupLocation />
+    <PublishUrl>publish\</PublishUrl>
+    <Install>true</Install>
+    <InstallFrom>Disk</InstallFrom>
+    <UpdateEnabled>false</UpdateEnabled>
+    <UpdateMode>Foreground</UpdateMode>
+    <UpdateInterval>7</UpdateInterval>
+    <UpdateIntervalUnits>Days</UpdateIntervalUnits>
+    <UpdatePeriodically>false</UpdatePeriodically>
+    <UpdateRequired>false</UpdateRequired>
+    <MapFileExtensions>true</MapFileExtensions>
+    <ApplicationRevision>0</ApplicationRevision>
+    <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
+    <IsWebBootstrapper>false</IsWebBootstrapper>
+    <UseApplicationTrust>false</UseApplicationTrust>
+    <BootstrapperEnabled>true</BootstrapperEnabled>
+    <TargetFrameworkProfile />
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
+    <DebugSymbols>true</DebugSymbols>
+    <DebugType>full</DebugType>
+    <Optimize>false</Optimize>
+    <OutputPath>..\..\console\bin\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+    <DocumentationFile>..\..\console\bin\Debug\Gendarme.Rules.NUnit.xml</DocumentationFile>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
+    <DebugType>pdbonly</DebugType>
+    <Optimize>true</Optimize>
+    <OutputPath>..\..\console\bin\Release\</OutputPath>
+    <DefineConstants>TRACE;RELEASE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+    <DocumentationFile>..\..\console\bin\Release\Gendarme.Rules.NUnit.xml</DocumentationFile>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
+  </PropertyGroup>
+  <ItemGroup>
+    <Reference Include="System" />
+    <Reference Include="System.Core">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+  </ItemGroup>
+  <ItemGroup>
+    <Compile Include="..\..\AssemblyStaticInfo.cs">
+      <Link>AssemblyStaticInfo.cs</Link>
+    </Compile>
+    <Compile Include="NUnitRocks.cs" />
+    <Compile Include="NUnitRule.cs" />
+    <Compile Include="ProvideMessageOnAssertCallsRule.cs" />
+    <Compile Include="TestMethodsMustBePublicRule.cs" />
+    <Compile Include="UnitTestsMissingTestFixtureRule.cs" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\..\..\..\cecil\Mono.Cecil.csproj">
+      <Project>{D68133BD-1E63-496E-9EDE-4FBDBF77B486}</Project>
+      <Name>Mono.Cecil</Name>
+    </ProjectReference>
+    <ProjectReference Include="..\..\framework\Gendarme.Framework.csproj">
+      <Project>{CD6818D5-B398-486C-B180-92A07B143AFD}</Project>
+      <Name>Gendarme.Framework</Name>
+    </ProjectReference>
+  </ItemGroup>
+  <ItemGroup>
+    <Folder Include="Properties\" />
+  </ItemGroup>
+  <ItemGroup>
+    <BootstrapperPackage Include="Microsoft.Net.Client.3.5">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1 Client Profile</ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Windows.Installer.3.1">
+      <Visible>False</Visible>
+      <ProductName>Windows Installer 3.1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+  </ItemGroup>
+  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
   <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
        Other similar extension points exist, see Microsoft.Common.targets.
   <Target Name="BeforeBuild">
   </Target>
   <Target Name="AfterBuild">
   </Target>
-  -->
+  -->
 </Project>
\ No newline at end of file
diff --git a/gendarme/rules/Gendarme.Rules.NUnit/ProvideMessageOnAssertCallsRule.cs b/gendarme/rules/Gendarme.Rules.NUnit/ProvideMessageOnAssertCallsRule.cs
index 4c58065..1e01a2b 100644
--- a/gendarme/rules/Gendarme.Rules.NUnit/ProvideMessageOnAssertCallsRule.cs
+++ b/gendarme/rules/Gendarme.Rules.NUnit/ProvideMessageOnAssertCallsRule.cs
@@ -95,7 +95,7 @@ namespace Gendarme.Rules.NUnit {
 					continue;
 
 				MethodReference m = (instruction.Operand as MethodReference);
-				if (m == null || m.DeclaringType.FullName != "NUnit.Framework.Assert" ||
+				if (m == null || !m.DeclaringType.IsNamed ("NUnit.Framework", "Assert") ||
 					exceptions.Contains (m.Name))
 					continue;
 
@@ -105,7 +105,7 @@ namespace Gendarme.Rules.NUnit {
 					if (resolvedMethod == null)
 						continue;
 					foreach (ParameterDefinition parameter in resolvedMethod.Parameters) {
-						if (parameter.ParameterType.FullName == "System.String" &&
+						if (parameter.ParameterType.IsNamed ("System", "String") &&
 							parameter.Name == "message") {
 							foundMessage = true;
 							break;
diff --git a/gendarme/rules/Gendarme.Rules.NUnit/README.md b/gendarme/rules/Gendarme.Rules.NUnit/README.md
new file mode 100644
index 0000000..00a3cb5
--- /dev/null
+++ b/gendarme/rules/Gendarme.Rules.NUnit/README.md
@@ -0,0 +1,9 @@
+# Gendarme.Rules.NUnit Rules
+
+You can access the latest rules documentation from our [[wiki|https://github.com/spouliot/gendarme/wiki/Gendarme.Rules.NUnit(git)]] pages.
+
+
+## Feedback
+
+Please report any documentation errors, typos or suggestions to the [[Gendarme Mailing List|https://groups.google.com/forum/?fromgroups#!forum/gendarme]]. Thanks!
+
diff --git a/gendarme/rules/Gendarme.Rules.NUnit/Test/Tests.Rules.NUnit.csproj b/gendarme/rules/Gendarme.Rules.NUnit/Test/Tests.Rules.NUnit.csproj
index 411ce56..7fc3ffe 100755
--- a/gendarme/rules/Gendarme.Rules.NUnit/Test/Tests.Rules.NUnit.csproj
+++ b/gendarme/rules/Gendarme.Rules.NUnit/Test/Tests.Rules.NUnit.csproj
@@ -1,5 +1,5 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
     <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
@@ -10,8 +10,28 @@
     <AppDesignerFolder>Properties</AppDesignerFolder>
     <RootNamespace>Tests.Rules.NUnit</RootNamespace>
     <AssemblyName>Tests.Rules.NUnit</AssemblyName>
-    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
     <FileAlignment>512</FileAlignment>
+    <FileUpgradeFlags>
+    </FileUpgradeFlags>
+    <OldToolsVersion>3.5</OldToolsVersion>
+    <UpgradeBackupLocation />
+    <PublishUrl>publish\</PublishUrl>
+    <Install>true</Install>
+    <InstallFrom>Disk</InstallFrom>
+    <UpdateEnabled>false</UpdateEnabled>
+    <UpdateMode>Foreground</UpdateMode>
+    <UpdateInterval>7</UpdateInterval>
+    <UpdateIntervalUnits>Days</UpdateIntervalUnits>
+    <UpdatePeriodically>false</UpdatePeriodically>
+    <UpdateRequired>false</UpdateRequired>
+    <MapFileExtensions>true</MapFileExtensions>
+    <ApplicationRevision>0</ApplicationRevision>
+    <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
+    <IsWebBootstrapper>false</IsWebBootstrapper>
+    <UseApplicationTrust>false</UseApplicationTrust>
+    <BootstrapperEnabled>true</BootstrapperEnabled>
+    <TargetFrameworkProfile />
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
     <DebugSymbols>true</DebugSymbols>
@@ -21,6 +41,7 @@
     <DefineConstants>DEBUG;TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
     <DebugType>pdbonly</DebugType>
@@ -29,6 +50,7 @@
     <DefineConstants>TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <ItemGroup>
     <Reference Include="nunit.framework, Version=2.4.8.0, Culture=neutral, PublicKeyToken=96d09a1eb7f44a77, processorArchitecture=MSIL">
@@ -68,6 +90,23 @@
   <ItemGroup>
     <Folder Include="Properties\" />
   </ItemGroup>
+  <ItemGroup>
+    <BootstrapperPackage Include="Microsoft.Net.Client.3.5">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1 Client Profile</ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Windows.Installer.3.1">
+      <Visible>False</Visible>
+      <ProductName>Windows Installer 3.1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+  </ItemGroup>
   <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
   <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
        Other similar extension points exist, see Microsoft.Common.targets.
diff --git a/gendarme/rules/Gendarme.Rules.NUnit/UnitTestsMissingTestFixtureRule.cs b/gendarme/rules/Gendarme.Rules.NUnit/UnitTestsMissingTestFixtureRule.cs
index 4b0164c..daa4721 100644
--- a/gendarme/rules/Gendarme.Rules.NUnit/UnitTestsMissingTestFixtureRule.cs
+++ b/gendarme/rules/Gendarme.Rules.NUnit/UnitTestsMissingTestFixtureRule.cs
@@ -81,7 +81,7 @@ namespace Gendarme.Rules.NUnit {
 			// check if TestFixture is applied to any type in the hierarchy
 			TypeDefinition testingType = type;
 			while (testingType != null) {
-				if (testingType.HasAttribute ("NUnit.Framework.TestFixtureAttribute"))
+				if (testingType.HasAttribute ("NUnit.Framework", "TestFixtureAttribute"))
 					return RuleResult.Success;
 				if (testingType.BaseType != null)
 					testingType = testingType.BaseType.Resolve ();
diff --git a/gendarme/rules/Gendarme.Rules.Naming/AvoidDeepNamespaceHierarchyRule.cs b/gendarme/rules/Gendarme.Rules.Naming/AvoidDeepNamespaceHierarchyRule.cs
index a8f2afa..f9d2783 100644
--- a/gendarme/rules/Gendarme.Rules.Naming/AvoidDeepNamespaceHierarchyRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Naming/AvoidDeepNamespaceHierarchyRule.cs
@@ -96,7 +96,9 @@ namespace Gendarme.Rules.Naming {
 		[DefaultValue (DefaultMaxDepth)]
 		[Description ("The depth at which namespaces may be nested without triggering a defect.")]
 		public int MaxDepth {
-			get { return max_depth; }
+			get {
+				return max_depth;
+			}
 			set {
 				if (value < 1)
 					throw new ArgumentOutOfRangeException ("MaxDepth", "Minimum: 1");
@@ -139,7 +141,7 @@ namespace Gendarme.Rules.Naming {
 				if (levels == MaxDepth + 1) {
 					if (NamespaceDefinition.IsSpecialized (ns)) {
 						continue;
-					} else if (ns.EndsWith (".Internal") || ns.EndsWith (".Impl")) {
+					} else if (ns.EndsWith (".Internal", StringComparison.Ordinal) || ns.EndsWith (".Impl", StringComparison.Ordinal)) {
 						continue;
 					}
 				}
@@ -149,5 +151,11 @@ namespace Gendarme.Rules.Naming {
 			}
 			return Runner.CurrentRuleResult;
 		}
+
+		public override string Solution {
+			get {
+				return string.Format("Try to keep the depth below {0}, with an additional one for specialization (e.g. Design, Interop, Permissions).", MaxDepth);
+			}
+		}
 	}
 }
diff --git a/gendarme/rules/Gendarme.Rules.Naming/AvoidRedundancyInMethodNameRule.cs b/gendarme/rules/Gendarme.Rules.Naming/AvoidRedundancyInMethodNameRule.cs
index 305f23b..2bff9a0 100644
--- a/gendarme/rules/Gendarme.Rules.Naming/AvoidRedundancyInMethodNameRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Naming/AvoidRedundancyInMethodNameRule.cs
@@ -26,6 +26,7 @@
 // WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 using System;
+using System.Globalization;
 
 using Mono.Cecil;
 
@@ -138,7 +139,7 @@ namespace Gendarme.Rules.Naming {
 			if (method_name.StartsWith (name, StringComparison.Ordinal))
 				return RuleResult.Success;
 
-			int pos = method_name.LastIndexOf (name);
+			int pos = method_name.LastIndexOf (name, StringComparison.Ordinal);
 			if (-1 == pos)
 				return RuleResult.Success;
 
@@ -159,10 +160,11 @@ namespace Gendarme.Rules.Naming {
 			string msg;
 			if (method.IsStatic) { //we already have a rule that checks if the method should be static
 				string memberKind = GetSuggestionMemberKind (method);
-				msg = String.Format ("Consider renaming method to '{2}', or extracting method to type '{0}' as {1} '{2}', or making an extension method of that type.", 
+				msg = String.Format (CultureInfo.InvariantCulture, 
+					"Consider renaming method to '{2}', or extracting method to type '{0}' as {1} '{2}', or making an extension method of that type.", 
 					p0.ParameterType, memberKind, suggestion);
 			} else {
-				msg = String.Format ("Consider renaming method to '{0}'.", suggestion);
+				msg = String.Format (CultureInfo.InvariantCulture, "Consider renaming method to '{0}'.", suggestion);
 			}
 
 			Runner.Report (method, severity, confidence, msg);
@@ -184,7 +186,7 @@ namespace Gendarme.Rules.Naming {
 
 		private static string GetSuggestionMemberKind (IMethodSignature method)
 		{
-			if (method.Parameters.Count == 1 && method.ReturnType.FullName != "System.Void")
+			if (method.Parameters.Count == 1 && !method.ReturnType.IsNamed ("System", "Void"))
 				return "property";
 			return "method";
 		}
diff --git a/gendarme/rules/Gendarme.Rules.Naming/AvoidRedundancyInTypeNameRule.cs b/gendarme/rules/Gendarme.Rules.Naming/AvoidRedundancyInTypeNameRule.cs
index b050cb5..7a36180 100644
--- a/gendarme/rules/Gendarme.Rules.Naming/AvoidRedundancyInTypeNameRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Naming/AvoidRedundancyInTypeNameRule.cs
@@ -27,6 +27,7 @@
 
 using System;
 using System.Collections.Generic;
+using System.Globalization;
 
 using Mono.Cecil;
 
@@ -94,6 +95,7 @@ namespace Gendarme.Rules.Naming {
 	[Problem ("This type name is prefixed with the last component of its enclosing namespace. This usually makes an API more verbose and less autocompletion-friendly than necessary.")]
 	[Solution ("Remove the prefix from the type or replace it with a more meaningful term in the context of the namespace.")]
 	[EngineDependency (typeof (NamespaceEngine))]
+	[FxCopCompatibility ("Microsoft.Naming", "CA1724:TypeNamesShouldNotMatchNamespaces")]
 	public class AvoidRedundancyInTypeNameRule : Rule, ITypeRule {
 
 		public RuleResult CheckType (TypeDefinition type)
@@ -153,7 +155,7 @@ namespace Gendarme.Rules.Naming {
 			//main goal is to keep the API as simple as possible so this is more severe for visible types
 			Severity severity = type.IsVisible () ? Severity.Medium : Severity.Low;
 
-			string msg = String.Format ("Consider renaming type to '{0}'.", suggestion);
+			string msg = String.Format (CultureInfo.InvariantCulture, "Consider renaming type to '{0}'.", suggestion);
 			Runner.Report (type, severity, Confidence.Normal, msg);
 			return RuleResult.Failure;
 		}
diff --git a/gendarme/rules/Gendarme.Rules.Naming/AvoidTypeInterfaceInconsistencyRule.cs b/gendarme/rules/Gendarme.Rules.Naming/AvoidTypeInterfaceInconsistencyRule.cs
index 0570b72..0d47376 100644
--- a/gendarme/rules/Gendarme.Rules.Naming/AvoidTypeInterfaceInconsistencyRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Naming/AvoidTypeInterfaceInconsistencyRule.cs
@@ -92,11 +92,11 @@ namespace Gendarme.Rules.Naming {
 			if (name [0] != 'I')
 				return RuleResult.DoesNotApply;
 
-			string candidate_name = String.Concat (type.Namespace, ".", name.Substring (1));
-			TypeDefinition candidate = type.Module.GetType (candidate_name);
+			string nspace = type.Namespace;
+			TypeDefinition candidate = type.Module.GetType (nspace, name.Substring (1));
 			if (candidate != null) {
 				// does Foo implement IFoo ?
-				if (!candidate.Implements (type.FullName)) {
+				if (!candidate.Implements (nspace, name)) {
 					Runner.Report (candidate, Severity.High, Confidence.High);
 				}
 			}
diff --git a/gendarme/rules/Gendarme.Rules.Naming/DetectNonAlphaNumericsInTypeNamesRule.cs b/gendarme/rules/Gendarme.Rules.Naming/DetectNonAlphaNumericsInTypeNamesRule.cs
index 9bb8063..972d031 100644
--- a/gendarme/rules/Gendarme.Rules.Naming/DetectNonAlphaNumericsInTypeNamesRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Naming/DetectNonAlphaNumericsInTypeNamesRule.cs
@@ -98,9 +98,6 @@ namespace Gendarme.Rules.Naming {
 	[FxCopCompatibility ("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
 	public class AvoidNonAlphanumericIdentifierRule : Rule, IAssemblyRule, IMethodRule, ITypeRule {
 
-		private const string GuidAttribute = "System.Runtime.InteropServices.GuidAttribute";
-		private const string InterfaceTypeAttribute = "System.Runtime.InteropServices.InterfaceTypeAttribute";
-
 		// Compiler generates an error for any other non alpha-numerics than underscore ('_'), 
 		// so we just need to check the presence of underscore in method names
 		private static bool CheckName (string name, bool special)
@@ -111,8 +108,8 @@ namespace Gendarme.Rules.Naming {
 
 		private static bool UsedForComInterop (TypeDefinition type)
 		{
-			return (type.IsInterface && type.HasAttribute (GuidAttribute) &&
-				type.HasAttribute (InterfaceTypeAttribute));
+			return (type.IsInterface && type.HasAttribute ("System.Runtime.InteropServices", "GuidAttribute") &&
+				type.HasAttribute ("System.Runtime.InteropServices", "InterfaceTypeAttribute"));
 		}
 
 		public RuleResult CheckAssembly (AssemblyDefinition assembly)
diff --git a/gendarme/rules/Gendarme.Rules.Naming/Gendarme.Rules.Naming.csproj b/gendarme/rules/Gendarme.Rules.Naming/Gendarme.Rules.Naming.csproj
index bfb1fbe..8de71e4 100755
--- a/gendarme/rules/Gendarme.Rules.Naming/Gendarme.Rules.Naming.csproj
+++ b/gendarme/rules/Gendarme.Rules.Naming/Gendarme.Rules.Naming.csproj
@@ -1,5 +1,5 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
     <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
@@ -10,8 +10,28 @@
     <AppDesignerFolder>Properties</AppDesignerFolder>
     <RootNamespace>Gendarme.Rules.Naming</RootNamespace>
     <AssemblyName>Gendarme.Rules.Naming</AssemblyName>
-    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
     <FileAlignment>512</FileAlignment>
+    <FileUpgradeFlags>
+    </FileUpgradeFlags>
+    <OldToolsVersion>3.5</OldToolsVersion>
+    <UpgradeBackupLocation />
+    <PublishUrl>publish\</PublishUrl>
+    <Install>true</Install>
+    <InstallFrom>Disk</InstallFrom>
+    <UpdateEnabled>false</UpdateEnabled>
+    <UpdateMode>Foreground</UpdateMode>
+    <UpdateInterval>7</UpdateInterval>
+    <UpdateIntervalUnits>Days</UpdateIntervalUnits>
+    <UpdatePeriodically>false</UpdatePeriodically>
+    <UpdateRequired>false</UpdateRequired>
+    <MapFileExtensions>true</MapFileExtensions>
+    <ApplicationRevision>0</ApplicationRevision>
+    <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
+    <IsWebBootstrapper>false</IsWebBootstrapper>
+    <UseApplicationTrust>false</UseApplicationTrust>
+    <BootstrapperEnabled>true</BootstrapperEnabled>
+    <TargetFrameworkProfile />
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
     <DebugSymbols>true</DebugSymbols>
@@ -24,6 +44,7 @@
     <DocumentationFile>..\..\console\bin\Debug\Gendarme.Rules.Naming.xml</DocumentationFile>
     <NoWarn>1591</NoWarn>
     <WarningsAsErrors>1570</WarningsAsErrors>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
     <DebugType>pdbonly</DebugType>
@@ -35,6 +56,7 @@
     <NoWarn>1591</NoWarn>
     <WarningsAsErrors>1570</WarningsAsErrors>
     <DocumentationFile>..\..\console\bin\Release\Gendarme.Rules.Naming.xml</DocumentationFile>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <ItemGroup>
     <Compile Include="..\..\AssemblyStaticInfo.cs">
@@ -72,6 +94,23 @@
       <RequiredTargetFramework>3.5</RequiredTargetFramework>
     </Reference>
   </ItemGroup>
+  <ItemGroup>
+    <BootstrapperPackage Include="Microsoft.Net.Client.3.5">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1 Client Profile</ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Windows.Installer.3.1">
+      <Visible>False</Visible>
+      <ProductName>Windows Installer 3.1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+  </ItemGroup>
   <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
   <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
        Other similar extension points exist, see Microsoft.Common.targets.
diff --git a/gendarme/rules/Gendarme.Rules.Naming/ParameterNamesShouldMatchOverridenMethodRule.cs b/gendarme/rules/Gendarme.Rules.Naming/ParameterNamesShouldMatchOverridenMethodRule.cs
index 95a3e46..7e4a8db 100644
--- a/gendarme/rules/Gendarme.Rules.Naming/ParameterNamesShouldMatchOverridenMethodRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Naming/ParameterNamesShouldMatchOverridenMethodRule.cs
@@ -3,8 +3,10 @@
 //
 // Authors:
 //	Andreas Noever <andreas.noever@gmail.com>
+//	Sebastien Pouliot  <sebastien@ximian.com>
 //
 //  (C) 2008 Andreas Noever
+// Copyright (C) 2011 Novell, Inc (http://www.novell.com)
 //
 // Permission is hereby granted, free of charge, to any person obtaining
 // a copy of this software and associated documentation files (the
@@ -84,8 +86,10 @@ namespace Gendarme.Rules.Naming {
 			base.Initialize (runner);
 
 			//check if this is a Boo assembly using macros
-			Runner.AnalyzeAssembly += delegate (object o, RunnerEventArgs e) {
-				IsBooAssemblyUsingMacro = (e.CurrentAssembly.MainModule.HasTypeReference (BooMacroStatement));
+			Runner.AnalyzeModule += delegate (object o, RunnerEventArgs e) {
+				IsBooAssemblyUsingMacro = (e.CurrentModule.AnyTypeReference ((TypeReference tr) => {
+					return tr.IsNamed ("Boo.Lang.Compiler.Ast", "MacroStatement");
+				}));
 			};
 		}
 
@@ -97,29 +101,26 @@ namespace Gendarme.Rules.Naming {
 			if (name != base_name) {
 				if (!explicitInterfaceCheck)
 					return false;
-				string full_name = baseMethod.DeclaringType.FullName;
-				if (!name.StartsWith (full_name, StringComparison.Ordinal))
+
+				TypeReference btype = baseMethod.DeclaringType;
+				string bnspace = btype.Namespace;
+				if (!name.StartsWith (bnspace, StringComparison.Ordinal))
 					return false;
-				if (name [full_name.Length] != '.')
+				if (name [bnspace.Length] != '.')
 					return false;
-				if (name.LastIndexOf (base_name, StringComparison.Ordinal) != full_name.Length + 1)
+
+				string bname = btype.Name;
+				if (String.CompareOrdinal (bname, 0, name, bnspace.Length + 1, bname.Length) != 0)
 					return false;
-			}
-			if (method.ReturnType.FullName != baseMethod.ReturnType.FullName)
-				return false;
-			if (method.HasParameters != baseMethod.HasParameters)
-				return false;
 
-			IList<ParameterDefinition> pdc = method.Parameters;
-			IList<ParameterDefinition> base_pdc = baseMethod.Parameters;
-			if (pdc.Count != base_pdc.Count)
-				return false;
+				int dot = bnspace.Length + bname.Length + 1;
+				if (name [dot] != '.')
+					return false;
 
-			for (int i = 0; i < pdc.Count; i++) {
-				if (pdc [i].ParameterType != base_pdc [i].ParameterType)
+				if (name.LastIndexOf (base_name, StringComparison.Ordinal) != dot + 1)
 					return false;
 			}
-			return true;
+			return method.CompareSignature (baseMethod);
 		}
 
 		private static MethodDefinition GetBaseMethod (MethodDefinition method)
@@ -130,7 +131,7 @@ namespace Gendarme.Rules.Naming {
 
 			while ((baseType.BaseType != null) && (baseType != baseType.BaseType)) {
 				baseType = baseType.BaseType.Resolve ();
-				if (baseType == null)
+				if ((baseType == null) || !baseType.HasMethods)
 					return null;		// could not resolve
 
 				foreach (MethodDefinition baseMethodCandidate in baseType.Methods) {
@@ -143,11 +144,15 @@ namespace Gendarme.Rules.Naming {
 
 		private static MethodDefinition GetInterfaceMethod (MethodDefinition method)
 		{
-			TypeDefinition type = (TypeDefinition) method.DeclaringType;
+			TypeDefinition type = (method.DeclaringType as TypeDefinition);
+			if (!type.HasInterfaces)
+				return null;
+
 			foreach (TypeReference interfaceReference in type.Interfaces) {
 				TypeDefinition interfaceCandidate = interfaceReference.Resolve ();
-				if (interfaceCandidate == null)
+				if ((interfaceCandidate == null) || !interfaceCandidate.HasMethods)
 					continue;
+
 				foreach (MethodDefinition interfaceMethodCandidate in interfaceCandidate.Methods) {
 					if (SignatureMatches (method, interfaceMethodCandidate, true))
 						return interfaceMethodCandidate;
@@ -177,7 +182,8 @@ namespace Gendarme.Rules.Naming {
 			IList<ParameterDefinition> pdc = method.Parameters;
 			for (int i = 0; i < pdc.Count; i++) {
 				if (pdc [i].Name != base_pdc [i].Name) {
-					string s = string.Format ("The name of parameter #{0} ({1}) does not match the name of the parameter in the overriden method ({2}).", 
+					string s = String.Format (CultureInfo.InvariantCulture,
+						"The name of parameter #{0} ({1}) does not match the name of the parameter in the overriden method ({2}).", 
 						i + 1, pdc [i].Name, base_pdc [i].Name);
 					Runner.Report (method, Severity.Medium, Confidence.High, s);
 				}
@@ -185,21 +191,11 @@ namespace Gendarme.Rules.Naming {
 			return Runner.CurrentRuleResult;
 		}
 
-		private const string BooMacroStatement = "Boo.Lang.Compiler.Ast.MacroStatement";
-
-		private bool IsBooAssemblyUsingMacro {
-			get {
-				return isBooAssemblyUsingMacro;
-			}
-			set {
-				isBooAssemblyUsingMacro = value;
-			}
-		}
-		private bool isBooAssemblyUsingMacro;
+		private bool IsBooAssemblyUsingMacro { get; set; }
 
 		private static bool IsBooMacroParameter (ParameterReference p)
 		{
-			return p.Name == "macro" && p.ParameterType.FullName == BooMacroStatement;
+			return p.Name == "macro" && p.ParameterType.IsNamed ("Boo.Lang.Compiler.Ast", "MacroStatement");
 		}
 	}
 }
diff --git a/gendarme/rules/Gendarme.Rules.Naming/README.md b/gendarme/rules/Gendarme.Rules.Naming/README.md
new file mode 100644
index 0000000..a5e5992
--- /dev/null
+++ b/gendarme/rules/Gendarme.Rules.Naming/README.md
@@ -0,0 +1,9 @@
+# Gendarme.Rules.Naming Rules
+
+You can access the latest rules documentation from our [[wiki|https://github.com/spouliot/gendarme/wiki/Gendarme.Rules.Naming(git)]] pages.
+
+
+## Feedback
+
+Please report any documentation errors, typos or suggestions to the [[Gendarme Mailing List|https://groups.google.com/forum/?fromgroups#!forum/gendarme]]. Thanks!
+
diff --git a/gendarme/rules/Gendarme.Rules.Naming/Test/ParameterNamesShouldMatchOverridenMethodTest.cs b/gendarme/rules/Gendarme.Rules.Naming/Test/ParameterNamesShouldMatchOverridenMethodTest.cs
index ff5fc3a..7baa37f 100644
--- a/gendarme/rules/Gendarme.Rules.Naming/Test/ParameterNamesShouldMatchOverridenMethodTest.cs
+++ b/gendarme/rules/Gendarme.Rules.Naming/Test/ParameterNamesShouldMatchOverridenMethodTest.cs
@@ -3,8 +3,10 @@
 //
 // Authors:
 //	Andreas Noever <andreas.noever@gmail.com>
+//	Sebastien Pouliot  <sebastien@ximian.com>
 //
 //  (C) 2008 Andreas Noever
+// Copyright (C) 2011 Novell, Inc (http://www.novell.com)
 //
 // Permission is hereby granted, free of charge, to any person obtaining
 // a copy of this software and associated documentation files (the
@@ -27,15 +29,12 @@
 //
 
 using System;
-using System.Reflection;
 
-using Gendarme.Framework;
+using Gendarme.Framework.Helpers;
 using Gendarme.Rules.Naming;
-using Gendarme.Framework.Rocks;
-using Mono.Cecil;
 
 using NUnit.Framework;
-using Test.Rules.Helpers;
+using Test.Rules.Fixtures;
 
 namespace Test.Rules.Naming {
 
@@ -75,141 +74,94 @@ namespace Test.Rules.Naming {
 	}
 
 	[TestFixture]
-	public class ParameterNamesShouldMatchOverridenMethodTest : BaseClass, ISomeInterface, ISomeInterface2 {
+	public class ParameterNamesShouldMatchOverridenMethodTest : MethodRuleTestFixture<ParameterNamesShouldMatchOverriddenMethodRule> {
 
-		private ParameterNamesShouldMatchOverriddenMethodRule rule;
-		private AssemblyDefinition assembly;
-		private TypeDefinition type;
-		private TestRunner runner;
+		class TestCase : BaseClass, ISomeInterface, ISomeInterface2, IEquatable<string> {
+			protected override void VirtualCorrect (int vc1, int vc2)
+			{
+			}
 
-		[TestFixtureSetUp]
-		public void FixtureSetUp ()
-		{
-			string unit = Assembly.GetExecutingAssembly ().Location;
-			assembly = AssemblyDefinition.ReadAssembly (unit);
-			type = assembly.MainModule.GetType ("Test.Rules.Naming.ParameterNamesShouldMatchOverridenMethodTest");
-			rule = new ParameterNamesShouldMatchOverriddenMethodRule ();
-			runner = new TestRunner (rule);
-		}
+			protected override void VirtualIncorrect (int vi1, int vi2a)
+			{
+			}
 
-		private MethodDefinition GetTest (string name)
-		{
-			foreach (MethodDefinition method in type.Methods) {
-				if (method.Name == name)
-					return method;
+			protected override void VirtualSuperIncorrect (int vsi1, bool vsi2_)
+			{
 			}
-			return null;
-		}
 
-		protected override void VirtualCorrect (int vc1, int vc2)
-		{
-		}
+			protected override void AbstractCorrect (int ac1, int ac2)
+			{
+				throw new NotImplementedException ();
+			}
 
-		[Test]
-		public void TestVirtualCorrect ()
-		{
-			MethodDefinition method = GetTest ("VirtualCorrect");
-			Assert.AreEqual (RuleResult.Success, runner.CheckMethod (method), "RuleResult");
-			Assert.AreEqual (0, runner.Defects.Count, "Count");
-		}
+			protected override void AbstractIncorrect (int ai1, int ai2_)
+			{
+				throw new NotImplementedException ();
+			}
 
-		protected override void VirtualIncorrect (int vi1, int vi2a)
-		{
-		}
+			protected virtual void NoOverwrite (int a, int bb)
+			{
+			}
 
-		[Test]
-		public void TestVirtualIncorrect ()
-		{
-			MethodDefinition method = GetTest ("VirtualIncorrect");
-			Assert.AreEqual (RuleResult.Failure, runner.CheckMethod (method), "RuleResult");
-			Assert.AreEqual (1, runner.Defects.Count, "Count");
-		}
+			public bool InterfaceMethod (int im_)
+			{
+				return false;
+			}
 
-		protected override void VirtualSuperIncorrect (int vsi1, bool vsi2_)
-		{
-		}
+			bool ISomeInterface2.InterfaceMethod2 (int im_)
+			{
+				return false;
+			}
 
-		[Test]
-		public void TestVirtualSuperIncorrect ()
-		{
-			MethodDefinition method = GetTest ("VirtualSuperIncorrect");
-			Assert.AreEqual (RuleResult.Failure, runner.CheckMethod (method), "RuleResult");
-			Assert.AreEqual (1, runner.Defects.Count, "Count");
-		}
+			void NoParameter ()
+			{
+			}
 
-		protected override void AbstractCorrect (int ac1, int ac2)
-		{
-			throw new NotImplementedException ();
+			public bool Equals (string s)
+			{
+				throw new NotImplementedException ();
+			}
 		}
 
 		[Test]
-		public void TestAbstractCorrect ()
+		public void TestVirtual ()
 		{
-			MethodDefinition method = GetTest ("AbstractCorrect");
-			Assert.AreEqual (RuleResult.Success, runner.CheckMethod (method), "RuleResult");
-			Assert.AreEqual (0, runner.Defects.Count, "Count");
-		}
-
-		protected override void AbstractIncorrect (int ai1, int ai2_)
-		{
-			throw new NotImplementedException ();
+			AssertRuleSuccess<TestCase> ("VirtualCorrect");
+			AssertRuleFailure<TestCase> ("VirtualIncorrect", 1);
+			AssertRuleFailure<TestCase> ("VirtualSuperIncorrect", 1);
 		}
 
 		[Test]
-		public void TestAbstractIncorrect ()
-		{
-			MethodDefinition method = GetTest ("AbstractIncorrect");
-			Assert.AreEqual (RuleResult.Failure, runner.CheckMethod (method), "RuleResult");
-			Assert.AreEqual (1, runner.Defects.Count, "Count");
-		}
-
-		protected virtual void NoOverwrite (int a, int bb)
+		public void TestAbstract ()
 		{
+			AssertRuleSuccess<TestCase> ("AbstractCorrect");
+			AssertRuleFailure<TestCase> ("AbstractIncorrect", 1);
 		}
 
 		[Test]
 		public void TestNoOverwrite ()
 		{
-			MethodDefinition method = GetTest ("NoOverwrite");
-			Assert.AreEqual (RuleResult.Success, runner.CheckMethod (method), "RuleResult");
-			Assert.AreEqual (0, runner.Defects.Count, "Count");
-		}
-
-		public bool InterfaceMethod (int im_)
-		{
-			return false;
+			AssertRuleSuccess<TestCase> ("NoOverwrite");
 		}
 
 		[Test]
 		public void TestInterfaceMethod ()
 		{
-			MethodDefinition method = GetTest ("InterfaceMethod");
-			Assert.AreEqual (RuleResult.Failure, runner.CheckMethod (method), "RuleResult");
-			Assert.AreEqual (1, runner.Defects.Count, "Count");
-		}
-
-		bool ISomeInterface2.InterfaceMethod2 (int im_)
-		{
-			return false;
+			AssertRuleFailure<TestCase> ("InterfaceMethod", 1);
+			AssertRuleFailure<TestCase> ("Test.Rules.Naming.ISomeInterface2.InterfaceMethod2", 1);
 		}
 
 		[Test]
-		public void TestInterfaceMethod2 ()
-		{
-			MethodDefinition method = GetTest ("Test.Rules.Naming.ISomeInterface2.InterfaceMethod2");
-			Assert.AreEqual (RuleResult.Failure, runner.CheckMethod (method), "RuleResult");
-			Assert.AreEqual (1, runner.Defects.Count, "Count");
-		}
-
-		void NoParameter ()
+		public void TestDoesNotApply ()
 		{
+			AssertRuleDoesNotApply<TestCase> ("NoParameter");
 		}
 
 		[Test]
-		public void TestDoesNotApply ()
+		public void GenericInterface ()
 		{
-			MethodDefinition method = GetTest ("NoParameter");
-			Assert.AreEqual (RuleResult.DoesNotApply, runner.CheckMethod (method), "RuleResult");
+			AssertRuleSuccess<OpCodeBitmask> ("Equals", new Type [] { typeof (OpCodeBitmask) });
+			AssertRuleFailure<TestCase> ("Equals", 1);
 		}
 	}
 }
diff --git a/gendarme/rules/Gendarme.Rules.Naming/Test/Tests.Rules.Naming.csproj b/gendarme/rules/Gendarme.Rules.Naming/Test/Tests.Rules.Naming.csproj
index 549c8b8..549dc4d 100755
--- a/gendarme/rules/Gendarme.Rules.Naming/Test/Tests.Rules.Naming.csproj
+++ b/gendarme/rules/Gendarme.Rules.Naming/Test/Tests.Rules.Naming.csproj
@@ -1,5 +1,5 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
     <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
@@ -10,8 +10,28 @@
     <AppDesignerFolder>Properties</AppDesignerFolder>
     <RootNamespace>Tests.Rules.Naming</RootNamespace>
     <AssemblyName>Tests.Rules.Naming</AssemblyName>
-    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
     <FileAlignment>512</FileAlignment>
+    <FileUpgradeFlags>
+    </FileUpgradeFlags>
+    <OldToolsVersion>3.5</OldToolsVersion>
+    <UpgradeBackupLocation />
+    <PublishUrl>publish\</PublishUrl>
+    <Install>true</Install>
+    <InstallFrom>Disk</InstallFrom>
+    <UpdateEnabled>false</UpdateEnabled>
+    <UpdateMode>Foreground</UpdateMode>
+    <UpdateInterval>7</UpdateInterval>
+    <UpdateIntervalUnits>Days</UpdateIntervalUnits>
+    <UpdatePeriodically>false</UpdatePeriodically>
+    <UpdateRequired>false</UpdateRequired>
+    <MapFileExtensions>true</MapFileExtensions>
+    <ApplicationRevision>0</ApplicationRevision>
+    <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
+    <IsWebBootstrapper>false</IsWebBootstrapper>
+    <UseApplicationTrust>false</UseApplicationTrust>
+    <BootstrapperEnabled>true</BootstrapperEnabled>
+    <TargetFrameworkProfile />
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
     <DebugSymbols>true</DebugSymbols>
@@ -21,6 +41,7 @@
     <DefineConstants>DEBUG;TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
     <DebugType>pdbonly</DebugType>
@@ -29,6 +50,7 @@
     <DefineConstants>TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <ItemGroup>
     <Reference Include="nunit.framework, Version=2.4.8.0, Culture=neutral, PublicKeyToken=96d09a1eb7f44a77, processorArchitecture=MSIL">
@@ -76,6 +98,23 @@
   <ItemGroup>
     <Folder Include="Properties\" />
   </ItemGroup>
+  <ItemGroup>
+    <BootstrapperPackage Include="Microsoft.Net.Client.3.5">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1 Client Profile</ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Windows.Installer.3.1">
+      <Visible>False</Visible>
+      <ProductName>Windows Installer 3.1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+  </ItemGroup>
   <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
   <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
        Other similar extension points exist, see Microsoft.Common.targets.
diff --git a/gendarme/rules/Gendarme.Rules.Naming/Test/UseCorrectPrefixTest.cs b/gendarme/rules/Gendarme.Rules.Naming/Test/UseCorrectPrefixTest.cs
index 7ac6880..7000340 100644
--- a/gendarme/rules/Gendarme.Rules.Naming/Test/UseCorrectPrefixTest.cs
+++ b/gendarme/rules/Gendarme.Rules.Naming/Test/UseCorrectPrefixTest.cs
@@ -54,6 +54,10 @@ namespace Test.Rules.Naming {
 	public class ILRange {
 	}
 
+	public class InMemoryDoohicky
+	{
+	}
+
 	public interface I {
 	}
 
@@ -102,6 +106,7 @@ namespace Test.Rules.Naming {
 			AssertRuleFailure<CIncorrectClass> (1);
 			AssertRuleFailure<INcorrectClass> (1);
 			AssertRuleSuccess<ILRange> ();
+			AssertRuleSuccess<InMemoryDoohicky> ();
 		}
 
 		[Test]
diff --git a/gendarme/rules/Gendarme.Rules.Naming/Test/UseCorrectSuffixTest.cs b/gendarme/rules/Gendarme.Rules.Naming/Test/UseCorrectSuffixTest.cs
index adb15fa..0fc5205 100644
--- a/gendarme/rules/Gendarme.Rules.Naming/Test/UseCorrectSuffixTest.cs
+++ b/gendarme/rules/Gendarme.Rules.Naming/Test/UseCorrectSuffixTest.cs
@@ -176,13 +176,8 @@ namespace Test.Rules.Naming {
 		}
 	}
 
-	public class DerivingClassImplementingInterfaces : EventArgs, IEnumerable, IPermission {		 
+	public class DerivingClassImplementingInterfaces : EventArgs, IPermission {		 
 		
-		public IEnumerator GetEnumerator ()
-		{
-			throw new NotImplementedException();
-		}
-
 		public void FromXml (SecurityElement e)
 		{
 			throw new NotImplementedException();
@@ -246,16 +241,27 @@ namespace Test.Rules.Naming {
 	public class DictionaryIncorrectDerived<T, V> : DictionaryIncorrect<T, V> {
 	}
 
+	// test case from https://github.com/Iristyle/mono-tools/commit/40bfb2260511cfe4171e9153c3c434fedd8a4d4a.diff
+
+	public class CorrectCollectionAndDictionary<T, V> : Dictionary<T, V>, ICollection<V> {
+		public void Add(V item) { throw new NotImplementedException(); }
+		public bool Contains(V item) { throw new NotImplementedException(); }
+		public void CopyTo(V[] array, int arrayIndex) { throw new NotImplementedException(); }
+		public bool IsReadOnly { get { throw new NotImplementedException(); } }
+		public bool Remove(V item) { throw new NotImplementedException(); }
+		public new IEnumerator<V> GetEnumerator() { throw new NotImplementedException(); }
+	}
+
 	[TestFixture]
 	public class UseCorrectSuffixTest : TypeRuleTestFixture<UseCorrectSuffixRule> {
 
-		void AssertRuleFailureWithHighConfidence<T>()
+		void AssertRuleFailureWithHighConfidence<T> (int num)
 		{
-			AssertRuleFailure<T> (1);
+			AssertRuleFailure<T> (num);
 			Assert.AreEqual (Confidence.High, Runner.Defects [0].Confidence, typeof (T).Name);
 		}
 
-		void AssertRuleFailureWithLowConfidence<T>()
+		void AssertRuleFailureWithLowConfidence<T> ()
 		{
 			AssertRuleFailure<T> (1);
 			Assert.AreEqual (Confidence.Low, Runner.Defects [0].Confidence, typeof (T).Name);
@@ -270,7 +276,7 @@ namespace Test.Rules.Naming {
 		[Test]
 		public void TestOneLevelInheritanceIncorrectName () 
 		{
-			AssertRuleFailureWithHighConfidence<IncorrectAttr> ();
+			AssertRuleFailureWithHighConfidence<IncorrectAttr> (1);
 		}
 		
 		[Test]
@@ -288,7 +294,7 @@ namespace Test.Rules.Naming {
 		[Test]
 		public void TestVariousLevelInheritanceIncorrectName () 
 		{
-			AssertRuleFailureWithHighConfidence<OtherAttr> ();
+			AssertRuleFailureWithHighConfidence<OtherAttr> (1);
 		}
 		
 		[Test]
@@ -326,7 +332,7 @@ namespace Test.Rules.Naming {
        		[Test]
 		public void TestMultipleInterfaceImplementerIncorrectName () 
 		{
-			AssertRuleFailureWithHighConfidence<MultipleInterfaceImplementer> ();
+			AssertRuleFailureWithHighConfidence<MultipleInterfaceImplementer> (1);
 		}
 
 		[Test]
@@ -342,7 +348,7 @@ namespace Test.Rules.Naming {
 		{
 			//this type derives from an incorrect base type, but also introduce its own defect
 			//hence it has high confidence
-			AssertRuleFailureWithHighConfidence<IncorrectICollectionImplementer> ();
+			AssertRuleFailureWithHighConfidence<IncorrectICollectionImplementer> (1);
 		}
 		
 		[Test]
@@ -360,23 +366,24 @@ namespace Test.Rules.Naming {
 		[Test]
 		public void TestDerivingClassImplementingInterfacesAnotherIncorrectName ()
 		{
-			//this type derives from an incorrect base type, *without* introducing its own defect
-			//hence it has low confidence
-			AssertRuleFailureWithLowConfidence<IncorrectDerivingClassImplementingInterfacesCollection> ();
+			//this type derives from an incorrect base type
+			AssertRuleFailureWithHighConfidence<IncorrectDerivingClassImplementingInterfacesCollection> (2);
 		}
 
 		[Test]
 		public void GenericCollection ()
 		{
 			AssertRuleSuccess<CorrectCollection<int>> ();
-			AssertRuleFailureWithHighConfidence<CollectionIncorrect<int>> ();
+			AssertRuleFailureWithHighConfidence<CollectionIncorrect<int>> (1);
 		}
 
 		[Test]
 		public void GenericDictionary ()
 		{
 			AssertRuleSuccess<CorrectDictionary<int,int>> ();
-			AssertRuleFailureWithHighConfidence<DictionaryIncorrect<int,int>> ();
+			// to be consistent with FxCop, a class implementing IDictionary and ICollection should end in Dictionary
+			AssertRuleSuccess<CorrectCollectionAndDictionary<int, int>> ();
+			AssertRuleFailureWithHighConfidence<DictionaryIncorrect<int, int>> (1);
 		}
 
 		[Test]
@@ -410,11 +417,11 @@ namespace Test.Rules.Naming {
 		public void CheckShouldNeverBeUsedSuffixes ()
 		{
 			AssertRuleSuccess<My> ();
-			AssertRuleFailureWithHighConfidence<MyDelegate> ();
-			AssertRuleFailureWithHighConfidence<MyEnum> ();
-			AssertRuleFailureWithHighConfidence<MyFlags> ();
-			AssertRuleFailureWithHighConfidence<MyEx> ();
-			AssertRuleFailureWithHighConfidence<MyImpl> ();
+			AssertRuleFailureWithHighConfidence<MyDelegate> (1);
+			AssertRuleFailureWithHighConfidence<MyEnum> (1);
+			AssertRuleFailureWithHighConfidence<MyFlags> (1);
+			AssertRuleFailureWithHighConfidence<MyEx> (1);
+			AssertRuleFailureWithHighConfidence<MyImpl> (1);
 		}
 
 		class MyCollection : EventArgs {
@@ -467,16 +474,16 @@ namespace Test.Rules.Naming {
 		public void EnumName ()
 		{
 			AssertRuleSuccess<ReturnValue> ();
-			AssertRuleFailureWithHighConfidence<ReturnValueEnum> ();
-			AssertRuleFailureWithHighConfidence<returnvalueenum> ();
+			AssertRuleFailureWithHighConfidence<ReturnValueEnum> (1);
+			AssertRuleFailureWithHighConfidence<returnvalueenum> (1);
 		}
 
 		[Test]
 		public void FlagsName ()
 		{
 			AssertRuleSuccess<ReturnValues> ();
-			AssertRuleFailureWithHighConfidence<ReturnValuesFlags> ();
-			AssertRuleFailureWithHighConfidence<returnvaluesflags> ();
+			AssertRuleFailureWithHighConfidence<ReturnValuesFlags> (1);
+			AssertRuleFailureWithHighConfidence<returnvaluesflags> (1);
 		}
 	}
 }
diff --git a/gendarme/rules/Gendarme.Rules.Naming/UseCorrectCasingRule.cs b/gendarme/rules/Gendarme.Rules.Naming/UseCorrectCasingRule.cs
index 32cec08..6a6252b 100644
--- a/gendarme/rules/Gendarme.Rules.Naming/UseCorrectCasingRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Naming/UseCorrectCasingRule.cs
@@ -30,6 +30,7 @@
 
 using System;
 using System.Collections.Generic;
+using System.Globalization;
 using System.Linq;
 
 using Mono.Cecil;
@@ -96,7 +97,7 @@ namespace Gendarme.Rules.Naming {
 				return name.ToUpperInvariant ();
 
 			int index = IndexOfFirstCorrectChar (name);
-			return Char.ToUpperInvariant (name [index]).ToString () + name.Substring (index + 1);
+			return Char.ToUpperInvariant (name [index]).ToString (CultureInfo.InvariantCulture) + name.Substring (index + 1);
 		}
 
 		// check if name is camelCased
@@ -118,7 +119,7 @@ namespace Gendarme.Rules.Naming {
 				return name.ToLowerInvariant ();
 
 			int index = IndexOfFirstCorrectChar (name);
-			return Char.ToLowerInvariant (name [index]).ToString () + name.Substring (index + 1);
+			return Char.ToLowerInvariant (name [index]).ToString (CultureInfo.InvariantCulture) + name.Substring (index + 1);
 		}
 
 		private static int IndexOfFirstCorrectChar (string s)
@@ -144,14 +145,15 @@ namespace Gendarme.Rules.Naming {
 			foreach (string ns in nspace.Split ('.')) {
 				switch (ns.Length) {
 				case 1:
-					ReportCasingError (nd, string.Format (
+					ReportCasingError (nd, String.Format (CultureInfo.InvariantCulture,
 						"Use of single character namespace is discouraged. Rename namespace {0}", ns));
 
 					break;
 				case 2:
 					// if the subnamespace is made of 2 chars, each letter have to be uppercase
 					if (ns.Any (c => Char.IsLetter (c) && Char.IsLower (c))) {
-						string msg = String.Format ("In namespaces made of two characters, both characters should uppercase. Rename namespace '{0}' to '{1}'",
+						string msg = String.Format (CultureInfo.InvariantCulture,
+							"In namespaces made of two characters, both characters should uppercase. Rename namespace '{0}' to '{1}'",
 							ns, ns.ToUpperInvariant ());
 						ReportCasingError (nd, msg);
 					}
@@ -159,11 +161,13 @@ namespace Gendarme.Rules.Naming {
 				default:
 					// if the sub namespace is made of 3 or more chars, make sure they're not all uppercase
 					if (ns.All (c => Char.IsLetter (c) && Char.IsUpper (c))) {
-						string msg = String.Format ("Namespaces longer than two characters should not be all uppercase. Rename namespace '{0}' to '{1}{2}'",
-							ns, ns [0].ToString (), ns.Substring (1).ToLowerInvariant ());
+						string msg = String.Format (CultureInfo.InvariantCulture,
+							"Namespaces longer than two characters should not be all uppercase. Rename namespace '{0}' to '{1}{2}'",
+							ns, ns [0].ToString (CultureInfo.InvariantCulture), ns.Substring (1).ToLowerInvariant ());
 						ReportCasingError (nd, msg);
 					} else if (!IsPascalCase (ns)) {
-						string msg = String.Format ("Namespaces longer than two characters should be pascal cased. Rename namespace '{0}' to '{1}'",
+						string msg = String.Format (CultureInfo.InvariantCulture,
+							"Namespaces longer than two characters should be pascal cased. Rename namespace '{0}' to '{1}'",
 							ns, PascalCase (ns));
 						ReportCasingError (nd, msg);
 					}
@@ -189,7 +193,7 @@ namespace Gendarme.Rules.Naming {
 			// types should all be PascalCased
 			string name = type.Name;
 			if (!IsPascalCase (name)) {
-				ReportCasingError (type, string.Format (
+				ReportCasingError (type, String.Format (CultureInfo.InvariantCulture,
 					"Type names should all be pascal-cased. Rename '{0}' type to '{1}'.", 
 					name, PascalCase (name)));
 			}
@@ -222,7 +226,8 @@ namespace Gendarme.Rules.Naming {
 
 			// like types, methods/props should all be PascalCased, too
 			if (!IsPascalCase (name)) {
-				string errorMessage = String.Format ("By existing naming conventions, all the method and property names should all be pascal-cased (e.g. MyOperation). Rename '{0}' to '{1}'.",
+				string errorMessage = String.Format (CultureInfo.InvariantCulture,
+					"By existing naming conventions, all the method and property names should all be pascal-cased (e.g. MyOperation). Rename '{0}' to '{1}'.",
 					name, PascalCase (name));
 				Runner.Report (method, Severity.Medium, Confidence.High, errorMessage);
 			}
@@ -232,7 +237,8 @@ namespace Gendarme.Rules.Naming {
 				foreach (ParameterDefinition param in method.Parameters) {
 					// params should all be camelCased
 					if (!IsCamelCase (param.Name)) {
-						string errorMessage = String.Format ("By existing naming conventions, the parameter names should all be camel-cased (e.g. myParameter). Rename '{0}' parameter to '{1}'.",
+						string errorMessage = String.Format (CultureInfo.InvariantCulture,
+							"By existing naming conventions, the parameter names should all be camel-cased (e.g. myParameter). Rename '{0}' parameter to '{1}'.",
 							param, CamelCase (param.Name));
 						Runner.Report (method, Severity.Medium, Confidence.High, errorMessage);
 					}
diff --git a/gendarme/rules/Gendarme.Rules.Naming/UseCorrectPrefixRule.cs b/gendarme/rules/Gendarme.Rules.Naming/UseCorrectPrefixRule.cs
index 68de78a..03ff58c 100644
--- a/gendarme/rules/Gendarme.Rules.Naming/UseCorrectPrefixRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Naming/UseCorrectPrefixRule.cs
@@ -29,6 +29,7 @@
 //
 
 using System;
+using System.Globalization;
 
 using Mono.Cecil;
 using Gendarme.Framework;
@@ -89,9 +90,9 @@ namespace Gendarme.Rules.Naming {
 				return true;
 
 			switch (name [0]) {
-			case 'C':	// MFC like CMyClass - but works for CLSCompliant
-			case 'I':	// interface-like
-				return Char.IsLower (name [1]) == Char.IsLower (name [2]);
+			case 'C':	// MFC like CMyClass should fail - but works for CLSCompliant
+			case 'I':	// interface-like - Classes beginning with In or Is etc should pass, e.g. InMemoryDoohicky
+				return Char.IsLower (name [1]) ? true : Char.IsUpper (name [2]);
 			default:
 				return true;
 			}
@@ -118,13 +119,16 @@ namespace Gendarme.Rules.Naming {
 			if (type.IsInterface) {
 				// interfaces should look like 'ISomething'
 				if (!IsCorrectInterfaceName (name)) { 
-					string s = String.Format ("The '{0}' interface name doesn't have the required 'I' prefix. Acoording to existing naming conventions, all interface names should begin with the 'I' letter followed by another capital letter.", name);
+					string s = String.Format (CultureInfo.InvariantCulture,
+						"The '{0}' interface name doesn't have the required 'I' prefix. Acoording to existing naming conventions, all interface names should begin with the 'I' letter followed by another capital letter.", 
+						name);
 					Runner.Report (type, Severity.Critical, Confidence.High, s);
 				}
 			} else {
 				// class should _not_ look like 'CSomething" or like an interface 'IOops'
 				if (!IsCorrectTypeName (name)) { 
-					string s = String.Format ("The '{0}' type name starts with '{1}' prefix but, according to existing naming conventions, type names should not have any specific prefix.", 
+					string s = String.Format (CultureInfo.InvariantCulture,
+						"The '{0}' type name starts with '{1}' prefix but, according to existing naming conventions, type names should not have any specific prefix.", 
 						name, name [0]);
 					Runner.Report (type, Severity.Medium, Confidence.High, s);
 				}
@@ -137,7 +141,9 @@ namespace Gendarme.Rules.Naming {
 				foreach (GenericParameter parameter in type.GenericParameters) {
 					string param_name = parameter.Name;
 					if (IsCorrectGenericParameterName (param_name)) {
-						string s = String.Format ("The generic parameter '{0}' should be prefixed with 'T' or be a single, uppercased letter.", param_name);
+						string s = String.Format (CultureInfo.InvariantCulture,
+							"The generic parameter '{0}' should be prefixed with 'T' or be a single, uppercased letter.", 
+							param_name);
 						Runner.Report (type, Severity.High, Confidence.High, s);
 					}
 				}
diff --git a/gendarme/rules/Gendarme.Rules.Naming/UseCorrectSuffixRule.cs b/gendarme/rules/Gendarme.Rules.Naming/UseCorrectSuffixRule.cs
index cad641b..671d842 100644
--- a/gendarme/rules/Gendarme.Rules.Naming/UseCorrectSuffixRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Naming/UseCorrectSuffixRule.cs
@@ -32,6 +32,7 @@
 
 using System;
 using System.Collections.Generic;
+using System.Globalization;
 using System.Text;
 
 using Mono.Cecil;
@@ -83,29 +84,30 @@ namespace Gendarme.Rules.Naming {
 	public class UseCorrectSuffixRule : Rule, ITypeRule {
 
 		static Dictionary<string, HashSet<string>> definedSuffixes = new Dictionary<string, HashSet<string>> ();
+		static Dictionary<string, string> namespaces = new Dictionary<string, string> ();
 		static SortedDictionary<string, Func<TypeDefinition, string>> reservedSuffixes = new SortedDictionary<string, Func<TypeDefinition, string>> ();
 
 		static UseCorrectSuffixRule ()
 		{
-			Add ("Attribute", "System.Attribute", true);
-			Add ("Collection", "System.Collections.ICollection", false);
-			Add ("Collection", "System.Collections.IEnumerable", false);
-			Add ("Collection", "System.Collections.Queue", false);
-			Add ("Collection", "System.Collections.Stack", false);
-			Add ("Collection", "System.Collections.Generic.ICollection`1", false);
-			Add ("Collection", "System.Data.DataSet", false);
-			Add ("Collection", "System.Data.DataTable", false);
-			Add ("Condition", "System.Security.Policy.IMembershipCondition", true);
-			Add ("DataSet", "System.Data.DataSet", true);
-			Add ("DataTable", "System.Data.DataTable", true);
-			Add ("Dictionary", "System.Collections.IDictionary", false);
-			Add ("Dictionary", "System.Collections.IDictionary`2", false);
-			Add ("EventArgs", "System.EventArgs", true);
-			Add ("Exception", "System.Exception", true);
-			Add ("Permission", "System.Security.IPermission", true);
-			Add ("Queue", "System.Collections.Queue", true);
-			Add ("Stack", "System.Collections.Stack", true);
-			Add ("Stream", "System.IO.Stream", true);
+			Add ("Attribute", "System", "Attribute", true);
+			Add ("Collection", "System.Collections", "ICollection", false);
+			Add ("Collection", "System.Collections", "IEnumerable", false);
+			Add ("Collection", "System.Collections", "Queue", false);
+			Add ("Collection", "System.Collections", "Stack", false);
+			Add ("Collection", "System.Collections.Generic", "ICollection`1", false);
+			Add ("Collection", "System.Data", "DataSet", false);
+			Add ("Collection", "System.Data", "DataTable", false);
+			Add ("Condition", "System.Security.Policy", "IMembershipCondition", true);
+			Add ("DataSet", "System.Data", "DataSet", true);
+			Add ("DataTable", "System.Data", "DataTable", true);
+			Add ("Dictionary", "System.Collections", "IDictionary", false);
+			Add ("Dictionary", "System.Collections", "IDictionary`2", false);
+			Add ("EventArgs", "System", "EventArgs", true);
+			Add ("Exception", "System", "Exception", true);
+			Add ("Permission", "System.Security", "IPermission", true);
+			Add ("Queue", "System.Collections", "Queue", true);
+			Add ("Stack", "System.Collections", "Stack", true);
+			Add ("Stream", "System.IO", "Stream", true);
 
 			// special cases
 			reservedSuffixes.Add ("Collection", message => CheckCollection (message));
@@ -119,36 +121,40 @@ namespace Gendarme.Rules.Naming {
 			reservedSuffixes.Add ("Impl", message => "Use the 'Core' prefix instead of 'Impl'.");
 		}
 
-		static void Add (string suffix, string type, bool reserved)
+		static void Add (string suffix, string nameSpace, string name, bool reserved)
 		{
 			if (reserved) {
-				reservedSuffixes.Add (suffix, message => InheritsOrImplements (message, type));
+				reservedSuffixes.Add (suffix, message => InheritsOrImplements (message, nameSpace, name));
 			}
 
 			HashSet<string> set;
-			if (!definedSuffixes.TryGetValue (type, out set)) {
+			if (!definedSuffixes.TryGetValue (name, out set)) {
 				set = new HashSet<string> ();
-				definedSuffixes.Add (type, set);
+				definedSuffixes.Add (name, set);
+				namespaces.Add (name, nameSpace);
 			}
 			set.Add (suffix);
 		}
 
-		static string InheritsOrImplements (TypeReference type, string subtype)
+		static string InheritsOrImplements (TypeReference type, string nameSpace, string name)
 		{
-			if (type.Inherits (subtype) || type.Implements (subtype))
+			if (type.Inherits (nameSpace, name) || type.Implements (nameSpace, name))
 				return String.Empty;
-			return String.Format ("'{0}' should only be used for types that inherits or implements {1}.", type.Name, subtype);
+
+			return String.Format (CultureInfo.InvariantCulture,
+				"'{0}' should only be used for types that inherits or implements '{1}.{2}'.", 
+				type.Name, nameSpace, name);
 		}
 
 		static string CheckCollection (TypeReference type)
 		{
-			if (type.Implements ("System.Collections.ICollection") ||
-				type.Implements ("System.Collections.IEnumerable") ||
-				type.Implements ("System.Collections.Generic.ICollection`1"))
+			if (type.Implements ("System.Collections", "ICollection") ||
+				type.Implements ("System.Collections", "IEnumerable") ||
+				type.Implements ("System.Collections.Generic", "ICollection`1"))
 				return String.Empty;
 
-			if (type.Inherits ("System.Collections.Queue") || type.Inherits ("System.Collections.Stack") || 
-				type.Inherits ("System.Data.DataSet") || type.Inherits ("System.Data.DataTable"))
+			if (type.Inherits ("System.Collections", "Queue") || type.Inherits ("System.Collections", "Stack") || 
+				type.Inherits ("System.Data", "DataSet") || type.Inherits ("System.Data", "DataTable"))
 				return String.Empty;
 
 			return "'Collection' should only be used for implementing ICollection or IEnumerable or inheriting from Queue, Stack, DataSet and DataTable.";
@@ -156,7 +162,7 @@ namespace Gendarme.Rules.Naming {
 
 		static string CheckDictionary (TypeReference type)
 		{
-			if (type.Implements ("System.Collections.IDictionary") || type.Implements ("System.Collections.Generic.IDictionary`2"))
+			if (type.Implements ("System.Collections", "IDictionary") || type.Implements ("System.Collections.Generic", "IDictionary`2"))
 				return String.Empty;
 			return "'Dictionary' should only be used for types implementing IDictionary and IDictionary<TKey,TValue>.";
 		}
@@ -168,16 +174,24 @@ namespace Gendarme.Rules.Naming {
 			return "'EventHandler' should only be used for event handler delegates.";
 		}
 
-		// handle types using generics
-		private static string GetFullName (TypeReference type)
+		static bool TryGetCandidates (TypeReference type, out HashSet<string> candidates)
 		{
-			string name = type.FullName;
-			// handle types using generics
+			string name = type.Name;
 			if ((type is GenericInstanceType) || type.HasGenericParameters) {
 				int pos = name.IndexOf ('`');
-				name = name.Substring (0, pos);
+				if (pos != -1)
+					name = name.Substring (0, pos);
+			}
+			
+			if (definedSuffixes.TryGetValue (name, out candidates)) {
+				string nspace;
+				if (namespaces.TryGetValue (name, out nspace)) {
+					if (nspace == type.Namespace)
+						return true;
+				}
 			}
-			return name;
+			candidates = null;
+			return false;
 		}
 
 		// checks if type name ends with an approriate suffix
@@ -189,18 +203,15 @@ namespace Gendarme.Rules.Naming {
 			currentTypeSuffix = false;
 
 			while (current != null && current.BaseType != null) {
-				string base_name = GetFullName (current.BaseType);
-
 				HashSet<string> candidates;
-				if (definedSuffixes.TryGetValue (base_name, out candidates)) {
+				if (TryGetCandidates (current.BaseType, out candidates)) {
 					suffixes.AddRangeIfNew (candidates);
 					if (current == type)
 						currentTypeSuffix = true;
 				} else {
 					// if no suffix for base type is found, we start looking through interfaces
 					foreach (TypeReference iface in current.Interfaces) {
-						string interface_name = GetFullName (iface);
-						if (definedSuffixes.TryGetValue (interface_name, out candidates)) {
+						if (TryGetCandidates (iface, out candidates)) {
 							suffixes.AddRangeIfNew (candidates);
 							if (current == type)
 								currentTypeSuffix = true;
@@ -210,8 +221,9 @@ namespace Gendarme.Rules.Naming {
 				if (suffixes.Count > 0) {
 					// if any suffixes found
 					// check whether type name ends with any of these suffixes
+					string tname = type.Name;
 					return suffixes.Exists (delegate (string suffix) {
-						return GetFullName (type).EndsWith (suffix, StringComparison.Ordinal);
+						return HasSuffix (tname, suffix);
 					});
 				} else {
 					// inspect base type
@@ -224,8 +236,11 @@ namespace Gendarme.Rules.Naming {
 
 		private static string ComposeMessage (List<string> candidates)
 		{
-			if (candidates.Count == 1)
-				return String.Format ("The type name does not end with '{0}' suffix. Append it to the type name.", candidates [0]);
+			if (candidates.Count == 1) {
+				return String.Format (CultureInfo.InvariantCulture, 
+					"The type name does not end with '{0}' suffix. Append it to the type name.", 
+					candidates [0]);
+			}
 
 			StringBuilder sb = new StringBuilder ("The type name does not end with one of the following suffixes: ");
 			sb.Append (candidates [0]);
@@ -239,6 +254,21 @@ namespace Gendarme.Rules.Naming {
 
 		private List<string> proposedSuffixes = new List<string> ();
 
+		static bool HasSuffix (string typeName, string suffix)
+		{
+			if (suffix.Length > typeName.Length)
+				return false;
+
+			// generic aware
+			int gpos = typeName.LastIndexOf ('`');
+			if (gpos == -1)
+				gpos = typeName.Length;
+			else if (suffix.Length > gpos)
+				return false;
+
+			return (String.Compare (suffix, 0, typeName, gpos - suffix.Length, suffix.Length, StringComparison.OrdinalIgnoreCase) == 0);
+		}
+
 		public RuleResult CheckType (TypeDefinition type)
 		{
 			// rule does not apply to generated code (outside developer's control)
@@ -247,15 +277,19 @@ namespace Gendarme.Rules.Naming {
 
 			// ok, rule applies
 
+			string tname = type.Name;
 			// first check if the current suffix is correct
 			// e.g. MyAttribute where the type does not inherit from Attribute
 			foreach (string suffix in reservedSuffixes.Keys) {
-				if (type.Name.EndsWith (suffix, StringComparison.OrdinalIgnoreCase)) {
+				if (HasSuffix (tname, suffix)) {
 					Func<TypeDefinition, string> f;
 					if (reservedSuffixes.TryGetValue (suffix, out f)) {
 						string msg = f (type);
-						if (!String.IsNullOrEmpty (msg))
-							Runner.Report (type, Severity.Medium, Confidence.High, msg);
+						// if this is a valid suffix then there's not need to check for invalid later
+						if (String.IsNullOrEmpty (msg))
+							return RuleResult.Success;
+
+						Runner.Report (type, Severity.Medium, Confidence.High, msg);
 					}
 				}
 			}
diff --git a/gendarme/rules/Gendarme.Rules.Naming/UsePreferredTermsRule.cs b/gendarme/rules/Gendarme.Rules.Naming/UsePreferredTermsRule.cs
index 59ede41..d2367c5 100644
--- a/gendarme/rules/Gendarme.Rules.Naming/UsePreferredTermsRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Naming/UsePreferredTermsRule.cs
@@ -30,6 +30,7 @@
 
 using System;
 using System.Collections.Generic;
+using System.Globalization;
 
 using Mono.Cecil;
 
@@ -140,7 +141,7 @@ namespace Gendarme.Rules.Naming {
 					continue;
 				if (index > 0 && char.IsLetter (name, index - 1) && char.IsLower (name, index))
 					continue; //term is part of a larger word
-				string s = String.Format (Message, pair.Key, pair.Value);
+				string s = String.Format (CultureInfo.InvariantCulture, Message, pair.Key, pair.Value);
 				Runner.Report (identifier, severity, Confidence.High, s);
 			}
 		}
diff --git a/gendarme/rules/Gendarme.Rules.Performance/AvoidConcatenatingCharsRule.cs b/gendarme/rules/Gendarme.Rules.Performance/AvoidConcatenatingCharsRule.cs
index e753a0d..44ba1e6 100644
--- a/gendarme/rules/Gendarme.Rules.Performance/AvoidConcatenatingCharsRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Performance/AvoidConcatenatingCharsRule.cs
@@ -27,6 +27,7 @@
 //
 
 using System;
+using System.Globalization;
 
 using Mono.Cecil;
 using Mono.Cecil.Cil;
@@ -74,26 +75,20 @@ namespace Gendarme.Rules.Performance {
 	[EngineDependency (typeof (OpCodeEngine))]
 	public class AvoidConcatenatingCharsRule : Rule, IMethodRule {
 
-		static bool IsStringConcat (MemberReference member)
-		{
-			if (member == null || (member.Name != "Concat"))
-				return false;
-
-			return (member.DeclaringType.FullName == "System.String");
-		}
-
 		static bool HasReferenceToStringConcatObject (ModuleDefinition module)
 		{
 			foreach (MemberReference mr in module.GetMemberReferences ()) {
-				if (IsStringConcat (mr)) {
+				if (mr.IsNamed ("System", "String", "Concat")) {
 					MethodReference method = (mr as MethodReference);
 					// catch both System.Object and System.Object[]
 					if (!method.HasParameters)
 						continue;
-					switch (method.Parameters [0].ParameterType.FullName) {
-					case "System.Object":
-					case "System.Object[]":
-						return true;
+
+					TypeReference ptype = method.Parameters [0].ParameterType;
+					switch (ptype.Name) {
+					case "Object":
+					case "Object[]":
+						return (ptype.Namespace == "System");
 					}
 				}
 			}
@@ -113,7 +108,8 @@ namespace Gendarme.Rules.Performance {
 
 		private void ReportBoxing (MethodDefinition method, Instruction ins, Confidence confidence)
 		{
-			string msg = String.Format ("Type '{0}' is being boxed.", (ins.Operand as TypeReference).FullName);
+			string msg = String.Format (CultureInfo.InvariantCulture,
+				"Type '{0}' is being boxed.", (ins.Operand as TypeReference).GetFullName ());
 			Runner.Report (method, ins, Severity.High, confidence, msg);
 		}
 
@@ -159,14 +155,18 @@ namespace Gendarme.Rules.Performance {
 
 				// look for String.Concat overloads using System.Object
 				MethodReference mr = (ins.Operand as MethodReference);
-				if (!IsStringConcat (mr) || !mr.HasParameters)
+				if (!mr.HasParameters || !mr.IsNamed ("System", "String", "Concat"))
 					continue;
 
-				switch (mr.Parameters [0].ParameterType.FullName) {
-				case "System.Object":
+				TypeReference ptype = mr.Parameters [0].ParameterType;
+				if (ptype.Namespace != "System")
+					continue; // very unlikely
+
+				switch (ptype.Name) {
+				case "Object":
 					CheckParameters (mr, method, ins);
 					break;
-				case "System.Object[]":
+				case "Object[]":
 					if ((ins.Previous.OpCode.Code == Code.Stelem_Ref) || ins.Previous.IsLoadLocal ())
 						ScanArray (method, ins.Previous);
 					break;
diff --git a/gendarme/rules/Gendarme.Rules.Performance/AvoidLargeNumberOfLocalVariablesRule.cs b/gendarme/rules/Gendarme.Rules.Performance/AvoidLargeNumberOfLocalVariablesRule.cs
index a1bd50f..698867c 100644
--- a/gendarme/rules/Gendarme.Rules.Performance/AvoidLargeNumberOfLocalVariablesRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Performance/AvoidLargeNumberOfLocalVariablesRule.cs
@@ -28,6 +28,7 @@
 
 using System;
 using System.ComponentModel;
+using System.Globalization;
 
 using Mono.Cecil;
 using Mono.Cecil.Cil;
@@ -70,7 +71,7 @@ namespace Gendarme.Rules.Performance {
 			// special case for System.Windows.Forms since it's designer does not
 			// mark this code as generated :-(
 			if (method.Name == "InitializeComponent") {
-				if (method.DeclaringType.Inherits ("System.Windows.Forms.Form"))
+				if (method.DeclaringType.Inherits ("System.Windows.Forms", "Form"))
 					return RuleResult.DoesNotApply;
 			}
 
@@ -78,7 +79,8 @@ namespace Gendarme.Rules.Performance {
 			if (num <= MaximumVariables)
 				return RuleResult.Success;
 
-			string msg = String.Format ("Found {0} local variables (maximum {1}).", num, MaximumVariables);
+			string msg = String.Format (CultureInfo.InvariantCulture, 
+				"Found {0} local variables (maximum {1}).", num, MaximumVariables);
 			Runner.Report (method, Severity.High, Confidence.High, msg);
 			return RuleResult.Failure;
 		}
diff --git a/gendarme/rules/Gendarme.Rules.Performance/AvoidLargeStructureRule.cs b/gendarme/rules/Gendarme.Rules.Performance/AvoidLargeStructureRule.cs
index 99ecb4f..2ce5e3f 100644
--- a/gendarme/rules/Gendarme.Rules.Performance/AvoidLargeStructureRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Performance/AvoidLargeStructureRule.cs
@@ -29,6 +29,7 @@
 using System;
 using System.Collections.Generic;
 using System.ComponentModel;
+using System.Globalization;
 
 using Mono.Cecil;
 
@@ -75,20 +76,20 @@ namespace Gendarme.Rules.Performance {
 		private const int ReferenceSize = 4;
 
 		static Dictionary<string, int> Primitives = new Dictionary<string, int> (14) {
-			{ "System.Byte", 1 },
-			{ "System.SByte", 1 },
-			{ "System.Boolean", 1 },
-			{ "System.Int16", 2 },
-			{ "System.UInt16", 2 },
-			{ "System.Char", 2 },
-			{ "System.Int32", 4 },
-			{ "System.UInt32", 4 },
-			{ "System.Single", 4 },
-			{ "System.Int64", 8 },
-			{ "System.UInt64", 8 },
-			{ "System.Double", 8 },
-			{ "System.IntPtr", ReferenceSize },	// so rule return the same results
-			{ "System.UIntPtr", ReferenceSize },	// on 32 and 64 bits architectures
+			{ "Byte", 1 },
+			{ "SByte", 1 },
+			{ "Boolean", 1 },
+			{ "Int16", 2 },
+			{ "UInt16", 2 },
+			{ "Char", 2 },
+			{ "Int32", 4 },
+			{ "UInt32", 4 },
+			{ "Single", 4 },
+			{ "Int64", 8 },
+			{ "UInt64", 8 },
+			{ "Double", 8 },
+			{ "IntPtr", ReferenceSize },	// so rule return the same results
+			{ "UIntPtr", ReferenceSize },	// on 32 and 64 bits architectures
 		};
 
 		private int max_size = MaximumRecommendedSize;
@@ -179,7 +180,7 @@ namespace Gendarme.Rules.Performance {
 			// list based on Type.IsPrimitive
 			if (type.Namespace == "System") {
 				int size;
-				if (Primitives.TryGetValue (type.FullName, out size))
+				if (Primitives.TryGetValue (type.Name, out size))
 					return (long) size;
 			}
 
@@ -216,7 +217,7 @@ namespace Gendarme.Rules.Performance {
 			else if (size > medium_severity_limit)
 				severity = Severity.Medium;
 
-			string text = String.Format ("Structure size is {0} bytes.", size);
+			string text = String.Format (CultureInfo.CurrentCulture, "Structure size is {0} bytes.", size);
 			Runner.Report (type, severity, Confidence.High, text);
 			return RuleResult.Failure;
 		}
diff --git a/gendarme/rules/Gendarme.Rules.Performance/AvoidLocalDataStoreSlotRule.cs b/gendarme/rules/Gendarme.Rules.Performance/AvoidLocalDataStoreSlotRule.cs
index a039d6a..b881c09 100644
--- a/gendarme/rules/Gendarme.Rules.Performance/AvoidLocalDataStoreSlotRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Performance/AvoidLocalDataStoreSlotRule.cs
@@ -89,8 +89,6 @@ namespace Gendarme.Rules.Performance {
 	[EngineDependency (typeof (OpCodeEngine))]
 	public class AvoidLocalDataStoreSlotRule : Rule, IMethodRule {
 
-		private const string LocalDataStoreSlot = "System.LocalDataStoreSlot";
-
 		public override void Initialize (IRunner runner)
 		{
 			base.Initialize (runner);
@@ -99,7 +97,9 @@ namespace Gendarme.Rules.Performance {
 				// if the module does not reference System.LocalDataStoreSlot
 				// then no method inside it will be using it
 				Active = (e.CurrentAssembly.Name.Name == "mscorlib" ||
-					e.CurrentModule.HasTypeReference (LocalDataStoreSlot));
+					e.CurrentModule.AnyTypeReference ((TypeReference tr) => {
+						return tr.IsNamed ("System", "LocalDataStoreSlot");
+					}));
 			};
 		}
 
@@ -119,9 +119,18 @@ namespace Gendarme.Rules.Performance {
 					if (mr == null)
 						continue;
 
-					switch (mr.DeclaringType.FullName) {
-					case "System.Threading.Thread":
-					case "System.Runtime.Remoting.Contexts.Context":
+					TypeReference type = mr.DeclaringType;
+					switch (type.Namespace) {
+					case "System.Threading":
+					case "System.Runtime.Remoting.Contexts":
+						break;
+					default:
+						continue;
+					}
+
+					switch (type.Name) {
+					case "Thread":
+					case "Context":
 						break;
 					default:
 						continue;
diff --git a/gendarme/rules/Gendarme.Rules.Performance/AvoidMethodWithLargeMaximumStackSizeRule.cs b/gendarme/rules/Gendarme.Rules.Performance/AvoidMethodWithLargeMaximumStackSizeRule.cs
index 5fbc09d..576e211 100644
--- a/gendarme/rules/Gendarme.Rules.Performance/AvoidMethodWithLargeMaximumStackSizeRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Performance/AvoidMethodWithLargeMaximumStackSizeRule.cs
@@ -27,6 +27,7 @@
 //
 
 using System;
+using System.Globalization;
 
 using Mono.Cecil;
 using Mono.Cecil.Cil;
@@ -64,7 +65,8 @@ namespace Gendarme.Rules.Performance {
 			if (num <= MaximumStackSize)
 				return RuleResult.Success;
 
-			string msg = String.Format ("Found {0} maximum stack size (maximum {1}).", num, MaximumStackSize);
+			string msg = String.Format (CultureInfo.InvariantCulture, 
+				"Found {0} maximum stack size (maximum {1}).", num, MaximumStackSize);
 			Runner.Report (method, Severity.High, Confidence.High, msg);
 			return RuleResult.Failure;
 		}
diff --git a/gendarme/rules/Gendarme.Rules.Performance/AvoidRepetitiveCallsToPropertiesRule.cs b/gendarme/rules/Gendarme.Rules.Performance/AvoidRepetitiveCallsToPropertiesRule.cs
index a470e55..7e1bc64 100644
--- a/gendarme/rules/Gendarme.Rules.Performance/AvoidRepetitiveCallsToPropertiesRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Performance/AvoidRepetitiveCallsToPropertiesRule.cs
@@ -29,6 +29,7 @@
 using System;
 using System.Collections.Generic;
 using System.ComponentModel;
+using System.Globalization;
 using System.Text;
 
 using Mono.Cecil;
@@ -107,14 +108,19 @@ namespace Gendarme.Rules.Performance {
 		static string GetKey (MethodDefinition caller, MethodDefinition callee, Instruction ins)
 		{
 			if (callee.IsStatic)
-				return callee.ToString ();
+				return callee.GetFullName ();
 
 			IMetadataTokenProvider chain = callee;
 			Instruction instance = ins.TraceBack (caller);
 
 			StringBuilder sb = new StringBuilder ();
 			while (instance != null) {
-				sb.Append (chain.ToString () ?? "null").Append ('.');
+				MemberReference mr = (chain as MemberReference);
+				if (mr == null)
+					sb.Append (chain.ToString ()); // ?? "null")
+				else
+					sb.Append (mr.GetFullName ());
+				sb.Append ('.');
 				chain = (instance.Operand as IMetadataTokenProvider);
 				if (chain == null) {
 					sb.Append (instance.GetOperand (caller));
@@ -151,16 +157,15 @@ namespace Gendarme.Rules.Performance {
 
 		static bool Filter (MethodDefinition method)
 		{
-			switch (method.DeclaringType.FullName) {
+			TypeReference type = method.DeclaringType;
 			// Elapsed* and IsRunning
-			case "System.Diagnostics.Stopwatch":
+			if (type.IsNamed ("System.Diagnostics", "Stopwatch"))
 				return true;
 			// Now and UtcNow
-			case "System.DateTime":
+			else if (type.IsNamed ("System", "DateTime"))
 				return method.IsStatic;
-			default:
-				return false;
-			}
+
+			return false;
 		}
 
 		public RuleResult CheckMethod (MethodDefinition method)
@@ -218,13 +223,15 @@ namespace Gendarme.Rules.Performance {
 				MethodDefinition md = kvp.Value.Key;
 				if (md.IsVirtual && !md.IsFinal) {
 					// virtual calls are expensive, so the code better cache the value
-					string msg = String.Format ("Multiple ({0}) calls to virtual property '{1}'.", count, md.ToString ());
+					string msg = String.Format (CultureInfo.InvariantCulture, 
+						"Multiple ({0}) calls to virtual property '{1}'.", count, md.ToString ());
 					Runner.Report (method, GetSeverity (count, true), Confidence.Normal, msg);
 				} else if (!IsInliningCandidate (md)) {
 					// non-virtual calls might be inlined
 					// otherwise caching the value is again a good idea
 					int size = md.HasBody ? md.Body.CodeSize : 0;
-					string msg = String.Format ("Multiple ({0}) calls to non-virtual property '{1}', likely non-inlined due to size ({2} >= {3}).",
+					string msg = String.Format (CultureInfo.InvariantCulture,
+						"Multiple ({0}) calls to non-virtual property '{1}', likely non-inlined due to size ({2} >= {3}).",
 						count, md.ToString (), size, InlineLimit);
 					Runner.Report (method, GetSeverity (count, false), Confidence.Normal, msg);
 				}
diff --git a/gendarme/rules/Gendarme.Rules.Performance/AvoidRepetitiveCastsRule.cs b/gendarme/rules/Gendarme.Rules.Performance/AvoidRepetitiveCastsRule.cs
index 5680c14..5a4a10e 100644
--- a/gendarme/rules/Gendarme.Rules.Performance/AvoidRepetitiveCastsRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Performance/AvoidRepetitiveCastsRule.cs
@@ -29,6 +29,7 @@
 
 using System;
 using System.Collections.Generic;
+using System.Globalization;
 
 using Mono.Cecil;
 using Mono.Cecil.Cil;
@@ -237,7 +238,7 @@ namespace Gendarme.Rules.Performance {
 			return match;
 		}
 
-		private int FindDuplicates (MethodDefinition method, string type, Instruction origin)
+		private int FindDuplicates (MethodDefinition method, TypeReference type, Instruction origin)
 		{
 			// we already had our first cast if we got here
 			int count = 1;
@@ -245,7 +246,7 @@ namespace Gendarme.Rules.Performance {
 			// don't check 0 since it's the one we compare with
 			for (int i = 1; i < casts.Count; i++) {
 				Instruction ins = casts [i];
-				if (type != (ins.Operand as TypeReference).FullName)
+				if (!(ins.Operand as TypeReference).IsNamed (type.Namespace, type.Name))
 					continue;
 				if (!OriginsMatch(method, origin, GetOrigin (ins)))
 					continue;
@@ -287,7 +288,7 @@ namespace Gendarme.Rules.Performance {
 			// if there's only one then it can't be a duplicate cast
 			while (casts.Count > 1) {
 				Instruction ins = casts [0];
-				string type = (ins.Operand as TypeReference).FullName;
+				TypeReference type = (ins.Operand as TypeReference);
 				Instruction origin = GetOrigin (ins);
 
 				int count = FindDuplicates (method, type, origin);
@@ -296,7 +297,8 @@ namespace Gendarme.Rules.Performance {
 
 					// rare, but it's possible to cast a null value (ldnull)
 					object name = origin.GetOperand (method) ?? "Null";
-					string msg = String.Format ("'{0}' is casted {1} times for type '{2}'.", name, count, type);
+					string msg = String.Format (CultureInfo.InvariantCulture, 
+						"'{0}' is casted {1} times for type '{2}'.", name, count, type.GetFullName ());
 					Runner.Report (method, ins, Severity.Medium, Confidence.Normal, msg);
 				}
 				casts.RemoveAt (0);
diff --git a/gendarme/rules/Gendarme.Rules.Performance/AvoidTypeGetTypeForConstantStringsRule.cs b/gendarme/rules/Gendarme.Rules.Performance/AvoidTypeGetTypeForConstantStringsRule.cs
index 23da450..e2d9ed1 100644
--- a/gendarme/rules/Gendarme.Rules.Performance/AvoidTypeGetTypeForConstantStringsRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Performance/AvoidTypeGetTypeForConstantStringsRule.cs
@@ -27,6 +27,7 @@
 //
 
 using System;
+using System.Globalization;
 
 using Mono.Cecil;
 using Mono.Cecil.Cil;
@@ -34,6 +35,7 @@ using Mono.Cecil.Cil;
 using Gendarme.Framework;
 using Gendarme.Framework.Engines;
 using Gendarme.Framework.Helpers;
+using Gendarme.Framework.Rocks;
 
 namespace Gendarme.Rules.Performance {
 
@@ -84,9 +86,9 @@ namespace Gendarme.Rules.Performance {
 
 				// look for calls to: static Type System.Type.GetType(string...)
 				MethodReference mr = (ins.Operand as MethodReference);
-				if ((mr == null) || !mr.HasParameters || (mr.Name != "GetType"))
+				if ((mr == null) || !mr.HasParameters)
 					continue;
-				if (mr.DeclaringType.FullName != "System.Type")
+				if (!mr.IsNamed ("System", "Type", "GetType"))
 					continue;
 
 				if (ins.Previous.OpCode.Code != Code.Ldstr)
@@ -100,7 +102,8 @@ namespace Gendarme.Rules.Performance {
 				if (type_name == "Mono.Runtime")
 					continue;
 
-				string msg = string.Format ("Replace call to Type.GetType(\"{0}\") into typeof({0}).", type_name);
+				string msg = String.Format (CultureInfo.InvariantCulture, 
+					"Replace call to Type.GetType(\"{0}\") into typeof({0}).", type_name);
 				Runner.Report (method, ins, Severity.Medium, Confidence.Normal, msg);
 			}
 			return Runner.CurrentRuleResult;
diff --git a/gendarme/rules/Gendarme.Rules.Performance/AvoidUncalledPrivateCodeRule.cs b/gendarme/rules/Gendarme.Rules.Performance/AvoidUncalledPrivateCodeRule.cs
index 529657a..37d0478 100644
--- a/gendarme/rules/Gendarme.Rules.Performance/AvoidUncalledPrivateCodeRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Performance/AvoidUncalledPrivateCodeRule.cs
@@ -93,11 +93,21 @@ namespace Gendarme.Rules.Performance {
 	[FxCopCompatibility ("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
 	public class AvoidUncalledPrivateCodeRule : Rule, IMethodRule {
 
-		static string [] SpecialAttributes = new string[] {
-			"System.Runtime.InteropServices.ComRegisterFunctionAttribute",
-			"System.Runtime.InteropServices.ComUnregisterFunctionAttribute",
-			"System.Diagnostics.ConditionalAttribute"
-		};
+		static bool HasAnySpecialAttribute (ICustomAttributeProvider method)
+		{
+			if (!method.HasCustomAttributes)
+				return false;
+
+			foreach (CustomAttribute ca in method.CustomAttributes) {
+				TypeReference cat = ca.AttributeType;
+				string name = cat.Name;
+				if ((cat.IsNamed ("System.Diagnostics", name)) || (cat.Namespace == "System.Runtime.InteropServices" && 
+					(name == "ComRegisterFunctionAttribute" || name == "ComUnregisterFunctionAttribute"))) {
+					return true;
+				}
+			}
+			return false;
+		}
 
 		static private bool Applicable (MethodDefinition method)
 		{
@@ -119,10 +129,8 @@ namespace Gendarme.Rules.Performance {
 
 			// does not apply if the method is used to register/unregister COM objects
 			// or it is decorated with a [Conditional("x")] attribute
-			if (method.HasCustomAttributes) {
-				if (method.CustomAttributes.ContainsAnyType (SpecialAttributes))
-					return false;
-			}
+			if (HasAnySpecialAttribute (method))
+				return false;
 
 			return true;
 		}
@@ -301,7 +309,7 @@ namespace Gendarme.Rules.Performance {
 			return methods;
 		}
 
-		private static void BuildMethodUsage (HashSet<ulong> methods, MethodDefinition method)
+		private static void BuildMethodUsage (ISet<ulong> methods, MethodDefinition method)
 		{
 			foreach (Instruction ins in method.Body.Instructions) {
 				MethodReference mr = (ins.Operand as MethodReference);
@@ -310,7 +318,7 @@ namespace Gendarme.Rules.Performance {
 					continue;
 
 				TypeReference type = mr.DeclaringType;
-				if (!(type is ArrayType)) {
+				if (!type.IsArray) {
 					// if (type.GetElementType ().HasGenericParameters)
 					// the simpler ^^^ does not work under Mono but works on MS
 					type = type.Resolve ();
diff --git a/gendarme/rules/Gendarme.Rules.Performance/AvoidUninstantiatedInternalClassesRule.cs b/gendarme/rules/Gendarme.Rules.Performance/AvoidUninstantiatedInternalClassesRule.cs
index 518a451..2406244 100644
--- a/gendarme/rules/Gendarme.Rules.Performance/AvoidUninstantiatedInternalClassesRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Performance/AvoidUninstantiatedInternalClassesRule.cs
@@ -101,7 +101,7 @@ namespace Gendarme.Rules.Performance {
 			cache.Add (assembly, typeset);
 		}
 
-		static void AddType (HashSet<TypeReference> typeset, TypeReference type)
+		static void AddType (ISet<TypeReference> typeset, TypeReference type)
 		{
 			// we're interested in the array element type, not the array itself
 			if (type.IsArray)
@@ -240,7 +240,7 @@ namespace Gendarme.Rules.Performance {
 			// if we can't find the non-public type being used in the assembly then the rule fails
 			if (typeset == null || !typeset.Contains (type)) {
 				// base confidence on whether the internals are visible or not
-				Confidence c = assembly.HasAttribute ("System.Runtime.CompilerServices.InternalsVisibleToAttribute") ? 
+				Confidence c = assembly.HasAttribute ("System.Runtime.CompilerServices", "InternalsVisibleToAttribute") ? 
 					Confidence.Low : Confidence.Normal;
 				Runner.Report (type, Severity.High, c);
 				return RuleResult.Failure;
diff --git a/gendarme/rules/Gendarme.Rules.Performance/AvoidUnnecessaryOverridesRule.cs b/gendarme/rules/Gendarme.Rules.Performance/AvoidUnnecessaryOverridesRule.cs
index 5dac506..f1c9d8b 100644
--- a/gendarme/rules/Gendarme.Rules.Performance/AvoidUnnecessaryOverridesRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Performance/AvoidUnnecessaryOverridesRule.cs
@@ -80,8 +80,9 @@ namespace Gendarme.Rules.Performance {
 			if (!mr.CompareSignature (method))
 				return false;
 
+			TypeReference type = mr.DeclaringType;
 			foreach (TypeDefinition baseType in method.DeclaringType.AllSuperTypes ()) {
-				if (mr.DeclaringType.FullName == baseType.FullName)
+				if (baseType.IsNamed (type.Namespace, type.Name))
 					return true;
 			}
 			return false;
diff --git a/gendarme/rules/Gendarme.Rules.Performance/AvoidUnneededCallsOnStringRule.cs b/gendarme/rules/Gendarme.Rules.Performance/AvoidUnneededCallsOnStringRule.cs
index 212892a..08a051b 100644
--- a/gendarme/rules/Gendarme.Rules.Performance/AvoidUnneededCallsOnStringRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Performance/AvoidUnneededCallsOnStringRule.cs
@@ -29,6 +29,7 @@
 //
 
 using System;
+using System.Globalization;
 
 using Mono.Cecil;
 using Mono.Cecil.Cil;
@@ -126,15 +127,15 @@ namespace Gendarme.Rules.Performance {
 			if (call.HasParameters)
 				return String.Empty;
 
-			if (!IsSystemString (ins.Previous.GetOperandType (method)))
+			if (!ins.Previous.GetOperandType (method).IsNamed ("System", "String"))
 				return  String.Empty;
 
-			return String.Format (MessageString, call.Name, String.Empty);
+			return String.Format (CultureInfo.InvariantCulture, MessageString, call.Name, String.Empty);
 		}
 
 		private static string CheckSubstring (MethodReference call, Instruction ins)
 		{
-			if (!IsSystemString (call.DeclaringType))
+			if (!call.DeclaringType.IsNamed ("System", "String"))
 				return String.Empty;
 
 			// ensure it's System.String::Substring(System.Int32) and that it's given 0 as a parameter
@@ -143,24 +144,19 @@ namespace Gendarme.Rules.Performance {
 			if (!ins.Previous.IsOperandZero ())
 				return String.Empty;
 
-			return String.Format (MessageString, call.Name, "0");
+			return String.Format (CultureInfo.InvariantCulture, MessageString, call.Name, "0");
 		}
 
 		private static string CheckToString (MethodReference call, Instruction ins, MethodDefinition method)
 		{
-			if (IsSystemString (call.DeclaringType)) {
+			if (call.DeclaringType.IsNamed ("System", "String")) {
 				// most probably ToString(IFormatProvider), possibly ToString()
-				return String.Format (MessageString, call.Name, 
+				return String.Format (CultureInfo.InvariantCulture, MessageString, call.Name, 
 					(call.HasParameters && (call.Parameters.Count > 1)) ? "IFormatProvider" : String.Empty);
 			} else {
 				// signature for Clone is identical (well close enough) to share code
 				return CheckClone (call, ins, method);
 			}
 		}
-
-		private static bool IsSystemString (MemberReference type)
-		{
-			return (type == null) ? false : (type.FullName == "System.String");
-		}
 	}
 }
diff --git a/gendarme/rules/Gendarme.Rules.Performance/AvoidUnneededUnboxingRule.cs b/gendarme/rules/Gendarme.Rules.Performance/AvoidUnneededUnboxingRule.cs
index 06bbc3b..1b5e6d7 100644
--- a/gendarme/rules/Gendarme.Rules.Performance/AvoidUnneededUnboxingRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Performance/AvoidUnneededUnboxingRule.cs
@@ -28,6 +28,7 @@
 
 using System;
 using System.Collections.Generic;
+using System.Globalization;
 
 using Mono.Cecil;
 using Mono.Cecil.Cil;
@@ -95,7 +96,6 @@ namespace Gendarme.Rules.Performance {
 		private static string Previous (MethodDefinition method, Instruction ins)
 		{
 			string kind, name;
-			string type = (ins.Operand as TypeReference).FullName;
 
 			ins = ins.Previous;
 			Code previous_op_code = ins.OpCode.Code;
@@ -139,7 +139,8 @@ namespace Gendarme.Rules.Performance {
 			default:
 				return String.Empty;
 			}
-			return String.Format ("{0} '{1}' unboxed to type '{2}' {{0}} times.", kind, name, type);
+			return String.Format (CultureInfo.InvariantCulture, "{0} '{1}' unboxed to type '{2}' {{0}} times.", 
+				kind, name, (ins.Operand as TypeReference).GetFullName ());
 		}
 
 		// unboxing is never critical - but a high amount can be a sign of other problems too
@@ -189,7 +190,7 @@ namespace Gendarme.Rules.Performance {
 				// we can't (always) avoid unboxing one time
 				if (kvp.Value < 2)
 					continue;
-				string s = String.Format (kvp.Key, kvp.Value);
+				string s = String.Format (CultureInfo.InvariantCulture, kvp.Key, kvp.Value);
 				Runner.Report (method, GetSeverityFromCount (kvp.Value), Confidence.Normal, s);
 			}
 
diff --git a/gendarme/rules/Gendarme.Rules.Performance/AvoidUnsealedUninheritedInternalClassesRule.cs b/gendarme/rules/Gendarme.Rules.Performance/AvoidUnsealedUninheritedInternalClassesRule.cs
index c5f53ac..d7489c3 100644
--- a/gendarme/rules/Gendarme.Rules.Performance/AvoidUnsealedUninheritedInternalClassesRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Performance/AvoidUnsealedUninheritedInternalClassesRule.cs
@@ -74,16 +74,17 @@ namespace Gendarme.Rules.Performance {
 				return RuleResult.Success;
 
 			ModuleDefinition module = type.Module;
-			string type_name = type.FullName;
+			string name = type.Name;
+			string nspace = type.Namespace;
 			foreach (TypeDefinition type_definition in module.GetAllTypes ()) {
 				// skip ourself
-				if (type_definition.FullName == type_name)
+				if (type_definition.IsNamed (nspace, name))
 					continue;
-				if (type_definition.Inherits (type_name))
+				if (type_definition.Inherits (nspace, name))
 					return RuleResult.Success;
 			}
 
-			Confidence c = module.Assembly.HasAttribute ("System.Runtime.CompilerServices.InternalsVisibleToAttribute") ?
+			Confidence c = module.Assembly.HasAttribute ("System.Runtime.CompilerServices", "InternalsVisibleToAttribute") ?
 				Confidence.High : Confidence.Total;
 			Runner.Report (type, Severity.Medium, c);
 			return RuleResult.Failure;
diff --git a/gendarme/rules/Gendarme.Rules.Performance/AvoidUnusedParametersRule.cs b/gendarme/rules/Gendarme.Rules.Performance/AvoidUnusedParametersRule.cs
index 75a6448..8df328f 100644
--- a/gendarme/rules/Gendarme.Rules.Performance/AvoidUnusedParametersRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Performance/AvoidUnusedParametersRule.cs
@@ -30,6 +30,7 @@
 
 using System;
 using System.Collections.Generic;
+using System.Globalization;
 
 using Mono.Cecil;
 using Mono.Cecil.Cil;
@@ -132,10 +133,8 @@ namespace Gendarme.Rules.Performance {
 				return RuleResult.DoesNotApply;
 
 			// methods with [Conditional] can be empty (not using any parameter) IL-wise but not source-wise, ignore them
-			if (method.HasCustomAttributes) {
-				if (method.CustomAttributes.ContainsType ("System.Diagnostics.ConditionalAttribute"))
-					return RuleResult.DoesNotApply;
-			}
+			if (method.HasAttribute ("System.Diagnostics", "ConditionalAttribute"))
+				return RuleResult.DoesNotApply;
 
 			// rule applies
 
@@ -151,7 +150,7 @@ namespace Gendarme.Rules.Performance {
 				ParameterDefinition parameter = ins.GetParameter (method);
 				if (parameter == null)
 					continue;
-				mask |= ((ulong)1 << (parameter.GetSequence () - 1));
+				mask |= ((ulong)1 << parameter.Index);
 			}
 
 			// quick out based on value - i.e. every parameter is being used
@@ -162,7 +161,8 @@ namespace Gendarme.Rules.Performance {
 			for (int i = 0; i < pcount; i++) {
 				if ((mask & ((ulong) 1 << i)) == 0) {
 					ParameterDefinition parameter = pdc [i];
-					string text = String.Format ("Parameter '{0}' of type '{1}' is never used in the method.",
+					string text = String.Format (CultureInfo.InvariantCulture,
+						"Parameter '{0}' of type '{1}' is never used in the method.",
 						parameter.Name, parameter.ParameterType);
 					Runner.Report (parameter, Severity.Medium, Confidence.Normal, text);
 				}
diff --git a/gendarme/rules/Gendarme.Rules.Performance/AvoidUnusedPrivateFieldsRule.cs b/gendarme/rules/Gendarme.Rules.Performance/AvoidUnusedPrivateFieldsRule.cs
index bc8c0e5..72a548c 100644
--- a/gendarme/rules/Gendarme.Rules.Performance/AvoidUnusedPrivateFieldsRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Performance/AvoidUnusedPrivateFieldsRule.cs
@@ -105,13 +105,32 @@ namespace Gendarme.Rules.Performance {
 			// copy all fields into an hashset
 			fields.Clear ();
 			foreach (FieldDefinition field in type.Fields) {
-				if (!field.IsPrivate || field.IsLiteral)
+				if (!field.IsPrivate || field.IsLiteral || field.IsGeneratedCode ())
 					continue;
 
 				fields.Add (field);
 			}
 
 			// scan all methods, including constructors, to find if the field is used
+			if (fields.Count > 0) {
+				CheckFieldsUsageInType (type);
+
+				// scan nested types becuase they also have access to private fields of their parent
+				if (type.HasNestedTypes) {
+					foreach (TypeDefinition nested in type.NestedTypes)
+						CheckFieldsUsageInType (nested);
+				}
+
+				// check remaining (private) fields in the set
+				foreach (FieldDefinition field in fields) {
+					Runner.Report (field, Severity.Medium, Confidence.Normal);
+				}
+			}
+			return Runner.CurrentRuleResult;
+		}
+
+		private void CheckFieldsUsageInType (TypeDefinition type)
+		{
 			foreach (MethodDefinition method in type.Methods) {
 				if (!method.HasBody)
 					continue;
@@ -127,14 +146,12 @@ namespace Gendarme.Rules.Performance {
 
 					fields.Remove (fd);
 				}
+				
+				if (fields.Count == 0)
+					break;				
 			}
-
-			// check remaining (private) fields in the set
-			foreach (FieldDefinition field in fields) {
-				Runner.Report (field, Severity.Medium, Confidence.Normal);
-			}
-			return Runner.CurrentRuleResult;
 		}
+
 #if false
 		public void Bitmask ()
 		{
diff --git a/gendarme/rules/Gendarme.Rules.Performance/CompareWithStringEmptyEfficientlyRule.cs b/gendarme/rules/Gendarme.Rules.Performance/CompareWithStringEmptyEfficientlyRule.cs
index 61fdee9..47f6e1e 100644
--- a/gendarme/rules/Gendarme.Rules.Performance/CompareWithStringEmptyEfficientlyRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Performance/CompareWithStringEmptyEfficientlyRule.cs
@@ -94,13 +94,16 @@ namespace Gendarme.Rules.Performance {
 				case "Equals":
 					if (mref.Parameters.Count > 1)
 						continue;
-					string tname = mref.DeclaringType.FullName;
-					if ((tname != "System.String") && (tname != "System.Object"))
+					TypeReference type = mref.DeclaringType;
+					if (type.Namespace != "System")
+						continue;
+					string name = type.Name;
+					if ((name != "String") && (name != "Object"))
 						continue;
 					break;
 				case "op_Equality":
 				case "op_Inequality":
-					if (mref.DeclaringType.FullName != "System.String")
+					if (!mref.DeclaringType.IsNamed ("System", "String"))
 						continue;
 					break;
 				default:
@@ -115,7 +118,7 @@ namespace Gendarme.Rules.Performance {
 					break;
 				case Code.Ldsfld:
 					FieldReference field = (prev.Operand as FieldReference);
-					if (field.DeclaringType.FullName != "System.String")
+					if (!field.DeclaringType.IsNamed ("System", "String"))
 						continue;
 					// unlikely to be anything else (at least with released fx)
 					if (field.Name != "Empty")
diff --git a/gendarme/rules/Gendarme.Rules.Performance/DontIgnoreMethodResultRule.cs b/gendarme/rules/Gendarme.Rules.Performance/DontIgnoreMethodResultRule.cs
index aadb867..fbd1931 100644
--- a/gendarme/rules/Gendarme.Rules.Performance/DontIgnoreMethodResultRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Performance/DontIgnoreMethodResultRule.cs
@@ -29,6 +29,7 @@
 //
 
 using System;
+using System.Globalization;
 
 using Mono.Cecil;
 using Mono.Cecil.Cil;
@@ -99,17 +100,17 @@ namespace Gendarme.Rules.Performance {
 
 		private static bool IsCallException (MethodReference method)
 		{
-			switch (method.DeclaringType.FullName) {
+			switch (method.DeclaringType.GetFullName ()) {
 			case "System.String":
 				// Since strings are immutable, calling System.String methods that returns strings 
 				// better be assigned to something
-				return (method.ReturnType.FullName != "System.String");
+				return !method.ReturnType.IsNamed ("System", "String");
 			case "System.IO.DirectoryInfo":
 				// GetDirectories overloads don't apply to the instance
 				return (method.Name != "GetDirectories");
 			case "System.Security.PermissionSet":
 				// Intersection and Union returns a new PermissionSet (it does not change the instance)
-				return (method.ReturnType.FullName != "System.Security.PermissionSet");
+				return !method.ReturnType.IsNamed ("System.Security", "PermissionSet");
 			default:
 				// this is useless anytime, if unassigned, more in cases like a StringBuilder
 				return (method.Name != "ToString");
@@ -118,7 +119,7 @@ namespace Gendarme.Rules.Performance {
 
 		private static bool IsNewException (MemberReference method)
 		{
-			switch (method.ToString ()) {
+			switch (method.GetFullName ()) {
 			// supplying a callback is enough to make the Timer creation worthwhile
 			case "System.Void System.Threading.Timer::.ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)":
 				return true;
@@ -132,7 +133,8 @@ namespace Gendarme.Rules.Performance {
 			if ((instruction.OpCode.Code == Code.Newobj || instruction.OpCode.Code == Code.Newarr)) {
 				MemberReference member = (instruction.Operand as MemberReference);
 				if ((member != null) && !IsNewException (member)) {
-					string s = String.Format ("Unused object of type '{0}' created.", member.ToString ());
+					string s = String.Format (CultureInfo.InvariantCulture,
+						"Unused object of type '{0}' created.", member.GetFullName ());
 					Runner.Report (method, instruction, Severity.High, Confidence.Normal, s);
 				}
 			}
@@ -142,7 +144,8 @@ namespace Gendarme.Rules.Performance {
 				if (callee != null && !callee.ReturnType.IsValueType) {
 					// check for some common exceptions (to reduce false positive)
 					if (!IsCallException (callee)) {
-						string s = String.Format ("Do not ignore method results from call to '{0}'.", callee.ToString ());
+						string s = String.Format (CultureInfo.InvariantCulture,
+							"Do not ignore method results from call to '{0}'.", callee.GetFullName ());
 						Runner.Report (method, instruction, Severity.Medium, Confidence.Normal, s);
 					}
 				}
diff --git a/gendarme/rules/Gendarme.Rules.Performance/EmptyDestructorRule.cs b/gendarme/rules/Gendarme.Rules.Performance/EmptyDestructorRule.cs
index a6b3bb3..4971448 100644
--- a/gendarme/rules/Gendarme.Rules.Performance/EmptyDestructorRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Performance/EmptyDestructorRule.cs
@@ -27,6 +27,7 @@
 //
 
 using System;
+using System.Globalization;
 
 using Mono.Cecil;
 using Mono.Cecil.Cil;
@@ -131,7 +132,8 @@ namespace Gendarme.Rules.Performance {
 
 			// finalizer is empty (bad / useless)
 			string msg = nullify_fields == 0 ? String.Empty : 
-				String.Format ("Contains {0} fields being nullified needlessly", nullify_fields);
+				String.Format (CultureInfo.InvariantCulture, 
+					"Contains {0} fields being nullified needlessly", nullify_fields);
 			Runner.Report (type, Severity.Medium, Confidence.Normal, msg);
 			return RuleResult.Failure;
 		}
diff --git a/gendarme/rules/Gendarme.Rules.Performance/Gendarme.Rules.Performance.csproj b/gendarme/rules/Gendarme.Rules.Performance/Gendarme.Rules.Performance.csproj
index f9a5521..e8266ab 100755
--- a/gendarme/rules/Gendarme.Rules.Performance/Gendarme.Rules.Performance.csproj
+++ b/gendarme/rules/Gendarme.Rules.Performance/Gendarme.Rules.Performance.csproj
@@ -1,5 +1,5 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
-<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="3.5">
+<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="4.0">
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
     <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
@@ -12,9 +12,11 @@
     <AssemblyName>Gendarme.Rules.Performance</AssemblyName>
     <FileUpgradeFlags>
     </FileUpgradeFlags>
-    <OldToolsVersion>2.0</OldToolsVersion>
+    <OldToolsVersion>3.5</OldToolsVersion>
     <UpgradeBackupLocation>
     </UpgradeBackupLocation>
+    <IsWebBootstrapper>true</IsWebBootstrapper>
+    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
     <PublishUrl>http://localhost/Gendarme.Rules.Performance/</PublishUrl>
     <Install>true</Install>
     <InstallFrom>Web</InstallFrom>
@@ -27,10 +29,9 @@
     <MapFileExtensions>true</MapFileExtensions>
     <ApplicationRevision>0</ApplicationRevision>
     <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
-    <IsWebBootstrapper>true</IsWebBootstrapper>
     <UseApplicationTrust>false</UseApplicationTrust>
     <BootstrapperEnabled>true</BootstrapperEnabled>
-    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <TargetFrameworkProfile />
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
     <DebugSymbols>true</DebugSymbols>
@@ -43,6 +44,7 @@
     <DocumentationFile>..\..\console\bin\Debug\Gendarme.Rules.Performance.xml</DocumentationFile>
     <NoWarn>1591</NoWarn>
     <WarningsAsErrors>1570</WarningsAsErrors>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
     <DebugType>pdbonly</DebugType>
@@ -54,6 +56,7 @@
     <DocumentationFile>..\..\console\bin\Release\Gendarme.Rules.Performance.xml</DocumentationFile>
     <NoWarn>1591</NoWarn>
     <WarningsAsErrors>1570</WarningsAsErrors>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <ItemGroup>
     <Reference Include="System" />
@@ -117,14 +120,33 @@
     <None Include="ChangeLog" />
   </ItemGroup>
   <ItemGroup>
+    <BootstrapperPackage Include="Microsoft.Net.Client.3.5">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1 Client Profile</ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
     <BootstrapperPackage Include="Microsoft.Net.Framework.2.0">
       <Visible>False</Visible>
+      <ProductName>
+      </ProductName>
+      <Install>false</Install>
     </BootstrapperPackage>
     <BootstrapperPackage Include="Microsoft.Net.Framework.3.0">
       <Visible>False</Visible>
+      <ProductName>
+      </ProductName>
+      <Install>false</Install>
     </BootstrapperPackage>
     <BootstrapperPackage Include="Microsoft.Net.Framework.3.5">
       <Visible>False</Visible>
+      <ProductName>
+      </ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1</ProductName>
+      <Install>false</Install>
     </BootstrapperPackage>
   </ItemGroup>
   <Import Project="$(MSBuildBinPath)\Microsoft.CSharp.targets" />
diff --git a/gendarme/rules/Gendarme.Rules.Performance/IDisposableWithDestructorWithoutSuppressFinalizeRule.cs b/gendarme/rules/Gendarme.Rules.Performance/IDisposableWithDestructorWithoutSuppressFinalizeRule.cs
index 7d81391..d02c1c0 100644
--- a/gendarme/rules/Gendarme.Rules.Performance/IDisposableWithDestructorWithoutSuppressFinalizeRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Performance/IDisposableWithDestructorWithoutSuppressFinalizeRule.cs
@@ -128,7 +128,7 @@ namespace Gendarme.Rules.Performance {
 				case Code.Callvirt:
 					// are we calling GC.SuppressFinalize ?
 					MethodReference callee = (ins.Operand as MethodReference);
-					if ((callee.Name == "SuppressFinalize") && (callee.DeclaringType.FullName == "System.GC")) {
+					if (callee.IsNamed ("System", "GC", "SuppressFinalize")) {
 						return true;
 					} else if (level < 3) {
 						if (Recurse (callee.Resolve (), level + 1))
@@ -154,7 +154,7 @@ namespace Gendarme.Rules.Performance {
 				return RuleResult.DoesNotApply;
 
 			// rule applies to types that implements System.IDisposable
-			if (!type.Implements ("System.IDisposable"))
+			if (!type.Implements ("System", "IDisposable"))
 				return RuleResult.DoesNotApply;
 
 			// and provide a finalizer
diff --git a/gendarme/rules/Gendarme.Rules.Performance/ImplementEqualsTypeRule.cs b/gendarme/rules/Gendarme.Rules.Performance/ImplementEqualsTypeRule.cs
index 528a7cf..76240b4 100644
--- a/gendarme/rules/Gendarme.Rules.Performance/ImplementEqualsTypeRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Performance/ImplementEqualsTypeRule.cs
@@ -27,6 +27,7 @@
 //
 
 using System;
+using System.Globalization;
 
 using Mono.Cecil;
 
@@ -107,20 +108,20 @@ namespace Gendarme.Rules.Performance {
 			// * the assembly targets the 2.0 (or later) runtime
 			// * and it does not already implement it
 			if (type.Module.Runtime >= TargetRuntime.Net_2_0) {
-				if (!type.Implements ("System.IEquatable`1")) {
+				if (!type.Implements ("System", "IEquatable`1")) {
 					Runner.Report (type, Severity.Medium, Confidence.Total, "Implement System.IEquatable<T>");
 				}
 				return Runner.CurrentRuleResult;
 			}
 
-			parameters [0] = type.FullName;
+			parameters [0] = type.GetFullName ();
 			if (type.GetMethod (MethodAttributes.Public, "Equals", "System.Boolean", parameters) != null)
 				return RuleResult.Success;
 
 			// we consider this a step more severe for value types since it will need 
 			// boxing/unboxing with Equals(object)
 			Severity severity = type.IsValueType ? Severity.Medium : Severity.Low;
-			string msg = String.Format ("Implement 'bool Equals({0})'", type.Name);
+			string msg = String.Format (CultureInfo.InvariantCulture, "Implement 'bool Equals({0})'", type.Name);
 			Runner.Report (type, severity, Confidence.High, msg);
 			return RuleResult.Failure;
 		}
diff --git a/gendarme/rules/Gendarme.Rules.Performance/MathMinMaxCandidateRule.cs b/gendarme/rules/Gendarme.Rules.Performance/MathMinMaxCandidateRule.cs
index 37bca4c..b87866f 100644
--- a/gendarme/rules/Gendarme.Rules.Performance/MathMinMaxCandidateRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Performance/MathMinMaxCandidateRule.cs
@@ -83,18 +83,21 @@ namespace Gendarme.Rules.Performance {
 		// unlikely than any JIT inlines it
 		private static bool IsSupported (TypeReference type)
 		{
-			// GetOriginalType will remove the '&' for references
-			switch (type.GetElementType ().FullName) {
-			case "System.Byte":
-			case "System.Double":
-			case "System.Int16":
-			case "System.Int32":
-			case "System.Int64":
-			case "System.SByte":
-			case "System.Single":
-			case "System.UInt16":
-			case "System.UInt32":
-			case "System.UInt64":
+			if (type.Namespace != "System")
+				return false;
+			// GetElementType will remove the '&' for references
+			TypeReference tr = type.GetElementType ();
+			switch (tr.Name) {
+			case "Byte":
+			case "Double":
+			case "Int16":
+			case "Int32":
+			case "Int64":
+			case "SByte":
+			case "Single":
+			case "UInt16":
+			case "UInt32":
+			case "UInt64":
 				return true;
 			default:
 				return false;
diff --git a/gendarme/rules/Gendarme.Rules.Performance/OverrideValueTypeDefaultsRule.cs b/gendarme/rules/Gendarme.Rules.Performance/OverrideValueTypeDefaultsRule.cs
index 5ab9c1c..169ced5 100644
--- a/gendarme/rules/Gendarme.Rules.Performance/OverrideValueTypeDefaultsRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Performance/OverrideValueTypeDefaultsRule.cs
@@ -27,6 +27,7 @@
 //
 
 using System;
+using System.Globalization;
 
 using Mono.Cecil;
 
@@ -118,7 +119,7 @@ namespace Gendarme.Rules.Performance {
 			// drop severity one level if only operators are missing (since overloading them
 			// is not available in every language)
 			Severity severity = (equals || gethashcode) ? Severity.Medium : Severity.Low;
-			string msg = String.Format (MissingImplementationMessage,
+			string msg = String.Format (CultureInfo.InvariantCulture, MissingImplementationMessage,
 				!equals && !gethashcode ? "Equals(object)' and 'GetHashCode()" : equals ? "GetHashCode()" : "Equals(object)",
 				operators ? String.Empty : MissingOperatorsMessage);
 
diff --git a/gendarme/rules/Gendarme.Rules.Performance/PreferCharOverloadRule.cs b/gendarme/rules/Gendarme.Rules.Performance/PreferCharOverloadRule.cs
index a81b773..84c84aa 100644
--- a/gendarme/rules/Gendarme.Rules.Performance/PreferCharOverloadRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Performance/PreferCharOverloadRule.cs
@@ -28,6 +28,7 @@
 
 using System;
 using System.Collections.Generic;
+using System.Globalization;
 
 using Mono.Cecil;
 using Mono.Cecil.Cil;
@@ -93,7 +94,8 @@ namespace Gendarme.Rules.Performance {
 
 		void Report (MethodDefinition method, Instruction ins, Confidence confidence, MemberReference call, string parameter)
 		{
-			string msg = String.Format ("Prefer the use of: {0}('{1}'...);", call.Name, parameter);
+			string msg = String.Format (CultureInfo.InvariantCulture, "Prefer the use of: {0}('{1}'...);", 
+				call.Name, parameter);
 			Runner.Report (method, ins, Severity.Medium, confidence, msg);
 		}
 
@@ -106,7 +108,7 @@ namespace Gendarme.Rules.Performance {
 
 			IList<ParameterDefinition> pdc = call.Parameters;
 			int last = pdc.Count;
-			if (pdc [last - 1].ParameterType.FullName != "System.StringComparison") {
+			if (!pdc [last - 1].ParameterType.IsNamed ("System", "StringComparison")) {
 				// confidence is normal because it's possible that the code expects a
 				// culture sensitive comparison (but that will break in .NET 4).
 				Report (method, ins, Confidence.Normal, call, p1);
@@ -140,14 +142,15 @@ namespace Gendarme.Rules.Performance {
 			if (p2.Length != 1)
 				return;
 
-			string msg = String.Format ("Prefer the use of: Replace('{0}','{1}');", p1, p2);
+			string msg = String.Format (CultureInfo.InvariantCulture, 
+				"Prefer the use of: Replace('{0}','{1}');", p1, p2);
 			// confidence is higher since there's no StringComparison to consider
 			Runner.Report (method, ins, Severity.Medium, Confidence.High, msg);
 		}
 
 		static bool CheckFirstParameterIsString (IMethodSignature method)
 		{
-			return (method.HasParameters && (method.Parameters [0].ParameterType.FullName == "System.String"));
+			return (method.HasParameters && method.Parameters [0].ParameterType.IsNamed ("System", "String"));
 		}
 
 		public RuleResult CheckMethod (MethodDefinition method)
@@ -165,7 +168,7 @@ namespace Gendarme.Rules.Performance {
 					continue;
 
 				MethodReference call = (ins.Operand as MethodReference);
-				if (call.DeclaringType.FullName != "System.String")
+				if (!call.DeclaringType.IsNamed ("System", "String"))
 					continue;
 
 				switch (call.Name) {
diff --git a/gendarme/rules/Gendarme.Rules.Performance/PreferInterfaceConstraintOnGenericParameterForPrimitiveInterfaceRule.cs b/gendarme/rules/Gendarme.Rules.Performance/PreferInterfaceConstraintOnGenericParameterForPrimitiveInterfaceRule.cs
index 2567025..6dac441 100644
--- a/gendarme/rules/Gendarme.Rules.Performance/PreferInterfaceConstraintOnGenericParameterForPrimitiveInterfaceRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Performance/PreferInterfaceConstraintOnGenericParameterForPrimitiveInterfaceRule.cs
@@ -28,7 +28,10 @@
 
 using System;
 using System.Collections.Generic;
+using System.Globalization;
+
 using Gendarme.Framework;
+using Gendarme.Framework.Rocks;
 using Mono.Cecil;
 
 namespace Gendarme.Rules.Performance {
@@ -61,41 +64,49 @@ namespace Gendarme.Rules.Performance {
 	[Solution("Replace the interface parameter with interface constraint on generic type parameter.")]
 	public class PreferInterfaceConstraintOnGenericParameterForPrimitiveInterfaceRule : Rule, IMethodRule {
 
-		private readonly HashSet<string> primitiveTypeInterfaces = new HashSet<string> ();
+		static bool CheckGenericArgument (GenericInstanceType git)
+		{
+			if ((git == null) || !git.HasGenericArguments)
+				return false; // should not happen with the '`1' but...
+
+			TypeReference arg = git.GenericArguments [0];
+			switch (arg.MetadataType) {
+			case MetadataType.MVar:
+				return (arg.IsGenericParameter && arg.IsNamed (String.Empty, "T"));
+			case MetadataType.ValueType:
+				return arg.IsNamed ("System", "Decimal");
+			case MetadataType.Boolean:
+			case MetadataType.Byte:
+			case MetadataType.Char:
+			case MetadataType.Double:
+			case MetadataType.Single:
+			case MetadataType.Int16:
+			case MetadataType.Int32:
+			case MetadataType.Int64:
+			case MetadataType.SByte:
+			case MetadataType.UInt16:
+			case MetadataType.UInt32:
+			case MetadataType.UInt64:
+				return true;
+			default:
+				return false;
+			}
+		}
 
-		public PreferInterfaceConstraintOnGenericParameterForPrimitiveInterfaceRule ()
+		static bool IsPrimitiveInterface (MemberReference type)
 		{
-			primitiveTypeInterfaces.Add ("System.IComparable");
-			primitiveTypeInterfaces.Add ("System.IComparable`1<T>");
-			primitiveTypeInterfaces.Add ("System.IComparable`1<System.Boolean>");
-			primitiveTypeInterfaces.Add ("System.IComparable`1<System.Byte>");
-			primitiveTypeInterfaces.Add ("System.IComparable`1<System.Char>");
-			primitiveTypeInterfaces.Add ("System.IComparable`1<System.Decimal>");
-			primitiveTypeInterfaces.Add ("System.IComparable`1<System.Double>");
-			primitiveTypeInterfaces.Add ("System.IComparable`1<System.Float>");
-			primitiveTypeInterfaces.Add ("System.IComparable`1<System.Int32>");
-			primitiveTypeInterfaces.Add ("System.IComparable`1<System.Int64>");
-			primitiveTypeInterfaces.Add ("System.IComparable`1<System.SByte>");
-			primitiveTypeInterfaces.Add ("System.IComparable`1<System.Short>");
-			primitiveTypeInterfaces.Add ("System.IComparable`1<System.UInt16>");
-			primitiveTypeInterfaces.Add ("System.IComparable`1<System.UInt32>");
-			primitiveTypeInterfaces.Add ("System.IComparable`1<System.UInt64>");
-			primitiveTypeInterfaces.Add ("System.IFormattable");
-			primitiveTypeInterfaces.Add ("System.IConvertible");
-			primitiveTypeInterfaces.Add ("System.IEquatable`1<T>");
-			primitiveTypeInterfaces.Add ("System.IEquatable`1<System.Boolean>");
-			primitiveTypeInterfaces.Add ("System.IEquatable`1<System.Byte>");
-			primitiveTypeInterfaces.Add ("System.IEquatable`1<System.Char>");
-			primitiveTypeInterfaces.Add ("System.IEquatable`1<System.Decimal>");
-			primitiveTypeInterfaces.Add ("System.IEquatable`1<System.Double>");
-			primitiveTypeInterfaces.Add ("System.IEquatable`1<System.Float>");
-			primitiveTypeInterfaces.Add ("System.IEquatable`1<System.Int32>");
-			primitiveTypeInterfaces.Add ("System.IEquatable`1<System.Int64>");
-			primitiveTypeInterfaces.Add ("System.IEquatable`1<System.SByte>");
-			primitiveTypeInterfaces.Add ("System.IEquatable`1<System.Short>");
-			primitiveTypeInterfaces.Add ("System.IEquatable`1<System.UInt16>");
-			primitiveTypeInterfaces.Add ("System.IEquatable`1<System.UInt32>");
-			primitiveTypeInterfaces.Add ("System.IEquatable`1<System.UInt64>");
+			switch (type.Name) {
+			case "IComparable":
+			case "IFormattable":
+			case "IConvertible":
+				return true; // no doubt
+			case "IComparable`1":
+			case "IEquatable`1":
+				// maybe, check generic argument type
+				return CheckGenericArgument (type as GenericInstanceType);
+			default:
+				return false;
+			}
 		}
 
 		public RuleResult CheckMethod (MethodDefinition method)
@@ -108,10 +119,10 @@ namespace Gendarme.Rules.Performance {
 				if (type.Namespace != "System")
 					continue;
 
-				string tname = type.FullName;
-				if (primitiveTypeInterfaces.Contains (tname)) {
-					string msg = String.Format ("You are using {0} as parameter, which cause boxing with value type as argument",
-						tname);
+				if (IsPrimitiveInterface (type)) {
+					string msg = String.Format (CultureInfo.InvariantCulture,
+						"You are using {0} as parameter, which cause boxing with value type as argument",
+						type.GetFullName ());
 					Runner.Report (method, Severity.Low, Confidence.Total, msg);
 				}
 			}
diff --git a/gendarme/rules/Gendarme.Rules.Performance/PreferLiteralOverInitOnlyFieldsRule.cs b/gendarme/rules/Gendarme.Rules.Performance/PreferLiteralOverInitOnlyFieldsRule.cs
index a28601b..31310f8 100644
--- a/gendarme/rules/Gendarme.Rules.Performance/PreferLiteralOverInitOnlyFieldsRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Performance/PreferLiteralOverInitOnlyFieldsRule.cs
@@ -113,7 +113,7 @@ namespace Gendarme.Rules.Performance {
 				// and report constant stuff
 				if (Constant.Get (previous.OpCode.Code)) {
 					// adjust severity based on the field visibility and it's type
-					Severity s = (field.FieldType.FullName == "System.String" || !field.IsVisible ()) ?
+					Severity s = (field.FieldType.IsNamed ("System", "String") || !field.IsVisible ()) ?
 						Severity.High : Severity.Medium;
 					Runner.Report (field, s, Confidence.Normal);
 				}
diff --git a/gendarme/rules/Gendarme.Rules.Performance/README.md b/gendarme/rules/Gendarme.Rules.Performance/README.md
new file mode 100644
index 0000000..5ef5f3b
--- /dev/null
+++ b/gendarme/rules/Gendarme.Rules.Performance/README.md
@@ -0,0 +1,9 @@
+# Gendarme.Rules.Performance Rules
+
+You can access the latest rules documentation from our [[wiki|https://github.com/spouliot/gendarme/wiki/Gendarme.Rules.Performance(git)]] pages.
+
+
+## Feedback
+
+Please report any documentation errors, typos or suggestions to the [[Gendarme Mailing List|https://groups.google.com/forum/?fromgroups#!forum/gendarme]]. Thanks!
+
diff --git a/gendarme/rules/Gendarme.Rules.Performance/RemoveUnusedLocalVariablesRule.cs b/gendarme/rules/Gendarme.Rules.Performance/RemoveUnusedLocalVariablesRule.cs
index bf1cda5..ac4ece9 100644
--- a/gendarme/rules/Gendarme.Rules.Performance/RemoveUnusedLocalVariablesRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Performance/RemoveUnusedLocalVariablesRule.cs
@@ -28,6 +28,7 @@
 
 using System;
 using System.Collections;
+using System.Globalization;
 
 using Mono.Cecil;
 using Mono.Cecil.Cil;
@@ -132,8 +133,8 @@ namespace Gendarme.Rules.Performance {
 					if (variable.IsGeneratedName ())
 						continue;
 
-					string s = String.Format ("Variable '{0}' of type '{1}'", 
-						variable.Name, variable.VariableType.FullName);
+					string s = String.Format (CultureInfo.InvariantCulture, "Variable '{0}' of type '{1}'", 
+						variable.Name, variable.VariableType.GetFullName ());
 					Runner.Report (method, Severity.Low, Confidence.Normal, s);
 				}
 			}
diff --git a/gendarme/rules/Gendarme.Rules.Performance/ReviewLinqMethodRule.cs b/gendarme/rules/Gendarme.Rules.Performance/ReviewLinqMethodRule.cs
index 0bef7c2..095c240 100644
--- a/gendarme/rules/Gendarme.Rules.Performance/ReviewLinqMethodRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Performance/ReviewLinqMethodRule.cs
@@ -28,6 +28,7 @@
 
 using System;
 using System.Collections.Generic;
+using System.Globalization;
 
 using Mono.Cecil;
 using Mono.Cecil.Cil;
@@ -96,10 +97,6 @@ namespace Gendarme.Rules.Performance {
 	[EngineDependency (typeof (OpCodeEngine))]
 	public sealed class ReviewLinqMethodRule : Rule, IMethodRule {
 
-		private const string EnumerableName = "System.Linq.Enumerable";
-
-		//private readonly OpCodeBitmask Comparisons = ComparisonsBitmask ();
-		//private readonly OpCodeBitmask Conditions = ConditionsBitmask ();
 		private readonly OpCodeBitmask Comparisons = new OpCodeBitmask (0x2801400000000000, 0x0, 0x0, 0xB);
 		private readonly OpCodeBitmask Conditions = new OpCodeBitmask (0x300180000000000, 0x0, 0x0, 0x0);
 
@@ -181,14 +178,16 @@ namespace Gendarme.Rules.Performance {
 		private void CheckForSubscript (TypeReference type, MethodDefinition method, Instruction ins, string name)
 		{
 			if (type.IsArray) {
-				string message = string.Format ("Use operator [] instead of the {0} method.", name);
+				string message = String.Format (CultureInfo.InvariantCulture, 
+					"Use operator [] instead of the {0} method.", name);
 				Log.WriteLine (this, "{0:X4} {1}", ins.Offset, message);
 				Runner.Report (method, ins, Severity.Medium, Confidence.High, message);
 
 			} else {
 				TypeDefinition td = type.Resolve ();						// resolve of an array returns the element type...
 				if (td != null && HasMethod (td, Subscript)) {
-					string message = string.Format ("Use operator [] instead of the {0} method.", name);
+					string message = String.Format (CultureInfo.InvariantCulture,
+						"Use operator [] instead of the {0} method.", name);
 					Log.WriteLine (this, "{0:X4} {1}", ins.Offset, message);
 					Runner.Report (method, ins, Severity.Medium, Confidence.High, message);
 				}
@@ -198,14 +197,16 @@ namespace Gendarme.Rules.Performance {
 		private void CheckForSort (TypeReference type, MethodDefinition method, Instruction ins, string name)
 		{
 			if (type.IsArray) {
-				string message = string.Format ("Use Array.Sort instead of the {0} method.", name);
+				string message = String.Format (CultureInfo.InvariantCulture,
+					"Use Array.Sort instead of the {0} method.", name);
 				Log.WriteLine (this, "{0:X4} {1}", ins.Offset, message);
 				Runner.Report (method, ins, Severity.Medium, Confidence.High, message);
 
 			} else {
 				TypeDefinition td = type.Resolve ();						// resolve of an array returns the element type...
 				if (td != null && HasMethod (td, Sort)) {
-					string message = string.Format ("Use Sort instead of the {0} method.", name);
+					string message = String.Format (CultureInfo.InvariantCulture,
+						"Use Sort instead of the {0} method.", name);
 					Log.WriteLine (this, "{0:X4} {1}", ins.Offset, message);
 					Runner.Report (method, ins, Severity.Medium, Confidence.High, message);
 				}
@@ -251,7 +252,7 @@ namespace Gendarme.Rules.Performance {
 				
 				// and the method is a System.Linq.Enumerable method then,
 				var target = ins.Operand as MethodReference;
-				if ((target == null) || (target.DeclaringType.FullName != EnumerableName))
+				if (!target.DeclaringType.IsNamed ("System.Linq", "Enumerable"))
 					continue;
 
 				string tname = target.Name;
diff --git a/gendarme/rules/Gendarme.Rules.Performance/Test/AvoidRepetitiveCallsToPropertiesTest.cs b/gendarme/rules/Gendarme.Rules.Performance/Test/AvoidRepetitiveCallsToPropertiesTest.cs
index a82ddf4..fe00fcc 100644
--- a/gendarme/rules/Gendarme.Rules.Performance/Test/AvoidRepetitiveCallsToPropertiesTest.cs
+++ b/gendarme/rules/Gendarme.Rules.Performance/Test/AvoidRepetitiveCallsToPropertiesTest.cs
@@ -240,8 +240,8 @@ namespace Test.Rules.Performance {
 			if ((source == null) || (target == null))
 				return false;
 
-			int ss = source.GetSequence () - 1;
-			int ts = target.GetSequence () - 1;
+			int ss = source.Index;
+			int ts = target.Index;
 			if ((ss <= 0) || (ts <= 0))
 				return false;
 
diff --git a/gendarme/rules/Gendarme.Rules.Performance/Test/AvoidUnusedPrivateFieldsTest.cs b/gendarme/rules/Gendarme.Rules.Performance/Test/AvoidUnusedPrivateFieldsTest.cs
index 212bebf..98fbb3a 100644
--- a/gendarme/rules/Gendarme.Rules.Performance/Test/AvoidUnusedPrivateFieldsTest.cs
+++ b/gendarme/rules/Gendarme.Rules.Performance/Test/AvoidUnusedPrivateFieldsTest.cs
@@ -162,5 +162,46 @@ namespace Test.Rules.Performance {
 			AssertRuleFailure<GenericUnused<int>> (1);
 			AssertRuleSuccess<GenericUsed<int>> ();
 		}
+
+		class FieldsUsedInNested {
+			private bool field;
+
+			private static string staticField;
+
+			class Nested {
+				public void Foo (FieldsUsedInNested parent)
+				{
+					FieldsUsedInNested.staticField = "bar";
+					parent.field = true;
+				}
+			}
+		}
+
+		[Test]
+		public void FieldsUsedInNestedType ()
+		{
+			AssertRuleSuccess<FieldsUsedInNested> ();
+		}
+		
+		class CompilerGenerated {
+			public string Name { get; set; }
+		}
+		
+		[Test]
+		public void ClassWithCompilerGeneratedFields ()
+		{
+			AssertRuleSuccess<CompilerGenerated> ();
+		}
+		
+		class CompilerGeneratedAndUnused {
+			private int number;
+			public string Name { get; set; }
+		}
+		
+		[Test]
+		public void ClassWithCompilerGeneratedFieldsAndUnusedPrivate ()
+		{
+			AssertRuleFailure<CompilerGeneratedAndUnused> (1);
+		}
 	}
 }
diff --git a/gendarme/rules/Gendarme.Rules.Performance/Test/PreferInterfaceConstraintOnGenericParameterForPrimitiveInterfaceTest.cs b/gendarme/rules/Gendarme.Rules.Performance/Test/PreferInterfaceConstraintOnGenericParameterForPrimitiveInterfaceTest.cs
index 22200a8..76b1fc0 100644
--- a/gendarme/rules/Gendarme.Rules.Performance/Test/PreferInterfaceConstraintOnGenericParameterForPrimitiveInterfaceTest.cs
+++ b/gendarme/rules/Gendarme.Rules.Performance/Test/PreferInterfaceConstraintOnGenericParameterForPrimitiveInterfaceTest.cs
@@ -52,7 +52,17 @@ namespace Tests.Rules.Performance {
 
 			}
 
-			private void MethodWithGenericInterfaceOfBaseTypeParameter2 (IComparable<int> comparable)
+			private void MethodWithGenericInterfaceOfBaseTypeParameter2a (IComparable<int> comparable)
+			{
+
+			}
+
+			private void MethodWithGenericInterfaceOfBaseTypeParameter2b (IComparable<decimal> comparable)
+			{
+
+			}
+
+			private void MethodWithGenericInterfaceOfBaseTypeParameter2c (IComparable<object> comparable)
 			{
 
 			}
@@ -101,25 +111,27 @@ namespace Tests.Rules.Performance {
 		[Test]
 		public void MethodWithInterfaceOfBaseTypeParameter ()
 		{
-			AssertRuleFailure<TestCase> ("MethodWithInterfaceOfBaseTypeParameter");
+			AssertRuleFailure<TestCase> ("MethodWithInterfaceOfBaseTypeParameter", 1);
 		}
 
 		[Test]
 		public void MethodWithGenericInterfaceOfBaseTypeParameter ()
 		{
-			AssertRuleFailure<TestCase> ("MethodWithGenericInterfaceOfBaseTypeParameter");
+			AssertRuleFailure<TestCase> ("MethodWithGenericInterfaceOfBaseTypeParameter", 1);
 		}
 
 		[Test]
 		public void MethodWithGenericInterfaceOfBaseTypeParameter2 ()
 		{
-			AssertRuleFailure<TestCase> ("MethodWithGenericInterfaceOfBaseTypeParameter2");
+			AssertRuleFailure<TestCase> ("MethodWithGenericInterfaceOfBaseTypeParameter2a", 1);
+			AssertRuleFailure<TestCase> ("MethodWithGenericInterfaceOfBaseTypeParameter2b", 1);
+			AssertRuleSuccess<TestCase> ("MethodWithGenericInterfaceOfBaseTypeParameter2c");
 		}
 
 		[Test]
 		public void MethodWithMultipleParameters ()
 		{
-			AssertRuleFailure<TestCase> ("MethodWithMultipleParameters");
+			AssertRuleFailure<TestCase> ("MethodWithMultipleParameters", 1);
 		}
 
 		[Test]
diff --git a/gendarme/rules/Gendarme.Rules.Performance/Test/Tests.Rules.Performance.csproj b/gendarme/rules/Gendarme.Rules.Performance/Test/Tests.Rules.Performance.csproj
index 16c7b64..531edcd 100755
--- a/gendarme/rules/Gendarme.Rules.Performance/Test/Tests.Rules.Performance.csproj
+++ b/gendarme/rules/Gendarme.Rules.Performance/Test/Tests.Rules.Performance.csproj
@@ -1,5 +1,5 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
-<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="3.5">
+<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="4.0">
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
     <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
@@ -12,9 +12,11 @@
     <AssemblyName>Tests.Rules.Performance</AssemblyName>
     <FileUpgradeFlags>
     </FileUpgradeFlags>
-    <OldToolsVersion>2.0</OldToolsVersion>
+    <OldToolsVersion>3.5</OldToolsVersion>
     <UpgradeBackupLocation>
     </UpgradeBackupLocation>
+    <IsWebBootstrapper>true</IsWebBootstrapper>
+    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
     <PublishUrl>http://localhost/Tests.Rules.Performance/</PublishUrl>
     <Install>true</Install>
     <InstallFrom>Web</InstallFrom>
@@ -27,10 +29,9 @@
     <MapFileExtensions>true</MapFileExtensions>
     <ApplicationRevision>0</ApplicationRevision>
     <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
-    <IsWebBootstrapper>true</IsWebBootstrapper>
     <UseApplicationTrust>false</UseApplicationTrust>
     <BootstrapperEnabled>true</BootstrapperEnabled>
-    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <TargetFrameworkProfile />
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
     <DebugSymbols>true</DebugSymbols>
@@ -41,6 +42,7 @@
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
     <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
     <DebugType>pdbonly</DebugType>
@@ -50,6 +52,7 @@
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
     <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <ItemGroup>
     <Reference Include="nunit.framework, Version=2.4.8.0, Culture=neutral, PublicKeyToken=96d09a1eb7f44a77, processorArchitecture=MSIL">
@@ -121,14 +124,33 @@
     </ProjectReference>
   </ItemGroup>
   <ItemGroup>
+    <BootstrapperPackage Include="Microsoft.Net.Client.3.5">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1 Client Profile</ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
     <BootstrapperPackage Include="Microsoft.Net.Framework.2.0">
       <Visible>False</Visible>
+      <ProductName>
+      </ProductName>
+      <Install>false</Install>
     </BootstrapperPackage>
     <BootstrapperPackage Include="Microsoft.Net.Framework.3.0">
       <Visible>False</Visible>
+      <ProductName>
+      </ProductName>
+      <Install>false</Install>
     </BootstrapperPackage>
     <BootstrapperPackage Include="Microsoft.Net.Framework.3.5">
       <Visible>False</Visible>
+      <ProductName>
+      </ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1</ProductName>
+      <Install>false</Install>
     </BootstrapperPackage>
   </ItemGroup>
   <Import Project="$(MSBuildBinPath)\Microsoft.CSharp.targets" />
diff --git a/gendarme/rules/Gendarme.Rules.Performance/UseTypeEmptyTypesRule.cs b/gendarme/rules/Gendarme.Rules.Performance/UseTypeEmptyTypesRule.cs
index 21b0879..92efb53 100644
--- a/gendarme/rules/Gendarme.Rules.Performance/UseTypeEmptyTypesRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Performance/UseTypeEmptyTypesRule.cs
@@ -83,9 +83,7 @@ namespace Gendarme.Rules.Performance {
 				if (ins.OpCode != OpCodes.Newarr)
 					continue;
 
-				var type = (TypeReference) ins.Operand;
-
-				if (type.FullName != "System.Type")
+				if (!(ins.Operand as TypeReference).IsNamed ("System", "Type"))
 					continue;
 
 				if (ins.Previous.IsOperandZero ())
diff --git a/gendarme/rules/Gendarme.Rules.Portability/DoNotHardcodePathsRule.cs b/gendarme/rules/Gendarme.Rules.Portability/DoNotHardcodePathsRule.cs
index 009ebba..92b597a 100644
--- a/gendarme/rules/Gendarme.Rules.Portability/DoNotHardcodePathsRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Portability/DoNotHardcodePathsRule.cs
@@ -28,6 +28,7 @@
 
 using System;
 using System.Collections.Generic;
+using System.Globalization;
 
 using Mono.Cecil;
 using Mono.Cecil.Cil;
@@ -363,11 +364,13 @@ namespace Gendarme.Rules.Portability {
 
 				// we can avoid some false positives by doing additional checks here
 
+				TypeReference tr = target.DeclaringType;
+				string nameSpace = tr.Namespace;
+				string typeName = tr.Name;
 				string methodName = target.Name;
-				string typeName = target.DeclaringType.FullName;
 
-				if (typeName.StartsWith ("Microsoft.Win32.Registry", StringComparison.Ordinal) // registry keys
-				    || (typeName.StartsWith ("System.Xml", StringComparison.Ordinal) // xpath expressions
+				if (nameSpace == "Microsoft.Win32" && typeName.StartsWith ("Registry", StringComparison.Ordinal) // registry keys
+				    || (nameSpace.StartsWith ("System.Xml", StringComparison.Ordinal) // xpath expressions
 					&& methodName.StartsWith ("Select", StringComparison.Ordinal))) {
 					AddPoints (-42);
 					return true; // handled
@@ -389,10 +392,8 @@ namespace Gendarme.Rules.Portability {
 			case Code.Newobj:
 				// this is a constructor call
 				MethodReference ctor = (MethodReference) ins.Operand;
-				string createdTypeName = ctor.DeclaringType.FullName;
-
 				// avoid catching regular expressions
-				if (createdTypeName == "System.Text.RegularExpressions.Regex")
+				if (ctor.DeclaringType.IsNamed ("System.Text.RegularExpressions", "Regex"))
 					AddPoints (-42);
 
 				break;
@@ -494,7 +495,8 @@ namespace Gendarme.Rules.Portability {
 				// if sure enough, report the problem with the candidate string
 				// important as this allows a quick false positive check without checking the source code
 				if (conf.HasValue) {
-					string msg = String.Format ("string \"{0}\" looks quite like a filename.", candidate);
+					string msg = String.Format (CultureInfo.InvariantCulture,
+						"string \"{0}\" looks quite like a filename.", candidate);
 					Runner.Report (method, ins, Severity.High, conf.Value, msg);
 				}
 			}
diff --git a/gendarme/rules/Gendarme.Rules.Portability/ExitCodeIsLimitedOnUnixRule.cs b/gendarme/rules/Gendarme.Rules.Portability/ExitCodeIsLimitedOnUnixRule.cs
index 29c63cd..5259d1d 100644
--- a/gendarme/rules/Gendarme.Rules.Portability/ExitCodeIsLimitedOnUnixRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Portability/ExitCodeIsLimitedOnUnixRule.cs
@@ -107,7 +107,9 @@ namespace Gendarme.Rules.Portability {
 			// but we want to avoid checking all methods if the Environment type
 			// isn't referenced in a module (big performance difference)
 			Runner.AnalyzeModule += delegate (object o, RunnerEventArgs e) {
-				Active = e.CurrentAssembly.MainModule.HasTypeReference ("System.Environment");
+				Active = e.CurrentModule.AnyTypeReference ((TypeReference tr) => {
+					return tr.IsNamed ("System", "Environment");
+				});
 			};
 		}
 
@@ -141,7 +143,7 @@ namespace Gendarme.Rules.Portability {
 			// FIXME: entryPoint.ReturnType should not be null with void Main ()
 			// either bad unit tests or bug in cecil
 			TypeReference rt = entry_point.ReturnType;
-			if (rt == null || rt.FullName != "System.Int32")
+			if (!rt.IsNamed ("System", "Int32"))
 				return RuleResult.DoesNotApply;
 
 			Instruction previous = null;
@@ -188,7 +190,7 @@ namespace Gendarme.Rules.Portability {
 				return (a >= 0 && a <= 255) ? InspectionResult.Good : InspectionResult.Bad;
 			case Code.Call:
 			case Code.Callvirt:
-				if ((instruction.Operand as MethodReference).ReturnType.FullName == "System.Byte")
+				if ((instruction.Operand as MethodReference).ReturnType.IsNamed ("System", "Byte"))
 					return InspectionResult.Good;
 				else
 					return InspectionResult.Unsure; // could be within 0-255 or not
@@ -217,7 +219,7 @@ namespace Gendarme.Rules.Portability {
 					string name = calledMethod.Name;
 					if ((name != "set_ExitCode") && (name != "Exit"))
 						break;
-					if (calledMethod.DeclaringType.FullName != "System.Environment")
+					if (!calledMethod.DeclaringType.IsNamed ("System", "Environment"))
 						break;
 
 					InspectionResult result = CheckInstruction (previous);
diff --git a/gendarme/rules/Gendarme.Rules.Portability/FeatureRequiresRootPrivilegeOnUnixRule.cs b/gendarme/rules/Gendarme.Rules.Portability/FeatureRequiresRootPrivilegeOnUnixRule.cs
index 8de2f25..daeaf2c 100644
--- a/gendarme/rules/Gendarme.Rules.Portability/FeatureRequiresRootPrivilegeOnUnixRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Portability/FeatureRequiresRootPrivilegeOnUnixRule.cs
@@ -84,10 +84,6 @@ namespace Gendarme.Rules.Portability {
 		private const string ProcessMessage = "Setting Process.PriorityClass to something else than ProcessPriorityClass.Normal requires root privileges.";
 		private const string PingMessage = "Usage of System.Net.NetworkInformation.Ping requires root privileges.";
 
-		// non-localizable
-		private const string Ping = "System.Net.NetworkInformation.Ping";
-		private const string Process = "System.Diagnostics.Process";
-
 		private bool ping_present = true;
 		private bool process_present = true;
 
@@ -98,8 +94,13 @@ namespace Gendarme.Rules.Portability {
 			// if the module does not reference either Ping or Process
 			// then it's not being used inside it
 			Runner.AnalyzeModule += delegate (object o, RunnerEventArgs e) {
-				ping_present = e.CurrentModule.HasTypeReference (Ping);
-				process_present = e.CurrentModule.HasTypeReference (Process);
+				Active = e.CurrentModule.AnyTypeReference ((TypeReference tr) => {
+					ping_present = tr.IsNamed ("System.Net.NetworkInformation", "Ping");
+					process_present = tr.IsNamed ("System.Diagnostics", "Process");
+					// return true to stop looping when both Ping and Process are found
+					return (ping_present && process_present);
+				});
+				// activate the rule if any (or both) is/are present(s)
 				Active = (ping_present || process_present);
 			};
 			// note: this ignores on purpose System.dll since there's
@@ -112,7 +113,7 @@ namespace Gendarme.Rules.Portability {
 			MethodReference method = (ins.Operand as MethodReference);
 			if ((method == null) || (method.Name != "set_PriorityClass"))
 				return false;
-			if (method.DeclaringType.FullName != "System.Diagnostics.Process")
+			if (!method.DeclaringType.IsNamed ("System.Diagnostics", "Process"))
 				return false;
 
 			Instruction prev = ins.Previous; //check stack
@@ -132,7 +133,7 @@ namespace Gendarme.Rules.Portability {
 		private static bool CheckPing (Instruction ins)
 		{
 			MethodReference method = (ins.Operand as MethodReference);
-			return ((method != null) && (method.DeclaringType.FullName == Ping));
+			return ((method != null) && (method.DeclaringType.IsNamed ("System.Net.NetworkInformation", "Ping")));
 		}
 
 		public RuleResult CheckMethod (MethodDefinition method)
diff --git a/gendarme/rules/Gendarme.Rules.Portability/Gendarme.Rules.Portability.csproj b/gendarme/rules/Gendarme.Rules.Portability/Gendarme.Rules.Portability.csproj
index 1528411..283e5d5 100755
--- a/gendarme/rules/Gendarme.Rules.Portability/Gendarme.Rules.Portability.csproj
+++ b/gendarme/rules/Gendarme.Rules.Portability/Gendarme.Rules.Portability.csproj
@@ -1,5 +1,5 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
-<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="3.5">
+<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="4.0">
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
     <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
@@ -12,9 +12,11 @@
     <AssemblyName>Gendarme.Rules.Portability</AssemblyName>
     <FileUpgradeFlags>
     </FileUpgradeFlags>
-    <OldToolsVersion>2.0</OldToolsVersion>
+    <OldToolsVersion>3.5</OldToolsVersion>
     <UpgradeBackupLocation>
     </UpgradeBackupLocation>
+    <IsWebBootstrapper>true</IsWebBootstrapper>
+    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
     <PublishUrl>http://localhost/Gendarme.Rules.Portability/</PublishUrl>
     <Install>true</Install>
     <InstallFrom>Web</InstallFrom>
@@ -27,10 +29,9 @@
     <MapFileExtensions>true</MapFileExtensions>
     <ApplicationRevision>0</ApplicationRevision>
     <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
-    <IsWebBootstrapper>true</IsWebBootstrapper>
     <UseApplicationTrust>false</UseApplicationTrust>
     <BootstrapperEnabled>true</BootstrapperEnabled>
-    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <TargetFrameworkProfile />
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
     <DebugSymbols>true</DebugSymbols>
@@ -43,6 +44,7 @@
     <NoWarn>1591</NoWarn>
     <WarningsAsErrors>1570</WarningsAsErrors>
     <DocumentationFile>..\..\console\bin\Debug\Gendarme.Rules.Portability.xml</DocumentationFile>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
     <DebugType>pdbonly</DebugType>
@@ -54,6 +56,7 @@
     <NoWarn>1591</NoWarn>
     <WarningsAsErrors>1570</WarningsAsErrors>
     <DocumentationFile>..\..\console\bin\Release\Gendarme.Rules.Portability.xml</DocumentationFile>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <ItemGroup>
     <Reference Include="ICSharpCode.SharpZipLib, Version=2.84.0.0, Culture=neutral, PublicKeyToken=1b03e6acf1164f73, processorArchitecture=MSIL">
@@ -94,14 +97,33 @@
     <None Include="ChangeLog" />
   </ItemGroup>
   <ItemGroup>
+    <BootstrapperPackage Include="Microsoft.Net.Client.3.5">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1 Client Profile</ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
     <BootstrapperPackage Include="Microsoft.Net.Framework.2.0">
       <Visible>False</Visible>
+      <ProductName>
+      </ProductName>
+      <Install>false</Install>
     </BootstrapperPackage>
     <BootstrapperPackage Include="Microsoft.Net.Framework.3.0">
       <Visible>False</Visible>
+      <ProductName>
+      </ProductName>
+      <Install>false</Install>
     </BootstrapperPackage>
     <BootstrapperPackage Include="Microsoft.Net.Framework.3.5">
       <Visible>False</Visible>
+      <ProductName>
+      </ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1</ProductName>
+      <Install>false</Install>
     </BootstrapperPackage>
   </ItemGroup>
   <Import Project="$(MSBuildBinPath)\Microsoft.CSharp.targets" />
diff --git a/gendarme/rules/Gendarme.Rules.Portability/MonoCompatibilityReviewRule.cs b/gendarme/rules/Gendarme.Rules.Portability/MonoCompatibilityReviewRule.cs
index 141323f..e3a5d3b 100644
--- a/gendarme/rules/Gendarme.Rules.Portability/MonoCompatibilityReviewRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Portability/MonoCompatibilityReviewRule.cs
@@ -6,7 +6,7 @@
 //	Sebastien Pouliot  <sebastien@ximian.com>
 //
 //  (C) 2007 Andreas Noever
-// Copyright (C) 2009 Novell, Inc (http://www.novell.com)
+// Copyright (C) 2009, 2011 Novell, Inc (http://www.novell.com)
 //
 // Permission is hereby granted, free of charge, to any person obtaining
 // a copy of this software and associated documentation files (the
@@ -31,6 +31,7 @@
 using System;
 using System.Collections.Generic;
 using System.ComponentModel;
+using System.Globalization;
 using System.IO;
 using System.Net;
 
@@ -40,6 +41,7 @@ using Mono.Cecil.Cil;
 using Gendarme.Framework;
 using Gendarme.Framework.Engines;
 using Gendarme.Framework.Helpers;
+using Gendarme.Framework.Rocks;
 
 using ICSharpCode.SharpZipLib.Zip;
 
@@ -126,7 +128,7 @@ namespace Gendarme.Rules.Portability {
 
 		private string GetFileName (Version v)
 		{
-			return Path.Combine (DefinitionsFolder, String.Format ("definitions-{0}.zip", v));
+			return Path.Combine (DefinitionsFolder, String.Format (CultureInfo.InvariantCulture, "definitions-{0}.zip", v));
 		}
 
 		private Version FindLastestLocalVersion ()
@@ -139,7 +141,7 @@ namespace Gendarme.Rules.Portability {
 
 			try {
 				string latest = def_files [def_files.Length - 1];
-				int s = latest.LastIndexOf ("definitions-") + 12;
+				int s = latest.LastIndexOf ("definitions-", StringComparison.Ordinal) + 12;
 				return new Version (latest.Substring (s, latest.Length - s - 4)); // remove .zip
 			}
 			catch (FormatException) {
@@ -175,7 +177,7 @@ namespace Gendarme.Rules.Portability {
 
 			using (FileStream fs = File.OpenRead (filename)) 
 			using (ZipInputStream zs = new ZipInputStream (fs))
-			using (StreamReader sr = new StreamReader (zs)) {
+			using (StreamLineReader sr = new StreamLineReader (zs)) {
 				ZipEntry ze;
 				while ((ze = zs.GetNextEntry ()) != null) {
 					switch (ze.Name) {
@@ -291,29 +293,28 @@ namespace Gendarme.Rules.Portability {
 			return v;
 		}
 
-		private static Dictionary<string, string> ReadWithComments (TextReader reader)
+		static char [] buffer = new char [4096];
+
+		private static Dictionary<string, string> ReadWithComments (StreamLineReader reader)
 		{
 			Dictionary<string, string> dict = new Dictionary<string, string> ();
-			string line;
-			while ((line = reader.ReadLine ()) != null) {
-				int split = line.IndexOf ('-');
-				string target = line.Substring (0, split);
-				// are there comments ? (many entries don't have any)
-				if (split == line.Length - 1) {
-					dict.Add (target, null);
-				} else {
-					dict.Add (target, line.Substring (split + 1));
-				}
+			while (!reader.EndOfStream) {
+				int length = reader.ReadLine (buffer, 0, buffer.Length);
+				int pos = Array.IndexOf (buffer, '-');
+				string key = new string (buffer, 0, pos);
+				string comment = (buffer [length - 1] == '-') ? null :
+					new string (buffer, pos + 1, length - pos - 1);
+				dict.Add (key, comment);
 			}
 			return dict;
 		}
 
-		private static HashSet<string> Read (TextReader reader)
+		private static HashSet<string> Read (StreamLineReader reader)
 		{
 			HashSet<string> set = new HashSet<string> ();
-			string line;
-			while ((line = reader.ReadLine ()) != null) {
-				set.Add (line);
+			while (!reader.EndOfStream) {
+				int length = reader.ReadLine (buffer, 0, buffer.Length);
+				set.Add (new string (buffer, 0, length));
 			}
 			return set;
 		}
@@ -344,18 +345,18 @@ namespace Gendarme.Rules.Portability {
 					continue;
 
 				// MethodReference.ToString is costly so we do it once for the three checks
-				string callee = mr.ToString ();
+				string callee = mr.GetFullName ();
 
 				// calling not implemented method is very likely not to work == High
 				if ((NotImplemented != null) && NotImplementedInternal.Contains (callee)) {
-					string message = String.Format (NotImplementedMessage, callee);
+					string message = String.Format (CultureInfo.InvariantCulture, NotImplementedMessage, callee);
 					// confidence is Normal since we can't be sure if MoMA data is up to date
 					Runner.Report (method, ins, Severity.High, Confidence.Normal, message);
 				}
 
 				// calling missing methods can't work == Critical
 				if ((Missing != null) && Missing.Contains (callee)) {
-					string message = String.Format (MissingMessage, callee);
+					string message = String.Format (CultureInfo.InvariantCulture, MissingMessage, callee);
 					Runner.Report (method, ins, Severity.Critical, Confidence.Normal, message);
 				}
 
@@ -363,7 +364,7 @@ namespace Gendarme.Rules.Portability {
 				if (ToDo != null) {
 					string value;
 					if (ToDo.TryGetValue (callee, out value)) {
-						string message = String.Format (TodoMessage, callee, value);
+						string message = String.Format (CultureInfo.InvariantCulture, TodoMessage, callee, value);
 						Runner.Report (method, ins,  Severity.Medium, Confidence.Normal, message);
 					}
 				}
diff --git a/gendarme/rules/Gendarme.Rules.Portability/NewLineLiteralRule.cs b/gendarme/rules/Gendarme.Rules.Portability/NewLineLiteralRule.cs
index 40345c9..1e3afa3 100644
--- a/gendarme/rules/Gendarme.Rules.Portability/NewLineLiteralRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Portability/NewLineLiteralRule.cs
@@ -27,6 +27,7 @@
 //
 
 using System;
+using System.Globalization;
 using System.Text;
 
 using Mono.Cecil;
@@ -115,7 +116,7 @@ namespace Gendarme.Rules.Portability {
 				else if (c == '\t')
 					result.Append ("\\t");
 				else
-					result.AppendFormat ("\\x").Append (((short) c).ToString ("x"));
+					result.Append ("\\x").Append (((short) c).ToString ("x", CultureInfo.InvariantCulture));
 			}
 			return result.Append ("\".").ToString ();
 		}
diff --git a/gendarme/rules/Gendarme.Rules.Portability/README.md b/gendarme/rules/Gendarme.Rules.Portability/README.md
new file mode 100644
index 0000000..ffe7609
--- /dev/null
+++ b/gendarme/rules/Gendarme.Rules.Portability/README.md
@@ -0,0 +1,9 @@
+# Gendarme.Rules.Portability Rules
+
+You can access the latest rules documentation from our [[wiki|https://github.com/spouliot/gendarme/wiki/Gendarme.Rules.Portability(git)]] pages.
+
+
+## Feedback
+
+Please report any documentation errors, typos or suggestions to the [[Gendarme Mailing List|https://groups.google.com/forum/?fromgroups#!forum/gendarme]]. Thanks!
+
diff --git a/gendarme/rules/Gendarme.Rules.Portability/Test/Tests.Rules.Portability.csproj b/gendarme/rules/Gendarme.Rules.Portability/Test/Tests.Rules.Portability.csproj
index 0787fd3..fcd8220 100755
--- a/gendarme/rules/Gendarme.Rules.Portability/Test/Tests.Rules.Portability.csproj
+++ b/gendarme/rules/Gendarme.Rules.Portability/Test/Tests.Rules.Portability.csproj
@@ -1,5 +1,5 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
-<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="3.5">
+<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="4.0">
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
     <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
@@ -12,9 +12,11 @@
     <AssemblyName>Tests.Rules.Portability</AssemblyName>
     <FileUpgradeFlags>
     </FileUpgradeFlags>
-    <OldToolsVersion>2.0</OldToolsVersion>
+    <OldToolsVersion>3.5</OldToolsVersion>
     <UpgradeBackupLocation>
     </UpgradeBackupLocation>
+    <IsWebBootstrapper>true</IsWebBootstrapper>
+    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
     <PublishUrl>http://localhost/Tests.Rules.Portability/</PublishUrl>
     <Install>true</Install>
     <InstallFrom>Web</InstallFrom>
@@ -27,10 +29,9 @@
     <MapFileExtensions>true</MapFileExtensions>
     <ApplicationRevision>0</ApplicationRevision>
     <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
-    <IsWebBootstrapper>true</IsWebBootstrapper>
     <UseApplicationTrust>false</UseApplicationTrust>
     <BootstrapperEnabled>true</BootstrapperEnabled>
-    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <TargetFrameworkProfile />
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
     <DebugSymbols>true</DebugSymbols>
@@ -40,6 +41,7 @@
     <DefineConstants>DEBUG;TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
     <DebugType>pdbonly</DebugType>
@@ -48,6 +50,7 @@
     <DefineConstants>TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <ItemGroup>
     <Reference Include="nunit.framework, Version=2.4.8.0, Culture=neutral, PublicKeyToken=96d09a1eb7f44a77, processorArchitecture=MSIL">
@@ -90,14 +93,33 @@
     </ProjectReference>
   </ItemGroup>
   <ItemGroup>
+    <BootstrapperPackage Include="Microsoft.Net.Client.3.5">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1 Client Profile</ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
     <BootstrapperPackage Include="Microsoft.Net.Framework.2.0">
       <Visible>False</Visible>
+      <ProductName>
+      </ProductName>
+      <Install>false</Install>
     </BootstrapperPackage>
     <BootstrapperPackage Include="Microsoft.Net.Framework.3.0">
       <Visible>False</Visible>
+      <ProductName>
+      </ProductName>
+      <Install>false</Install>
     </BootstrapperPackage>
     <BootstrapperPackage Include="Microsoft.Net.Framework.3.5">
       <Visible>False</Visible>
+      <ProductName>
+      </ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1</ProductName>
+      <Install>false</Install>
     </BootstrapperPackage>
   </ItemGroup>
   <Import Project="$(MSBuildBinPath)\Microsoft.CSharp.targets" />
diff --git a/gendarme/rules/Gendarme.Rules.Security.Cas/Gendarme.Rules.Security.Cas.csproj b/gendarme/rules/Gendarme.Rules.Security.Cas/Gendarme.Rules.Security.Cas.csproj
index 436c7cc..91cc467 100644
--- a/gendarme/rules/Gendarme.Rules.Security.Cas/Gendarme.Rules.Security.Cas.csproj
+++ b/gendarme/rules/Gendarme.Rules.Security.Cas/Gendarme.Rules.Security.Cas.csproj
@@ -1,5 +1,5 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
     <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
@@ -10,8 +10,28 @@
     <AppDesignerFolder>Properties</AppDesignerFolder>
     <RootNamespace>Gendarme.Rules.Security.Cas</RootNamespace>
     <AssemblyName>Gendarme.Rules.Security.Cas</AssemblyName>
-    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
     <FileAlignment>512</FileAlignment>
+    <FileUpgradeFlags>
+    </FileUpgradeFlags>
+    <OldToolsVersion>3.5</OldToolsVersion>
+    <UpgradeBackupLocation />
+    <PublishUrl>publish\</PublishUrl>
+    <Install>true</Install>
+    <InstallFrom>Disk</InstallFrom>
+    <UpdateEnabled>false</UpdateEnabled>
+    <UpdateMode>Foreground</UpdateMode>
+    <UpdateInterval>7</UpdateInterval>
+    <UpdateIntervalUnits>Days</UpdateIntervalUnits>
+    <UpdatePeriodically>false</UpdatePeriodically>
+    <UpdateRequired>false</UpdateRequired>
+    <MapFileExtensions>true</MapFileExtensions>
+    <ApplicationRevision>0</ApplicationRevision>
+    <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
+    <IsWebBootstrapper>false</IsWebBootstrapper>
+    <UseApplicationTrust>false</UseApplicationTrust>
+    <BootstrapperEnabled>true</BootstrapperEnabled>
+    <TargetFrameworkProfile />
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
     <DebugSymbols>true</DebugSymbols>
@@ -24,6 +44,7 @@
     <DocumentationFile>..\..\console\bin\Debug\Gendarme.Rules.Security.Cas.xml</DocumentationFile>
     <NoWarn>1591</NoWarn>
     <WarningsAsErrors>1570</WarningsAsErrors>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
     <DebugType>pdbonly</DebugType>
@@ -35,6 +56,7 @@
     <NoWarn>1591</NoWarn>
     <WarningsAsErrors>1570</WarningsAsErrors>
     <DocumentationFile>..\..\console\bin\Release\Gendarme.Rules.Security.Cas.xml</DocumentationFile>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <ItemGroup>
     <Reference Include="System" />
@@ -66,6 +88,23 @@
       <Name>Gendarme.Framework</Name>
     </ProjectReference>
   </ItemGroup>
+  <ItemGroup>
+    <BootstrapperPackage Include="Microsoft.Net.Client.3.5">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1 Client Profile</ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Windows.Installer.3.1">
+      <Visible>False</Visible>
+      <ProductName>Windows Installer 3.1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+  </ItemGroup>
   <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
   <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
        Other similar extension points exist, see Microsoft.Common.targets.
diff --git a/gendarme/rules/Gendarme.Rules.Security.Cas/README.md b/gendarme/rules/Gendarme.Rules.Security.Cas/README.md
new file mode 100644
index 0000000..7fb8880
--- /dev/null
+++ b/gendarme/rules/Gendarme.Rules.Security.Cas/README.md
@@ -0,0 +1,9 @@
+# Gendarme.Rules.Security.Cas Rules
+
+You can access the latest rules documentation from our [[wiki|https://github.com/spouliot/gendarme/wiki/Gendarme.Rules.Security.Cas(git)]] pages.
+
+
+## Feedback
+
+Please report any documentation errors, typos or suggestions to the [[Gendarme Mailing List|https://groups.google.com/forum/?fromgroups#!forum/gendarme]]. Thanks!
+
diff --git a/gendarme/rules/Gendarme.Rules.Security.Cas/ReviewSuppressUnmanagedCodeSecurityUsageRule.cs b/gendarme/rules/Gendarme.Rules.Security.Cas/ReviewSuppressUnmanagedCodeSecurityUsageRule.cs
index 8f0d3de..fc03231 100644
--- a/gendarme/rules/Gendarme.Rules.Security.Cas/ReviewSuppressUnmanagedCodeSecurityUsageRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Security.Cas/ReviewSuppressUnmanagedCodeSecurityUsageRule.cs
@@ -56,8 +56,6 @@ namespace Gendarme.Rules.Security.Cas {
 	[FxCopCompatibility ("Microsoft.Security", "CA2118:ReviewSuppressUnmanagedCodeSecurityUsage")]
 	public class ReviewSuppressUnmanagedCodeSecurityUsageRule : Rule, ITypeRule, IMethodRule {
 
-		private const string SUCS = "System.Security.SuppressUnmanagedCodeSecurityAttribute";
-
 		public override void Initialize (IRunner runner)
 		{
 			base.Initialize (runner);
@@ -65,8 +63,10 @@ namespace Gendarme.Rules.Security.Cas {
 			// if the module does not reference [SuppressUnmanagedCodeSecurityAttribute]
 			// then it's not being used inside it
 			Runner.AnalyzeModule += delegate (object o, RunnerEventArgs e) {
-				Active = (e.CurrentAssembly.Name.Name == "mscorlib"
-					|| e.CurrentModule.HasTypeReference (SUCS));
+				Active = (e.CurrentAssembly.Name.Name == "mscorlib" ||
+					e.CurrentModule.AnyTypeReference ((TypeReference tr) => {
+						return tr.IsNamed ("System.Security", "SuppressUnmanagedCodeSecurityAttribute");
+					}));
 			};
 		}
 
@@ -78,7 +78,7 @@ namespace Gendarme.Rules.Security.Cas {
 			if (type.IsEnum)
 				return RuleResult.DoesNotApply;
 
-			if (!type.HasAttribute (SUCS))
+			if (!type.HasAttribute ("System.Security", "SuppressUnmanagedCodeSecurityAttribute"))
 				return RuleResult.Success;
 
 			Runner.Report (type, Severity.Audit, Confidence.Total);
@@ -87,7 +87,7 @@ namespace Gendarme.Rules.Security.Cas {
 
 		public RuleResult CheckMethod (MethodDefinition method)
 		{
-			if (!method.HasAttribute (SUCS))
+			if (!method.HasAttribute ("System.Security", "SuppressUnmanagedCodeSecurityAttribute"))
 				return RuleResult.Success;
 
 			Runner.Report (method, Severity.Audit, Confidence.Total);
diff --git a/gendarme/rules/Gendarme.Rules.Security.Cas/SecureGetObjectDataOverridesRule.cs b/gendarme/rules/Gendarme.Rules.Security.Cas/SecureGetObjectDataOverridesRule.cs
index 481e95e..79831bd 100644
--- a/gendarme/rules/Gendarme.Rules.Security.Cas/SecureGetObjectDataOverridesRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Security.Cas/SecureGetObjectDataOverridesRule.cs
@@ -27,6 +27,7 @@
 //
 
 using System;
+using System.Globalization;
 using System.Security;
 using System.Security.Permissions;
 
@@ -87,7 +88,7 @@ namespace Gendarme.Rules.Security.Cas {
 		public RuleResult CheckType (TypeDefinition type)
 		{
 			// rule applies only to types that implements ISerializable
-			if (!type.Implements ("System.Runtime.Serialization.ISerializable"))
+			if (!type.Implements ("System.Runtime.Serialization", "ISerializable"))
 				return RuleResult.DoesNotApply;
 
 			MethodDefinition method = type.GetMethod (MethodSignatures.GetObjectData);
@@ -112,7 +113,8 @@ namespace Gendarme.Rules.Security.Cas {
 				case Mono.Cecil.SecurityAction.NonCasLinkDemand:
 					demand = true;
 					if (!RuleSet.IsSubsetOf (declsec.ToPermissionSet ())) {
-						string message = String.Format ("{0} is not a subset of {1} permission set",
+						string message = String.Format (CultureInfo.InvariantCulture,
+							"{0} is not a subset of {1} permission set",
 							"SerializationFormatter", declsec.Action);
 						Runner.Report (method, Severity.High, Confidence.Total, message);
 					}
diff --git a/gendarme/rules/Gendarme.Rules.Security.Cas/SecurityDeclarationRocks.cs b/gendarme/rules/Gendarme.Rules.Security.Cas/SecurityDeclarationRocks.cs
index ee136e9..ba56671 100644
--- a/gendarme/rules/Gendarme.Rules.Security.Cas/SecurityDeclarationRocks.cs
+++ b/gendarme/rules/Gendarme.Rules.Security.Cas/SecurityDeclarationRocks.cs
@@ -31,6 +31,7 @@ using System.Security;
 using SSP = System.Security.Permissions;
 
 using Mono.Cecil;
+using Gendarme.Framework.Rocks;
 
 namespace Gendarme.Rules.Security.Cas {
 
diff --git a/gendarme/rules/Gendarme.Rules.Security.Cas/Test/Tests.Rules.Security.Cas.csproj b/gendarme/rules/Gendarme.Rules.Security.Cas/Test/Tests.Rules.Security.Cas.csproj
index b9cd34a..8d2eec5 100644
--- a/gendarme/rules/Gendarme.Rules.Security.Cas/Test/Tests.Rules.Security.Cas.csproj
+++ b/gendarme/rules/Gendarme.Rules.Security.Cas/Test/Tests.Rules.Security.Cas.csproj
@@ -1,5 +1,5 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
     <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
@@ -10,8 +10,28 @@
     <AppDesignerFolder>Properties</AppDesignerFolder>
     <RootNamespace>Tests.Rules.Security.Cas</RootNamespace>
     <AssemblyName>Tests.Rules.Security.Cas</AssemblyName>
-    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
     <FileAlignment>512</FileAlignment>
+    <FileUpgradeFlags>
+    </FileUpgradeFlags>
+    <OldToolsVersion>3.5</OldToolsVersion>
+    <UpgradeBackupLocation />
+    <PublishUrl>publish\</PublishUrl>
+    <Install>true</Install>
+    <InstallFrom>Disk</InstallFrom>
+    <UpdateEnabled>false</UpdateEnabled>
+    <UpdateMode>Foreground</UpdateMode>
+    <UpdateInterval>7</UpdateInterval>
+    <UpdateIntervalUnits>Days</UpdateIntervalUnits>
+    <UpdatePeriodically>false</UpdatePeriodically>
+    <UpdateRequired>false</UpdateRequired>
+    <MapFileExtensions>true</MapFileExtensions>
+    <ApplicationRevision>0</ApplicationRevision>
+    <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
+    <IsWebBootstrapper>false</IsWebBootstrapper>
+    <UseApplicationTrust>false</UseApplicationTrust>
+    <BootstrapperEnabled>true</BootstrapperEnabled>
+    <TargetFrameworkProfile />
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
     <DebugSymbols>true</DebugSymbols>
@@ -21,6 +41,7 @@
     <DefineConstants>DEBUG;TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
     <DebugType>pdbonly</DebugType>
@@ -29,6 +50,7 @@
     <DefineConstants>TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <ItemGroup>
     <Reference Include="nunit.framework, Version=2.4.8.0, Culture=neutral, PublicKeyToken=96d09a1eb7f44a77, processorArchitecture=MSIL">
@@ -72,6 +94,23 @@
   <ItemGroup>
     <Folder Include="Properties\" />
   </ItemGroup>
+  <ItemGroup>
+    <BootstrapperPackage Include="Microsoft.Net.Client.3.5">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1 Client Profile</ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Windows.Installer.3.1">
+      <Visible>False</Visible>
+      <ProductName>Windows Installer 3.1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+  </ItemGroup>
   <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
   <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
        Other similar extension points exist, see Microsoft.Common.targets.
diff --git a/gendarme/rules/Gendarme.Rules.Security/DoNotShortCircuitCertificateCheckRule.cs b/gendarme/rules/Gendarme.Rules.Security/DoNotShortCircuitCertificateCheckRule.cs
index 31f51cf..3323b85 100644
--- a/gendarme/rules/Gendarme.Rules.Security/DoNotShortCircuitCertificateCheckRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Security/DoNotShortCircuitCertificateCheckRule.cs
@@ -122,8 +122,11 @@ namespace Gendarme.Rules.Security {
 			// if the module does not reference System.Math then 
 			// none of its method is being called with constants
 			Runner.AnalyzeModule += delegate (object o, RunnerEventArgs e) {
-				Active = (e.CurrentAssembly.Name.Name == "mscorlib") ||
-					e.CurrentModule.HasTypeReference ("System.Net.ICertificatePolicy");
+				Active = (e.CurrentAssembly.Name.Name == "mscorlib" ||
+					e.CurrentModule.AnyTypeReference ((TypeReference tr) => {
+						return tr.IsNamed ("System.Net", "ICertificatePolicy");
+					})
+				);
 			};
 		}
 
@@ -138,11 +141,11 @@ namespace Gendarme.Rules.Security {
 						if (pd == null)
 							continue;
 
-						switch (pd.GetSequence ()) {
-						case 2:
-						case 4:
-							return RuleResult.Success;
+						switch (pd.Index) {
+						case 1:
 						case 3:
+							return RuleResult.Success;
+						case 2:
 							if (third)
 								return RuleResult.Success;
 							break;
@@ -160,7 +163,7 @@ namespace Gendarme.Rules.Security {
 			// since ICertificatePolicy is an interface we need to check its name
 			string name = method.Name;
 			if (name == "CheckValidationResult") {
-				if (!method.DeclaringType.Implements ("System.Net.ICertificatePolicy"))
+				if (!method.DeclaringType.Implements ("System.Net", "ICertificatePolicy"))
 					return RuleResult.Success;
 			} else if (name != "System.Net.ICertificatePolicy.CheckValidationResult")
 				return RuleResult.Success;
@@ -187,7 +190,7 @@ namespace Gendarme.Rules.Security {
 
 			IList<ParameterDefinition> pdc = method.Parameters;
 			int count = pdc.Count;
-			if ((count != 4) || (method.ReturnType.FullName != "System.Boolean"))
+			if ((count != 4) || !method.ReturnType.IsNamed ("System", "Boolean"))
 				return RuleResult.DoesNotApply;
 
 			// this method could be a candidate for both policy or callback
@@ -195,10 +198,10 @@ namespace Gendarme.Rules.Security {
 			bool callback = true;
 			// if all the parameters match
 			for (int i = 0; i < count; i++) {
-				string name = pdc [i].ParameterType.FullName;
-				if (policy && (name != CertificatePolicyParameters [i]))
+				TypeReference ptype = pdc [i].ParameterType;
+				if (policy && !ptype.IsNamed (CertificatePolicyParameters [i]))
 					policy = false;
-				if (callback && (name != RemoteCertificateValidationParameters [i]))
+				if (callback && !ptype.IsNamed (RemoteCertificateValidationParameters [i]))
 					callback = false;
 			}
 
diff --git a/gendarme/rules/Gendarme.Rules.Security/Gendarme.Rules.Security.csproj b/gendarme/rules/Gendarme.Rules.Security/Gendarme.Rules.Security.csproj
index 7cec633..62fc565 100755
--- a/gendarme/rules/Gendarme.Rules.Security/Gendarme.Rules.Security.csproj
+++ b/gendarme/rules/Gendarme.Rules.Security/Gendarme.Rules.Security.csproj
@@ -1,5 +1,5 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
-<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="3.5">
+<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="4.0">
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
     <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
@@ -12,9 +12,11 @@
     <AssemblyName>Gendarme.Rules.Security</AssemblyName>
     <FileUpgradeFlags>
     </FileUpgradeFlags>
-    <OldToolsVersion>2.0</OldToolsVersion>
+    <OldToolsVersion>3.5</OldToolsVersion>
     <UpgradeBackupLocation>
     </UpgradeBackupLocation>
+    <IsWebBootstrapper>true</IsWebBootstrapper>
+    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
     <PublishUrl>http://localhost/Gendarme.Rules.Security/</PublishUrl>
     <Install>true</Install>
     <InstallFrom>Web</InstallFrom>
@@ -27,10 +29,9 @@
     <MapFileExtensions>true</MapFileExtensions>
     <ApplicationRevision>0</ApplicationRevision>
     <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
-    <IsWebBootstrapper>true</IsWebBootstrapper>
     <UseApplicationTrust>false</UseApplicationTrust>
     <BootstrapperEnabled>true</BootstrapperEnabled>
-    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <TargetFrameworkProfile />
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
     <DebugSymbols>true</DebugSymbols>
@@ -43,6 +44,7 @@
     <DocumentationFile>..\..\console\bin\Debug\Gendarme.Rules.Security.xml</DocumentationFile>
     <NoWarn>1591</NoWarn>
     <WarningsAsErrors>1570</WarningsAsErrors>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
     <DebugType>pdbonly</DebugType>
@@ -54,6 +56,7 @@
     <NoWarn>1591</NoWarn>
     <WarningsAsErrors>1570</WarningsAsErrors>
     <DocumentationFile>..\..\console\bin\Release\Gendarme.Rules.Security.xml</DocumentationFile>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <ItemGroup>
     <Reference Include="System" />
@@ -84,14 +87,33 @@
     <None Include="ChangeLog" />
   </ItemGroup>
   <ItemGroup>
+    <BootstrapperPackage Include="Microsoft.Net.Client.3.5">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1 Client Profile</ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
     <BootstrapperPackage Include="Microsoft.Net.Framework.2.0">
       <Visible>False</Visible>
+      <ProductName>
+      </ProductName>
+      <Install>false</Install>
     </BootstrapperPackage>
     <BootstrapperPackage Include="Microsoft.Net.Framework.3.0">
       <Visible>False</Visible>
+      <ProductName>
+      </ProductName>
+      <Install>false</Install>
     </BootstrapperPackage>
     <BootstrapperPackage Include="Microsoft.Net.Framework.3.5">
       <Visible>False</Visible>
+      <ProductName>
+      </ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1</ProductName>
+      <Install>false</Install>
     </BootstrapperPackage>
   </ItemGroup>
   <Import Project="$(MSBuildBinPath)\Microsoft.CSharp.targets" />
diff --git a/gendarme/rules/Gendarme.Rules.Security/README.md b/gendarme/rules/Gendarme.Rules.Security/README.md
new file mode 100644
index 0000000..d0b7430
--- /dev/null
+++ b/gendarme/rules/Gendarme.Rules.Security/README.md
@@ -0,0 +1,9 @@
+# Gendarme.Rules.Security Rules
+
+You can access the latest rules documentation from our [[wiki|https://github.com/spouliot/gendarme/wiki/Gendarme.Rules.Security(git)]] pages.
+
+
+## Feedback
+
+Please report any documentation errors, typos or suggestions to the [[Gendarme Mailing List|https://groups.google.com/forum/?fromgroups#!forum/gendarme]]. Thanks!
+
diff --git a/gendarme/rules/Gendarme.Rules.Security/Test/Tests.Rules.Security.csproj b/gendarme/rules/Gendarme.Rules.Security/Test/Tests.Rules.Security.csproj
index ce04b1c..2568557 100755
--- a/gendarme/rules/Gendarme.Rules.Security/Test/Tests.Rules.Security.csproj
+++ b/gendarme/rules/Gendarme.Rules.Security/Test/Tests.Rules.Security.csproj
@@ -1,5 +1,5 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
-<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="3.5">
+<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="4.0">
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
     <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
@@ -12,9 +12,11 @@
     <AssemblyName>Tests.Rules.Security</AssemblyName>
     <FileUpgradeFlags>
     </FileUpgradeFlags>
-    <OldToolsVersion>2.0</OldToolsVersion>
+    <OldToolsVersion>3.5</OldToolsVersion>
     <UpgradeBackupLocation>
     </UpgradeBackupLocation>
+    <IsWebBootstrapper>true</IsWebBootstrapper>
+    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
     <PublishUrl>http://localhost/Tests.Rules.Security/</PublishUrl>
     <Install>true</Install>
     <InstallFrom>Web</InstallFrom>
@@ -27,10 +29,9 @@
     <MapFileExtensions>true</MapFileExtensions>
     <ApplicationRevision>0</ApplicationRevision>
     <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
-    <IsWebBootstrapper>true</IsWebBootstrapper>
     <UseApplicationTrust>false</UseApplicationTrust>
     <BootstrapperEnabled>true</BootstrapperEnabled>
-    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <TargetFrameworkProfile />
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
     <DebugSymbols>true</DebugSymbols>
@@ -40,6 +41,7 @@
     <DefineConstants>DEBUG;TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
     <DebugType>pdbonly</DebugType>
@@ -48,6 +50,7 @@
     <DefineConstants>TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <ItemGroup>
     <Reference Include="nunit.framework, Version=2.4.8.0, Culture=neutral, PublicKeyToken=96d09a1eb7f44a77, processorArchitecture=MSIL">
@@ -86,14 +89,33 @@
     </ProjectReference>
   </ItemGroup>
   <ItemGroup>
+    <BootstrapperPackage Include="Microsoft.Net.Client.3.5">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1 Client Profile</ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
     <BootstrapperPackage Include="Microsoft.Net.Framework.2.0">
       <Visible>False</Visible>
+      <ProductName>
+      </ProductName>
+      <Install>false</Install>
     </BootstrapperPackage>
     <BootstrapperPackage Include="Microsoft.Net.Framework.3.0">
       <Visible>False</Visible>
+      <ProductName>
+      </ProductName>
+      <Install>false</Install>
     </BootstrapperPackage>
     <BootstrapperPackage Include="Microsoft.Net.Framework.3.5">
       <Visible>False</Visible>
+      <ProductName>
+      </ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1</ProductName>
+      <Install>false</Install>
     </BootstrapperPackage>
   </ItemGroup>
   <Import Project="$(MSBuildBinPath)\Microsoft.CSharp.targets" />
diff --git a/gendarme/rules/Gendarme.Rules.Serialization/CallBaseMethodsOnISerializableTypesRule.cs b/gendarme/rules/Gendarme.Rules.Serialization/CallBaseMethodsOnISerializableTypesRule.cs
index 640b093..bd7eb7c 100644
--- a/gendarme/rules/Gendarme.Rules.Serialization/CallBaseMethodsOnISerializableTypesRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Serialization/CallBaseMethodsOnISerializableTypesRule.cs
@@ -102,9 +102,9 @@ namespace Gendarme.Rules.Serialization {
 		private static bool InheritsFromISerializableImplementation (TypeDefinition type)
 		{
 			TypeDefinition current = type.BaseType != null ? type.BaseType.Resolve () : null;
-			if (current == null || current.FullName == "System.Object")
+			if (current == null || current.IsNamed ("System", "Object"))
 				return false;
-			if (current.IsSerializable && current.Implements ("System.Runtime.Serialization.ISerializable"))
+			if (current.IsSerializable && current.Implements ("System.Runtime.Serialization", "ISerializable"))
 				return true;
 
 			return InheritsFromISerializableImplementation (current);
@@ -124,7 +124,8 @@ namespace Gendarme.Rules.Serialization {
 						continue;
 
 					MethodReference operand = (MethodReference) instruction.Operand;
-					if (methodSignature.Matches (operand) && type.Inherits (operand.DeclaringType.FullName))
+					TypeReference tr = operand.DeclaringType;
+					if (methodSignature.Matches (operand) && type.Inherits (tr.Namespace, tr.Name))
 						return;
 				}
 			}
diff --git a/gendarme/rules/Gendarme.Rules.Serialization/DeserializeOptionalFieldRule.cs b/gendarme/rules/Gendarme.Rules.Serialization/DeserializeOptionalFieldRule.cs
index 217384b..5fdbd75 100644
--- a/gendarme/rules/Gendarme.Rules.Serialization/DeserializeOptionalFieldRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Serialization/DeserializeOptionalFieldRule.cs
@@ -26,6 +26,7 @@
 
 using System;
 using System.Collections.Generic;
+using System.Globalization;
 
 using Mono.Cecil;
 
@@ -85,10 +86,6 @@ namespace Gendarme.Rules.Serialization {
 		private const string MessageOptional = "Optional fields '{0}' is not deserialized.";
 		private const string MessageSerializable = "Optional fields '{0}' in non-serializable type.";
 
-		private const string OptionalFieldAttribute = "System.Runtime.Serialization.OptionalFieldAttribute";
-		private const string OnDeserializedAttribute = "System.Runtime.Serialization.OnDeserializedAttribute";
-		private const string OnDeserializingAttribute = "System.Runtime.Serialization.OnDeserializingAttribute";
-
 		public override void Initialize (IRunner runner)
 		{
 			base.Initialize (runner);
@@ -103,7 +100,10 @@ namespace Gendarme.Rules.Serialization {
 					// if the module does not have a reference to System.Runtime.Serialization.OptionalFieldAttribute
 					// then nothing will be reported by this rule
 					(e.CurrentAssembly.Name.Name == "mscorlib" ||
-					e.CurrentModule.HasTypeReference (OptionalFieldAttribute));
+					e.CurrentModule.AnyTypeReference ((TypeReference tr) => {
+						return tr.IsNamed ("System.Runtime.Serialization", "OptionalFieldAttribute");
+					})
+				);
 			};
 		}
 
@@ -121,9 +121,9 @@ namespace Gendarme.Rules.Serialization {
 					if (method.IsConstructor || !method.HasCustomAttributes)
 						continue;
 
-					if (method.HasAttribute (OnDeserializedAttribute))
+					if (method.HasAttribute ("System.Runtime.Serialization", "OnDeserializedAttribute"))
 						deserialized_candidate = true;
-					if (method.HasAttribute (OnDeserializingAttribute))
+					if (method.HasAttribute ("System.Runtime.Serialization", "OnDeserializingAttribute"))
 						deserializing_candidate = true;
 
 					if (deserialized_candidate && deserializing_candidate)
@@ -133,19 +133,17 @@ namespace Gendarme.Rules.Serialization {
 
 			// check if we found some optional fields, if none then it's all ok
 			foreach (FieldDefinition field in type.Fields) {
-				if (!field.HasCustomAttributes)
-					continue;
-				if (field.CustomAttributes.ContainsType (OptionalFieldAttribute)) {
+				if (field.HasAttribute ("System.Runtime.Serialization", "OptionalFieldAttribute")) {
 					if (type.IsSerializable) {
 						// report if we didn't find a deserialization method
 						if (!deserialized_candidate || !deserializing_candidate) {
 							// Medium since it's possible that the optional fields don't need to be re-computed
-							string s = String.Format (MessageOptional, field.Name);
+							string s = String.Format (CultureInfo.InvariantCulture, MessageOptional, field.Name);
 							Runner.Report (field, Severity.Medium, Confidence.High, s);
 						}
 					} else {
 						// [OptionalField] without [Serializable] is a bigger problem
-						string s = String.Format (MessageSerializable, field.Name);
+						string s = String.Format (CultureInfo.InvariantCulture, MessageSerializable, field.Name);
 						Runner.Report (field, Severity.Critical, Confidence.High, s);
 					}
 				}
diff --git a/gendarme/rules/Gendarme.Rules.Serialization/Gendarme.Rules.Serialization.csproj b/gendarme/rules/Gendarme.Rules.Serialization/Gendarme.Rules.Serialization.csproj
index 06d1196..c8a0661 100755
--- a/gendarme/rules/Gendarme.Rules.Serialization/Gendarme.Rules.Serialization.csproj
+++ b/gendarme/rules/Gendarme.Rules.Serialization/Gendarme.Rules.Serialization.csproj
@@ -1,5 +1,5 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
     <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
@@ -10,8 +10,28 @@
     <AppDesignerFolder>Properties</AppDesignerFolder>
     <RootNamespace>Gendarme.Rules.Serialization</RootNamespace>
     <AssemblyName>Gendarme.Rules.Serialization</AssemblyName>
-    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
     <FileAlignment>512</FileAlignment>
+    <FileUpgradeFlags>
+    </FileUpgradeFlags>
+    <OldToolsVersion>3.5</OldToolsVersion>
+    <UpgradeBackupLocation />
+    <PublishUrl>publish\</PublishUrl>
+    <Install>true</Install>
+    <InstallFrom>Disk</InstallFrom>
+    <UpdateEnabled>false</UpdateEnabled>
+    <UpdateMode>Foreground</UpdateMode>
+    <UpdateInterval>7</UpdateInterval>
+    <UpdateIntervalUnits>Days</UpdateIntervalUnits>
+    <UpdatePeriodically>false</UpdatePeriodically>
+    <UpdateRequired>false</UpdateRequired>
+    <MapFileExtensions>true</MapFileExtensions>
+    <ApplicationRevision>0</ApplicationRevision>
+    <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
+    <IsWebBootstrapper>false</IsWebBootstrapper>
+    <UseApplicationTrust>false</UseApplicationTrust>
+    <BootstrapperEnabled>true</BootstrapperEnabled>
+    <TargetFrameworkProfile />
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
     <DebugSymbols>true</DebugSymbols>
@@ -24,6 +44,7 @@
     <NoWarn>1591</NoWarn>
     <WarningsAsErrors>1570</WarningsAsErrors>
     <DocumentationFile>..\..\console\bin\Debug\Gendarme.Rules.Serialization.xml</DocumentationFile>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
     <DebugType>pdbonly</DebugType>
@@ -35,6 +56,7 @@
     <NoWarn>1591</NoWarn>
     <WarningsAsErrors>1570</WarningsAsErrors>
     <DocumentationFile>..\..\console\bin\Release\Gendarme.Rules.Serialization.xml</DocumentationFile>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <ItemGroup>
     <Reference Include="System" />
@@ -65,6 +87,23 @@
       <Name>Gendarme.Framework</Name>
     </ProjectReference>
   </ItemGroup>
+  <ItemGroup>
+    <BootstrapperPackage Include="Microsoft.Net.Client.3.5">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1 Client Profile</ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Windows.Installer.3.1">
+      <Visible>False</Visible>
+      <ProductName>Windows Installer 3.1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+  </ItemGroup>
   <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
   <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
        Other similar extension points exist, see Microsoft.Common.targets.
diff --git a/gendarme/rules/Gendarme.Rules.Serialization/ImplementISerializableCorrectlyRule.cs b/gendarme/rules/Gendarme.Rules.Serialization/ImplementISerializableCorrectlyRule.cs
index 553853b..2059795 100644
--- a/gendarme/rules/Gendarme.Rules.Serialization/ImplementISerializableCorrectlyRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Serialization/ImplementISerializableCorrectlyRule.cs
@@ -122,12 +122,12 @@ namespace Gendarme.Rules.Serialization {
 
 		static private FieldDefinition CheckProperty (MethodDefinition getter)
 		{
-			string return_type = getter.ReturnType.FullName;
+			TypeReference return_type = getter.ReturnType;
 			foreach (Instruction ins in getter.Body.Instructions) {
 				if (ins.OpCode.OperandType != OperandType.InlineField)
 					continue;
 				FieldDefinition field = (ins.Operand as FieldDefinition);
-				if ((field != null) && (field.FieldType.FullName == return_type))
+				if ((field != null) && field.FieldType.IsNamed (return_type.Namespace, return_type.Name))
 					return field;
 			}
 			return null;
@@ -143,7 +143,7 @@ namespace Gendarme.Rules.Serialization {
 					if (!mr.HasParameters || (mr.Name != "AddValue") || (mr.Parameters.Count < 2))
 						continue;
 					// type is sealed so this check is ok
-					if (mr.DeclaringType.FullName != "System.Runtime.Serialization.SerializationInfo")
+					if (!mr.DeclaringType.IsNamed ("System.Runtime.Serialization", "SerializationInfo"))
 						continue;
 
 					// look at the second parameter, which should be (or return) the field
@@ -189,7 +189,7 @@ namespace Gendarme.Rules.Serialization {
 
 		public RuleResult CheckType (TypeDefinition type)
 		{
-			if (!type.IsSerializable || !type.Implements ("System.Runtime.Serialization.ISerializable"))
+			if (!type.IsSerializable || !type.Implements ("System.Runtime.Serialization", "ISerializable"))
 				return RuleResult.DoesNotApply;
 
 			MethodDefinition getObjectData = type.GetMethod (MethodSignatures.GetObjectData);
diff --git a/gendarme/rules/Gendarme.Rules.Serialization/MarkAllNonSerializableFieldsRule.cs b/gendarme/rules/Gendarme.Rules.Serialization/MarkAllNonSerializableFieldsRule.cs
index 75d3a89..bfa7bf1 100644
--- a/gendarme/rules/Gendarme.Rules.Serialization/MarkAllNonSerializableFieldsRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Serialization/MarkAllNonSerializableFieldsRule.cs
@@ -27,6 +27,7 @@
 //
 
 using System;
+using System.Globalization;
 using Gendarme.Framework;
 using Gendarme.Framework.Rocks;
 using Mono.Cecil;
@@ -75,7 +76,7 @@ namespace Gendarme.Rules.Serialization {
 		public RuleResult CheckType (TypeDefinition type)
 		{
 			// if type is not serializable or has not any fields or does not implements a custom serialization
-			if (!type.IsSerializable || !type.HasFields || type.Implements ("System.Runtime.Serialization.ISerializable"))
+			if (!type.IsSerializable || !type.HasFields || type.Implements ("System.Runtime.Serialization", "ISerializable"))
 				return RuleResult.DoesNotApply;
 
 			foreach (FieldDefinition field in type.Fields) {
@@ -85,11 +86,17 @@ namespace Gendarme.Rules.Serialization {
 						continue;
 
 					if (fieldType.IsInterface) {
-						Runner.Report (field, Severity.Critical, Confidence.Low, String.Format ("Serialization of interface {0} as field {1} unknown until runtime", fieldType, field.Name));
+						string msg = String.Format (CultureInfo.InvariantCulture,
+							"Serialization of interface {0} as field {1} unknown until runtime", 
+							fieldType, field.Name);
+						Runner.Report (field, Severity.Critical, Confidence.Low, msg);
 						continue;
 					}
-					if (!fieldType.IsEnum && !fieldType.IsSerializable)
-						Runner.Report (field, Severity.Critical, Confidence.High, String.Format ("The field {0} isn't serializable.", field.Name));
+					if (!fieldType.IsEnum && !fieldType.IsSerializable) {
+						string msg = String.Format (CultureInfo.InvariantCulture,
+							"The field {0} isn't serializable.", field.Name);
+						Runner.Report (field, Severity.Critical, Confidence.High, msg);
+					}
 				}
 			}
 
diff --git a/gendarme/rules/Gendarme.Rules.Serialization/MissingSerializableAttributeOnISerializableTypeRule.cs b/gendarme/rules/Gendarme.Rules.Serialization/MissingSerializableAttributeOnISerializableTypeRule.cs
index 24f0b00..74be9db 100644
--- a/gendarme/rules/Gendarme.Rules.Serialization/MissingSerializableAttributeOnISerializableTypeRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Serialization/MissingSerializableAttributeOnISerializableTypeRule.cs
@@ -64,8 +64,6 @@ namespace Gendarme.Rules.Serialization {
 	[FxCopCompatibility ("Microsoft.Usage", "CA2237:MarkISerializableTypesWithSerializable")]
 	public class MissingSerializableAttributeOnISerializableTypeRule : Rule, ITypeRule {
 
-		private const string ISerializable = "System.Runtime.Serialization.ISerializable";
-
 		public RuleResult CheckType (TypeDefinition type)
 		{
 			// rule does not apply to interface (since [Serializable] is not applicable to interfaces)
@@ -74,11 +72,11 @@ namespace Gendarme.Rules.Serialization {
 				return RuleResult.DoesNotApply;
 
 			// rule does not apply if the type does not implements ISerializable 
-			if (!type.Implements (ISerializable))
+			if (!type.Implements ("System.Runtime.Serialization", "ISerializable"))
 				return RuleResult.DoesNotApply;
 
 			// rule applies only if base type is serializable
-			if (type.BaseType.FullName != "System.Object") {
+			if (!type.BaseType.IsNamed ("System", "Object")) {
 				TypeDefinition base_type = type.BaseType.Resolve ();
 				// in doubt don't report
 				if ((base_type == null) || !base_type.IsSerializable)
diff --git a/gendarme/rules/Gendarme.Rules.Serialization/MissingSerializationConstructorRule.cs b/gendarme/rules/Gendarme.Rules.Serialization/MissingSerializationConstructorRule.cs
index 36115b0..e80ffe7 100644
--- a/gendarme/rules/Gendarme.Rules.Serialization/MissingSerializationConstructorRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Serialization/MissingSerializationConstructorRule.cs
@@ -89,9 +89,6 @@ namespace Gendarme.Rules.Serialization {
 	[FxCopCompatibility ("Microsoft.Usage", "CA2229:ImplementSerializationConstructors")]
 	public class MissingSerializationConstructorRule : Rule, ITypeRule {
 
-		// non-localizable
-		private const string ISerializable = "System.Runtime.Serialization.ISerializable";
-
 		// localizable
 		private const string NoSerializationCtorText = "The required constructor for ISerializable is not present in this type.";
 		private const string CtorSealedTypeText = "The serialization constructor should be private since this type is sealed.";
@@ -100,7 +97,7 @@ namespace Gendarme.Rules.Serialization {
 		public RuleResult CheckType (TypeDefinition type)
 		{
 			// rule does not apply to interfaces, delegates or types that does not implement ISerializable
-			if (type.IsInterface || type.IsDelegate () || !type.Implements (ISerializable))
+			if (type.IsInterface || type.IsDelegate () || !type.Implements ("System.Runtime.Serialization", "ISerializable"))
 				return RuleResult.DoesNotApply;
 
 			// rule applies, only Success or Failure from the point on
diff --git a/gendarme/rules/Gendarme.Rules.Serialization/README.md b/gendarme/rules/Gendarme.Rules.Serialization/README.md
new file mode 100644
index 0000000..e236c99
--- /dev/null
+++ b/gendarme/rules/Gendarme.Rules.Serialization/README.md
@@ -0,0 +1,9 @@
+# Gendarme.Rules.Serialization Rules
+
+You can access the latest rules documentation from our [[wiki|https://github.com/spouliot/gendarme/wiki/Gendarme.Rules.Serialization(git)]] pages.
+
+
+## Feedback
+
+Please report any documentation errors, typos or suggestions to the [[Gendarme Mailing List|https://groups.google.com/forum/?fromgroups#!forum/gendarme]]. Thanks!
+
diff --git a/gendarme/rules/Gendarme.Rules.Serialization/Test/Tests.Rules.Serialization.csproj b/gendarme/rules/Gendarme.Rules.Serialization/Test/Tests.Rules.Serialization.csproj
index 5a92892..090910b 100755
--- a/gendarme/rules/Gendarme.Rules.Serialization/Test/Tests.Rules.Serialization.csproj
+++ b/gendarme/rules/Gendarme.Rules.Serialization/Test/Tests.Rules.Serialization.csproj
@@ -1,5 +1,5 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
     <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
@@ -10,8 +10,28 @@
     <AppDesignerFolder>Properties</AppDesignerFolder>
     <RootNamespace>Tests.Rules.Serialization</RootNamespace>
     <AssemblyName>Tests.Rules.Serialization</AssemblyName>
-    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
     <FileAlignment>512</FileAlignment>
+    <FileUpgradeFlags>
+    </FileUpgradeFlags>
+    <OldToolsVersion>3.5</OldToolsVersion>
+    <UpgradeBackupLocation />
+    <PublishUrl>publish\</PublishUrl>
+    <Install>true</Install>
+    <InstallFrom>Disk</InstallFrom>
+    <UpdateEnabled>false</UpdateEnabled>
+    <UpdateMode>Foreground</UpdateMode>
+    <UpdateInterval>7</UpdateInterval>
+    <UpdateIntervalUnits>Days</UpdateIntervalUnits>
+    <UpdatePeriodically>false</UpdatePeriodically>
+    <UpdateRequired>false</UpdateRequired>
+    <MapFileExtensions>true</MapFileExtensions>
+    <ApplicationRevision>0</ApplicationRevision>
+    <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
+    <IsWebBootstrapper>false</IsWebBootstrapper>
+    <UseApplicationTrust>false</UseApplicationTrust>
+    <BootstrapperEnabled>true</BootstrapperEnabled>
+    <TargetFrameworkProfile />
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
     <DebugSymbols>true</DebugSymbols>
@@ -21,6 +41,7 @@
     <DefineConstants>DEBUG;TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
     <DebugType>pdbonly</DebugType>
@@ -29,6 +50,7 @@
     <DefineConstants>TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <ItemGroup>
     <Reference Include="nunit.framework, Version=2.4.8.0, Culture=neutral, PublicKeyToken=96d09a1eb7f44a77, processorArchitecture=MSIL">
@@ -70,6 +92,23 @@
   <ItemGroup>
     <Folder Include="Properties\" />
   </ItemGroup>
+  <ItemGroup>
+    <BootstrapperPackage Include="Microsoft.Net.Client.3.5">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1 Client Profile</ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Windows.Installer.3.1">
+      <Visible>False</Visible>
+      <ProductName>Windows Installer 3.1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+  </ItemGroup>
   <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
   <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
        Other similar extension points exist, see Microsoft.Common.targets.
diff --git a/gendarme/rules/Gendarme.Rules.Serialization/UseCorrectSignatureForSerializationMethodsRule.cs b/gendarme/rules/Gendarme.Rules.Serialization/UseCorrectSignatureForSerializationMethodsRule.cs
index bf69c3a..eed6f2c 100644
--- a/gendarme/rules/Gendarme.Rules.Serialization/UseCorrectSignatureForSerializationMethodsRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Serialization/UseCorrectSignatureForSerializationMethodsRule.cs
@@ -76,13 +76,6 @@ namespace Gendarme.Rules.Serialization {
 		private const string NotSerializableText = "The type of this method is not marked as [Serializable].";
 		private const string WrongSignatureText = "The method has the wrong signature, it should return System.Void and have a single parameter of type 'System.Runtime.Serialization.StreamingContext' and be private.";
 
-		static string [] Attributes = {
-			"System.Runtime.Serialization.OnSerializingAttribute",
-			"System.Runtime.Serialization.OnSerializedAttribute",
-			"System.Runtime.Serialization.OnDeserializingAttribute",
-			"System.Runtime.Serialization.OnDeserializedAttribute"
-		};
-
 		public override void Initialize (IRunner runner)
 		{
 			base.Initialize (runner);
@@ -97,10 +90,40 @@ namespace Gendarme.Rules.Serialization {
 					// if the module does not have a reference to any of the attributes
 					// then nothing will be reported by this rule
 					(e.CurrentAssembly.Name.Name == "mscorlib" ||
-					e.CurrentModule.HasAnyTypeReference (Attributes));
+					e.CurrentModule.AnyTypeReference ((TypeReference tr) => {
+						return IsSerializationAttribute (tr);
+					}));
 			};
 		}
 
+		static bool IsSerializationAttribute (TypeReference type)
+		{
+			if (type.Namespace != "System.Runtime.Serialization")
+				return false;
+
+			switch (type.Name) {
+			case "OnSerializingAttribute":
+			case "OnSerializedAttribute":
+			case "OnDeserializingAttribute":
+			case "OnDeserializedAttribute":
+				return true;
+			default:
+				return false;
+			}
+		}
+
+		static bool HasAnySerializationAttribute (ICustomAttributeProvider method)
+		{
+			if (!method.HasCustomAttributes)
+				return false;
+
+			foreach (CustomAttribute ca in method.CustomAttributes) {
+				if (IsSerializationAttribute (ca.AttributeType))
+					return true;
+			}
+			return false;
+		}
+
 		public RuleResult CheckMethod (MethodDefinition method)
 		{
 			// rule does not apply to constructor or to methods without custom attributes
@@ -108,7 +131,7 @@ namespace Gendarme.Rules.Serialization {
 				return RuleResult.DoesNotApply;
 
 			// marked with any of On[Des|S]erializ[ed|ing]Attribute ?
-			if (!method.CustomAttributes.ContainsAnyType (Attributes))
+			if (!HasAnySerializationAttribute (method))
 				return RuleResult.DoesNotApply;
 
 			// rule apply!
diff --git a/gendarme/rules/Gendarme.Rules.Smells/AvoidLargeClassesRule.cs b/gendarme/rules/Gendarme.Rules.Smells/AvoidLargeClassesRule.cs
index 25519b4..947bd6a 100644
--- a/gendarme/rules/Gendarme.Rules.Smells/AvoidLargeClassesRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Smells/AvoidLargeClassesRule.cs
@@ -28,6 +28,7 @@
 
 using System;
 using System.Collections.Generic;
+using System.Globalization;
 
 using Mono.Cecil;
 
@@ -108,7 +109,7 @@ namespace Gendarme.Rules.Smells {
 			int counter = 1; // include self
 			for (int i = fields.Count - 1; i > start; i--) {
 				FieldDefinition field = fields [i];
-				if (field.Name.StartsWith (prefix)) {
+				if (field.Name.StartsWith (prefix, StringComparison.Ordinal)) {
 					fields.RemoveAt (i);
 					counter++;
 				}
@@ -167,7 +168,8 @@ namespace Gendarme.Rules.Smells {
 					continue;
 				int count = CountPrefixedFields (prefix, i);
 				if (count > 1) {
-					string msg = String.Format ("This type contains fields common prefixes: {0} fields prefixed with '{1}'.",
+					string msg = String.Format (CultureInfo.InvariantCulture,
+						"This type contains fields common prefixes: {0} fields prefixed with '{1}'.",
 						count, prefix);
 					Runner.Report (type, Severity.Medium, Confidence.High, msg);
 				}
@@ -182,7 +184,8 @@ namespace Gendarme.Rules.Smells {
 
 			int fcount = GetNonConstantFieldsCount (type);
 			if (fcount > MaxFields) {
-				string msg = String.Format ("This type contains a lot of fields ({0} versus maximum of {1}).",
+				string msg = String.Format (CultureInfo.InvariantCulture,
+					"This type contains a lot of fields ({0} versus maximum of {1}).",
 					fcount, MaxFields);
 				Runner.Report (type, Severity.High, Confidence.High, msg);
 			}
diff --git a/gendarme/rules/Gendarme.Rules.Smells/AvoidLongMethodsRule.cs b/gendarme/rules/Gendarme.Rules.Smells/AvoidLongMethodsRule.cs
index 67cb274..1ef115b 100644
--- a/gendarme/rules/Gendarme.Rules.Smells/AvoidLongMethodsRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Smells/AvoidLongMethodsRule.cs
@@ -28,6 +28,7 @@
 
 using System;
 using System.Collections.Generic;
+using System.Globalization;
 
 using Mono.Cecil;
 using Mono.Cecil.Cil;
@@ -181,19 +182,6 @@ namespace Gendarme.Rules.Smells {
 
 		const int AssignationRatio = 7;
 		const int DefaultAmountOfElements = 13;
-		static Dictionary<string, string> typeMethodDictionary;
-
-		static AvoidLongMethodsRule ()
-		{
-			typeMethodDictionary = new Dictionary<string,string> (4);
-			typeMethodDictionary.Add ("Gtk.Bin", "Build");
-			typeMethodDictionary.Add ("Gtk.Window", "Build");
-			typeMethodDictionary.Add ("Gtk.Dialog", "Build");
-			typeMethodDictionary.Add ("System.Windows.Forms.Form", "InitializeComponent");
-			typeMethodDictionary.Add ("System.Workflow.Activities.SequentialWorkflowActivity", "InitializeComponent");
-			typeMethodDictionary.Add ("System.Workflow.Activities.StateMachineWorkflowActivity", "InitializeComponent");
-			typeMethodDictionary.Add ("System.Windows.Controls.UserControl", "InitializeComponent");
-		}
 
 		public AvoidLongMethodsRule ()
 		{
@@ -215,12 +203,31 @@ namespace Gendarme.Rules.Smells {
 			if (method.HasParameters)
 				return false;
 
+			string name = method.Name;
+			if ((name != "Build") && (name != "InitializeComponent"))
+				return false;
+
 			TypeDefinition type = method.DeclaringType.Resolve ();
-			if ((type != null) && (type.BaseType != null)) {
-				string method_name;
-				if (typeMethodDictionary.TryGetValue (type.BaseType.FullName, out method_name)) {
-					return (method_name == method.Name);
+			if ((type == null) || (type.BaseType == null))
+				return false;
+
+			string nspace = type.BaseType.Namespace;
+			string tname = type.BaseType.Name;
+			switch (name) {
+			case "Build":
+				if (nspace != "Gtk")
+					return false;
+				return (tname == "Bin" || tname == "Window" || tname == "Dialog");
+			case "InitializeComponent":
+				switch (nspace) {
+				case "System.Windows.Forms":
+					return tname == "Form";
+				case "System.Workflow.Activities":
+					return tname == "SequentialWorkflowActivity" || tname == "StateMachineWorkflowActivity";
+				case "System.Windows.Controls":
+					return tname == "UserControl";
 				}
+				break;
 			}
 			return false;
 		}
@@ -326,7 +333,8 @@ namespace Gendarme.Rules.Smells {
 				if (sloc <= max)
 					return RuleResult.Success;
 
-				string message = String.Format ("Logical SLOC: {0}. Maximum : {1}", sloc, max);
+				string message = String.Format (CultureInfo.CurrentCulture, 
+					"Logical SLOC: {0}. Maximum : {1}", sloc, max);
 				Runner.Report (method, Severity.High, Confidence.High, message);
 			} else {
 				// success if the instruction count is below the defined threshold
@@ -336,7 +344,8 @@ namespace Gendarme.Rules.Smells {
 				if (count <= max)
 					return RuleResult.Success;
 
-				string message = String.Format ("Method IL Size: {0}. Maximum Size: {1}", count, max);
+				string message = String.Format (CultureInfo.CurrentCulture,
+					"Method IL Size: {0}. Maximum Size: {1}", count, max);
 				Runner.Report (method, Severity.High, Confidence.Normal, message);
 			}
 
diff --git a/gendarme/rules/Gendarme.Rules.Smells/AvoidLongParameterListsRule.cs b/gendarme/rules/Gendarme.Rules.Smells/AvoidLongParameterListsRule.cs
index bd5ff4f..a76ec28 100644
--- a/gendarme/rules/Gendarme.Rules.Smells/AvoidLongParameterListsRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Smells/AvoidLongParameterListsRule.cs
@@ -131,13 +131,13 @@ namespace Gendarme.Rules.Smells {
 			if (constructor == null) 
 				return;
 			if (HasMoreParametersThanAllowed (constructor)) 
-				Runner.Report (constructor, Severity.Medium, Confidence.Normal, "This constructor contains a long parameter list.");
+				Runner.Report (constructor, Severity.Medium, Confidence.High, "This constructor contains a long parameter list.");
 		}
 
 		private void CheckMethod (IMethodSignature method)
 		{
 			if (HasMoreParametersThanAllowed (method))
-				Runner.Report (method, Severity.Medium, Confidence.Normal, "This method contains a long parameter list.");
+				Runner.Report (method, Severity.Medium, Confidence.High, "This method contains a long parameter list.");
 		}
 
 		//TODO: Perhaps we can perform this action with linq instead of
@@ -182,7 +182,7 @@ namespace Gendarme.Rules.Smells {
 			MethodDefinition method = type.GetMethod ("Invoke");
 			// MulticastDelegate inherits from Delegate without overriding Invoke
 			if ((method != null) && HasMoreParametersThanAllowed (method))
-				Runner.Report (type, Severity.Medium, Confidence.Normal, "This delegate contains a long parameter list.");
+				Runner.Report (type, Severity.Medium, Confidence.High, "This delegate contains a long parameter list.");
 			return Runner.CurrentRuleResult;
 		}
 		
diff --git a/gendarme/rules/Gendarme.Rules.Smells/AvoidMessageChainsRule.cs b/gendarme/rules/Gendarme.Rules.Smells/AvoidMessageChainsRule.cs
index 8d79e77..f786cb7 100644
--- a/gendarme/rules/Gendarme.Rules.Smells/AvoidMessageChainsRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Smells/AvoidMessageChainsRule.cs
@@ -31,6 +31,7 @@
 using System;
 using System.Collections.Generic;
 using System.Diagnostics;
+using System.Globalization;
 
 using Mono.Cecil;
 using Mono.Cecil.Cil;
@@ -116,7 +117,7 @@ namespace Gendarme.Rules.Smells {
 
 				// operators "break" chains
 				MethodReference mr = (ins.Operand as MethodReference);
-				if (mr.Name.StartsWith ("op_"))
+				if (mr.Name.StartsWith ("op_", StringComparison.Ordinal))
 					continue;
 
 				int counter = 1;
@@ -131,7 +132,8 @@ namespace Gendarme.Rules.Smells {
 				Log.WriteLine (this, "chain of length {0} at {1:X4}", counter, ins.Offset);
 
 				if (counter > MaxChainLength) {
-					string msg = String.Format ("Chain length {0} versus maximum of {1}.", counter, MaxChainLength);
+					string msg = String.Format (CultureInfo.CurrentCulture, 
+						"Chain length {0} versus maximum of {1}.", counter, MaxChainLength);
 					Runner.Report (method, ins, Severity.Medium, Confidence.Normal, msg);
 				}
 			}
diff --git a/gendarme/rules/Gendarme.Rules.Smells/AvoidSpeculativeGeneralityRule.cs b/gendarme/rules/Gendarme.Rules.Smells/AvoidSpeculativeGeneralityRule.cs
index 7228572..1393c22 100644
--- a/gendarme/rules/Gendarme.Rules.Smells/AvoidSpeculativeGeneralityRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Smells/AvoidSpeculativeGeneralityRule.cs
@@ -117,15 +117,14 @@ namespace Gendarme.Rules.Smells {
 	[EngineDependency (typeof (OpCodeEngine))]
 	public class AvoidSpeculativeGeneralityRule : Rule, ITypeRule {
 
-		private bool HasExpectedInheritedTypeCount (MemberReference baseType, int expected)
+		private bool HasExpectedInheritedTypeCount (TypeReference baseType, int expected)
 		{
 			int count = 0;
-			string base_name = baseType.FullName;
 			foreach (AssemblyDefinition assembly in Runner.Assemblies) {
 				foreach (ModuleDefinition module in assembly.Modules) {
 					foreach (TypeDefinition type in module.GetAllTypes ()) {
 						if ((baseType == type.BaseType) || (type.BaseType != null &&
-							(base_name == type.BaseType.FullName))) {
+							type.BaseType.IsNamed (baseType.Namespace, baseType.Name))) {
 							if (++count > expected)
 								return false;
 						}
@@ -168,7 +167,7 @@ namespace Gendarme.Rules.Smells {
 
 		private static bool InheritsOnlyFromObject (TypeDefinition type)
 		{
-			return !type.HasInterfaces && type.BaseType.FullName == "System.Object";
+			return !type.HasInterfaces && type.BaseType.IsNamed ("System", "Object");
 		}
 
 		private static bool MostlyMethodsDelegatesCall (TypeDefinition type)
diff --git a/gendarme/rules/Gendarme.Rules.Smells/CodeDuplicatedLocator.cs b/gendarme/rules/Gendarme.Rules.Smells/CodeDuplicatedLocator.cs
index 621c22c..1e9790e 100644
--- a/gendarme/rules/Gendarme.Rules.Smells/CodeDuplicatedLocator.cs
+++ b/gendarme/rules/Gendarme.Rules.Smells/CodeDuplicatedLocator.cs
@@ -30,6 +30,7 @@ using System;
 using System.Collections.Generic;
 using System.Collections.ObjectModel;
 using System.Diagnostics;
+using System.Globalization;
 
 using Mono.Cecil;
 using Mono.Cecil.Cil;
@@ -81,8 +82,10 @@ namespace Gendarme.Rules.Smells {
 					continue;
 
 				Pattern duplicated = GetDuplicatedCode (current, target);
-				if (duplicated != null && duplicated.Count > 0)
-					parent_rule.Runner.Report (current, duplicated[0], Severity.High, Confidence.Normal, String.Format ("Duplicated code with {0}", target));
+				if (duplicated != null && duplicated.Count > 0) {
+					parent_rule.Runner.Report (current, duplicated[0], Severity.High, Confidence.Normal, 
+						String.Format (CultureInfo.InvariantCulture, "Duplicated code with {0}", target.GetFullName ()));
+				}
 			}
 		}
 
diff --git a/gendarme/rules/Gendarme.Rules.Smells/Gendarme.Rules.Smells.csproj b/gendarme/rules/Gendarme.Rules.Smells/Gendarme.Rules.Smells.csproj
index e3d68f2..bdad8ae 100755
--- a/gendarme/rules/Gendarme.Rules.Smells/Gendarme.Rules.Smells.csproj
+++ b/gendarme/rules/Gendarme.Rules.Smells/Gendarme.Rules.Smells.csproj
@@ -1,5 +1,5 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
     <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
@@ -10,8 +10,28 @@
     <AppDesignerFolder>Properties</AppDesignerFolder>
     <RootNamespace>Gendarme.Rules.Smells</RootNamespace>
     <AssemblyName>Gendarme.Rules.Smells</AssemblyName>
-    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
     <FileAlignment>512</FileAlignment>
+    <FileUpgradeFlags>
+    </FileUpgradeFlags>
+    <OldToolsVersion>3.5</OldToolsVersion>
+    <UpgradeBackupLocation />
+    <PublishUrl>publish\</PublishUrl>
+    <Install>true</Install>
+    <InstallFrom>Disk</InstallFrom>
+    <UpdateEnabled>false</UpdateEnabled>
+    <UpdateMode>Foreground</UpdateMode>
+    <UpdateInterval>7</UpdateInterval>
+    <UpdateIntervalUnits>Days</UpdateIntervalUnits>
+    <UpdatePeriodically>false</UpdatePeriodically>
+    <UpdateRequired>false</UpdateRequired>
+    <MapFileExtensions>true</MapFileExtensions>
+    <ApplicationRevision>0</ApplicationRevision>
+    <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
+    <IsWebBootstrapper>false</IsWebBootstrapper>
+    <UseApplicationTrust>false</UseApplicationTrust>
+    <BootstrapperEnabled>true</BootstrapperEnabled>
+    <TargetFrameworkProfile />
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
     <DebugSymbols>true</DebugSymbols>
@@ -24,6 +44,7 @@
     <NoWarn>1591</NoWarn>
     <WarningsAsErrors>1570</WarningsAsErrors>
     <DocumentationFile>..\..\console\bin\Debug\Gendarme.Rules.Smells.xml</DocumentationFile>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
     <DebugType>pdbonly</DebugType>
@@ -35,6 +56,7 @@
     <NoWarn>1591</NoWarn>
     <WarningsAsErrors>1570</WarningsAsErrors>
     <DocumentationFile>..\..\console\bin\Release\Gendarme.Rules.Smells.xml</DocumentationFile>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <ItemGroup>
     <Reference Include="System" />
@@ -72,6 +94,23 @@
       <Name>Gendarme.Rules.Performance</Name>
     </ProjectReference>
   </ItemGroup>
+  <ItemGroup>
+    <BootstrapperPackage Include="Microsoft.Net.Client.3.5">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1 Client Profile</ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Windows.Installer.3.1">
+      <Visible>False</Visible>
+      <ProductName>Windows Installer 3.1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+  </ItemGroup>
   <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
   <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
        Other similar extension points exist, see Microsoft.Common.targets.
diff --git a/gendarme/rules/Gendarme.Rules.Smells/InstructionMatcher.cs b/gendarme/rules/Gendarme.Rules.Smells/InstructionMatcher.cs
index 21fee89..34891d6 100644
--- a/gendarme/rules/Gendarme.Rules.Smells/InstructionMatcher.cs
+++ b/gendarme/rules/Gendarme.Rules.Smells/InstructionMatcher.cs
@@ -51,8 +51,8 @@ namespace Gendarme.Rules.Smells {
 			if ((source == null) || (target == null))
 				return false;
 
-			int ss = source.GetSequence () - 1;
-			int ts = target.GetSequence () - 1;
+			int ss = source.Index;
+			int ts = target.Index;
 			if ((ss <= 0) || (ts <= 0))
 				return false;
 
diff --git a/gendarme/rules/Gendarme.Rules.Smells/Pattern.cs b/gendarme/rules/Gendarme.Rules.Smells/Pattern.cs
index c0c37e4..17b5afb 100644
--- a/gendarme/rules/Gendarme.Rules.Smells/Pattern.cs
+++ b/gendarme/rules/Gendarme.Rules.Smells/Pattern.cs
@@ -52,16 +52,7 @@ namespace Gendarme.Rules.Smells {
 		{
 			if (ins.OpCode.Code != Code.Isinst)
 				return false;
-			return ((ins.Operand as TypeReference).FullName == "System.IDisposable");
-		}
-
-		// look for a virtual call to a specific method
-		static bool IsCallVirt (Instruction ins, string typeName, string methodName)
-		{
-			if (ins.OpCode.Code != Code.Callvirt)
-				return false;
-			MethodReference mr = (ins.Operand as MethodReference);
-			return ((mr != null) && (mr.Name == methodName) && (mr.DeclaringType.FullName == typeName));
+			return (ins.Operand as TypeReference).IsNamed ("System", "IDisposable");
 		}
 
 		// look for:
@@ -69,7 +60,9 @@ namespace Gendarme.Rules.Smells {
 		//	endfinally 
 		static bool IsIDisposableDisposePattern (Instruction ins)
 		{
-			if (!IsCallVirt (ins, "System.IDisposable", "Dispose"))
+			if (ins.OpCode.Code != Code.Callvirt)
+				return false;
+			if (!(ins.Operand as MethodReference).IsNamed ("System", "IDisposable", "Dispose"))
 				return false;
 			return ins.Next.Is (Code.Endfinally);
 		}
@@ -89,10 +82,13 @@ namespace Gendarme.Rules.Smells {
 			for (int i = 0; i < Count; i++) {
 				Instruction ins = instructions [i];
 				// foreach
-				if (IsCallVirt (ins, "System.Collections.IEnumerator", "get_Current"))
-					return true;
-				if (IsCallVirt (ins, "System.Collections.IEnumerator", "MoveNext"))
-					return !call;
+				if (ins.OpCode.Code == Code.Callvirt) {
+					MethodReference mr = (ins.Operand as MethodReference);
+					if (mr.IsNamed ("System.Collections", "IEnumerator", "get_Current"))
+						return true;
+					if (mr.IsNamed ("System.Collections", "IEnumerator", "MoveNext"))
+						return !call;
+				}
 				// if there's a unknown call then it's likely not (totally) compiler generated
 				call |= (ins.OpCode.FlowControl == FlowControl.Call);
 				// foreach
diff --git a/gendarme/rules/Gendarme.Rules.Smells/README.md b/gendarme/rules/Gendarme.Rules.Smells/README.md
new file mode 100644
index 0000000..b02c441
--- /dev/null
+++ b/gendarme/rules/Gendarme.Rules.Smells/README.md
@@ -0,0 +1,9 @@
+# Gendarme.Rules.Smells Rules
+
+You can access the latest rules documentation from our [[wiki|https://github.com/spouliot/gendarme/wiki/Gendarme.Rules.Smells(git)]] pages.
+
+
+## Feedback
+
+Please report any documentation errors, typos or suggestions to the [[Gendarme Mailing List|https://groups.google.com/forum/?fromgroups#!forum/gendarme]]. Thanks!
+
diff --git a/gendarme/rules/Gendarme.Rules.Smells/Test/AvoidCodeDuplicatedInSameClassTest.cs b/gendarme/rules/Gendarme.Rules.Smells/Test/AvoidCodeDuplicatedInSameClassTest.cs
index f88d4ed..11dcfa6 100644
--- a/gendarme/rules/Gendarme.Rules.Smells/Test/AvoidCodeDuplicatedInSameClassTest.cs
+++ b/gendarme/rules/Gendarme.Rules.Smells/Test/AvoidCodeDuplicatedInSameClassTest.cs
@@ -686,20 +686,20 @@ namespace Test.Rules.Smells {
 		class NonDuplicatedComparingAndReturningNull {
 			string CheckTwoOptions (TypeReference type) 
 			{
-				if (type.Implements ("System.Collections.IDictionary") || type.Implements ("System.Collections.Generic.IDictionary`2"))
+				if (type.Implements ("System.Collections", "IDictionary") || type.Implements ("System.Collections.Generic", "IDictionary`2"))
 					return null;
 				return "'Dictionary' should only be used for types implementing IDictionary and IDictionary<TKey,TValue>.";
 			}
 
 			string CheckThreeOptions (TypeReference type)
 			{
-				if (type.Implements ("System.Collections.ICollection") ||
-					type.Implements ("System.Collections.IEnumerable") ||
-					type.Implements ("System.Collections.Generic.ICollection`1"))
+				if (type.Implements ("System.Collections", "ICollection") ||
+					type.Implements ("System.Collections", "IEnumerable") ||
+					type.Implements ("System.Collections.Generic", "ICollection`1"))
 					return null;
 
-				if (type.Inherits ("System.Collections.Queue") || type.Inherits ("System.Collections.Stack") || 
-					type.Inherits ("System.Data.DataSet") || type.Inherits ("System.Data.DataTable"))
+				if (type.Inherits ("System.Collections", "Queue") || type.Inherits ("System.Collections", "Stack") || 
+					type.Inherits ("System.Data", "DataSet") || type.Inherits ("System.Data", "DataTable"))
 					return null;
 
 				return "'Collection' should only be used for implementing ICollection or IEnumerable or inheriting from Queue, Stack, DataSet and DataTable.";
diff --git a/gendarme/rules/Gendarme.Rules.Smells/Test/Tests.Rules.Smells.csproj b/gendarme/rules/Gendarme.Rules.Smells/Test/Tests.Rules.Smells.csproj
index a67869a..eb69c1d 100755
--- a/gendarme/rules/Gendarme.Rules.Smells/Test/Tests.Rules.Smells.csproj
+++ b/gendarme/rules/Gendarme.Rules.Smells/Test/Tests.Rules.Smells.csproj
@@ -1,5 +1,5 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
     <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
@@ -10,8 +10,28 @@
     <AppDesignerFolder>Properties</AppDesignerFolder>
     <RootNamespace>Tests.Rules.Smells</RootNamespace>
     <AssemblyName>Tests.Rules.Smells</AssemblyName>
-    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
     <FileAlignment>512</FileAlignment>
+    <FileUpgradeFlags>
+    </FileUpgradeFlags>
+    <OldToolsVersion>3.5</OldToolsVersion>
+    <UpgradeBackupLocation />
+    <PublishUrl>publish\</PublishUrl>
+    <Install>true</Install>
+    <InstallFrom>Disk</InstallFrom>
+    <UpdateEnabled>false</UpdateEnabled>
+    <UpdateMode>Foreground</UpdateMode>
+    <UpdateInterval>7</UpdateInterval>
+    <UpdateIntervalUnits>Days</UpdateIntervalUnits>
+    <UpdatePeriodically>false</UpdatePeriodically>
+    <UpdateRequired>false</UpdateRequired>
+    <MapFileExtensions>true</MapFileExtensions>
+    <ApplicationRevision>0</ApplicationRevision>
+    <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
+    <IsWebBootstrapper>false</IsWebBootstrapper>
+    <UseApplicationTrust>false</UseApplicationTrust>
+    <BootstrapperEnabled>true</BootstrapperEnabled>
+    <TargetFrameworkProfile />
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
     <DebugSymbols>true</DebugSymbols>
@@ -21,6 +41,7 @@
     <DefineConstants>DEBUG;TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
     <DebugType>pdbonly</DebugType>
@@ -29,6 +50,7 @@
     <DefineConstants>TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <ItemGroup>
     <Reference Include="nunit.framework, Version=2.4.8.0, Culture=neutral, PublicKeyToken=96d09a1eb7f44a77, processorArchitecture=MSIL">
@@ -75,6 +97,23 @@
   <ItemGroup>
     <Folder Include="Properties\" />
   </ItemGroup>
+  <ItemGroup>
+    <BootstrapperPackage Include="Microsoft.Net.Client.3.5">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1 Client Profile</ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Windows.Installer.3.1">
+      <Visible>False</Visible>
+      <ProductName>Windows Installer 3.1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+  </ItemGroup>
   <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
   <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
        Other similar extension points exist, see Microsoft.Common.targets.
diff --git a/gendarme/rules/Gendarme.Rules.Ui/AddMatchingArrangeMeasureOverrideRule.cs b/gendarme/rules/Gendarme.Rules.Ui/AddMatchingArrangeMeasureOverrideRule.cs
index aaf21fe..b288e10 100644
--- a/gendarme/rules/Gendarme.Rules.Ui/AddMatchingArrangeMeasureOverrideRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Ui/AddMatchingArrangeMeasureOverrideRule.cs
@@ -81,15 +81,18 @@ namespace Gendarme.Rules.UI {
 			// if the module does not reference System.Windows.Size, 
 			// then it will not be using the overrides
 			Runner.AnalyzeModule += delegate (object o, RunnerEventArgs e) {
-				Active = ((e.CurrentAssembly.Name.Name == "WindowsBase" ||
-					 e.CurrentAssembly.Name.Name == "System.Windows") ||
-					 e.CurrentModule.HasTypeReference (Size));
+				string assembly_name = e.CurrentAssembly.Name.Name;
+				Active = ((assembly_name == "WindowsBase" || assembly_name == "System.Windows") ||
+					e.CurrentModule.AnyTypeReference ((TypeReference tr) => {
+						return tr.IsNamed ("System.Windows", "Size");
+					})
+				);
 			};
 		}
 
 		public RuleResult CheckType (TypeDefinition type)
 		{
-			if (!type.IsClass || !type.HasMethods || !type.Inherits ("System.Windows.FrameworkElement"))
+			if (!type.IsClass || !type.HasMethods || !type.Inherits ("System.Windows", "FrameworkElement"))
 				return RuleResult.DoesNotApply;
 			var arrangeOverride = type.GetMethod (arrangeSignature);
 			var measureOverride = type.GetMethod (measureSignature);
diff --git a/gendarme/rules/Gendarme.Rules.Ui/Gendarme.Rules.Ui.csproj b/gendarme/rules/Gendarme.Rules.Ui/Gendarme.Rules.Ui.csproj
index 379050c..dd0ff7a 100644
--- a/gendarme/rules/Gendarme.Rules.Ui/Gendarme.Rules.Ui.csproj
+++ b/gendarme/rules/Gendarme.Rules.Ui/Gendarme.Rules.Ui.csproj
@@ -1,119 +1,141 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
-<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="3.5">
-  <PropertyGroup>
-    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
-    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
-    <ProductVersion>9.0.30729</ProductVersion>
-    <SchemaVersion>2.0</SchemaVersion>
-    <ProjectGuid>{949C4D51-4581-402A-AC18-B1B41F395FDA}</ProjectGuid>
-    <OutputType>Library</OutputType>
-    <AppDesignerFolder>Properties</AppDesignerFolder>
-    <RootNamespace>Gendarme.Rules.Ui</RootNamespace>
-    <AssemblyName>Gendarme.Rules.Ui</AssemblyName>
-    <FileUpgradeFlags>
-    </FileUpgradeFlags>
-    <OldToolsVersion>2.0</OldToolsVersion>
-    <UpgradeBackupLocation>
-    </UpgradeBackupLocation>
-    <PublishUrl>http://localhost/Gendarme.Rules.Ui/</PublishUrl>
-    <Install>true</Install>
-    <InstallFrom>Web</InstallFrom>
-    <UpdateEnabled>true</UpdateEnabled>
-    <UpdateMode>Foreground</UpdateMode>
-    <UpdateInterval>7</UpdateInterval>
-    <UpdateIntervalUnits>Days</UpdateIntervalUnits>
-    <UpdatePeriodically>false</UpdatePeriodically>
-    <UpdateRequired>false</UpdateRequired>
-    <MapFileExtensions>true</MapFileExtensions>
-    <ApplicationRevision>0</ApplicationRevision>
-    <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
-    <IsWebBootstrapper>true</IsWebBootstrapper>
-    <UseApplicationTrust>false</UseApplicationTrust>
-    <BootstrapperEnabled>true</BootstrapperEnabled>
-    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
-  </PropertyGroup>
-  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
-    <DebugSymbols>true</DebugSymbols>
-    <DebugType>full</DebugType>
-    <Optimize>false</Optimize>
-    <OutputPath>..\..\console\bin\Debug\</OutputPath>
-    <DefineConstants>DEBUG;TRACE</DefineConstants>
-    <ErrorReport>prompt</ErrorReport>
-    <WarningLevel>4</WarningLevel>
-    <NoWarn>1590</NoWarn>
-    <WarningsAsErrors>1571</WarningsAsErrors>
-    <DocumentationFile>..\..\console\bin\Debug\Gendarme.Rules.Ui.xml</DocumentationFile>
-  </PropertyGroup>
-  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
-    <DebugType>pdbonly</DebugType>
-    <Optimize>true</Optimize>
-    <OutputPath>..\..\console\bin\Release\</OutputPath>
-    <DefineConstants>TRACE;RELEASE</DefineConstants>
-    <ErrorReport>prompt</ErrorReport>
-    <WarningLevel>4</WarningLevel>
-    <DocumentationFile>..\..\console\bin\Release\Gendarme.Rules.Ui.xml</DocumentationFile>
-    <NoWarn>1591</NoWarn>
-    <WarningsAsErrors>1570</WarningsAsErrors>
-  </PropertyGroup>
-  <ItemGroup>
-    <Reference Include="System" />
-    <Reference Include="System.Core">
-      <RequiredTargetFramework>3.5</RequiredTargetFramework>
-    </Reference>
-  </ItemGroup>
-  <ItemGroup>
-    <Compile Include="..\..\AssemblyStaticInfo.cs">
-      <Link>AssemblyStaticInfo.cs</Link>
-    </Compile>
-    <Compile Include="AddMatchingArrangeMeasureOverrideRule.cs" />
-    <Compile Include="ExecutableTargetRule.cs" />
-    <Compile Include="GtkSharpExecutableTargetRule.cs" />
-    <Compile Include="SystemWindowsFormsExecutableTargetRule.cs" />
-    <Compile Include="UseSTAThreadAttributeOnSWFEntryPointsRule.cs" />
-  </ItemGroup>
-  <ItemGroup>
-    <ProjectReference Include="..\..\..\..\cecil\Mono.Cecil.csproj">
-      <Project>{D68133BD-1E63-496E-9EDE-4FBDBF77B486}</Project>
-      <Name>Mono.Cecil</Name>
-    </ProjectReference>
-    <ProjectReference Include="..\..\framework\Gendarme.Framework.csproj">
-      <Project>{CD6818D5-B398-486C-B180-92A07B143AFD}</Project>
-      <Name>Gendarme.Framework</Name>
-    </ProjectReference>
-  </ItemGroup>
-  <ItemGroup>
-    <BootstrapperPackage Include="Microsoft.Net.Framework.2.0">
-      <Visible>False</Visible>
-    </BootstrapperPackage>
-    <BootstrapperPackage Include="Microsoft.Net.Framework.3.0">
-      <Visible>False</Visible>
-    </BootstrapperPackage>
-    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5">
-      <Visible>False</Visible>
-    </BootstrapperPackage>
-  </ItemGroup>
-  <Import Project="$(MSBuildBinPath)\Microsoft.CSharp.targets" />
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="4.0">
+  <PropertyGroup>
+    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
+    <ProductVersion>9.0.30729</ProductVersion>
+    <SchemaVersion>2.0</SchemaVersion>
+    <ProjectGuid>{949C4D51-4581-402A-AC18-B1B41F395FDA}</ProjectGuid>
+    <OutputType>Library</OutputType>
+    <AppDesignerFolder>Properties</AppDesignerFolder>
+    <RootNamespace>Gendarme.Rules.Ui</RootNamespace>
+    <AssemblyName>Gendarme.Rules.Ui</AssemblyName>
+    <FileUpgradeFlags>
+    </FileUpgradeFlags>
+    <OldToolsVersion>3.5</OldToolsVersion>
+    <UpgradeBackupLocation>
+    </UpgradeBackupLocation>
+    <IsWebBootstrapper>true</IsWebBootstrapper>
+    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
+    <PublishUrl>http://localhost/Gendarme.Rules.Ui/</PublishUrl>
+    <Install>true</Install>
+    <InstallFrom>Web</InstallFrom>
+    <UpdateEnabled>true</UpdateEnabled>
+    <UpdateMode>Foreground</UpdateMode>
+    <UpdateInterval>7</UpdateInterval>
+    <UpdateIntervalUnits>Days</UpdateIntervalUnits>
+    <UpdatePeriodically>false</UpdatePeriodically>
+    <UpdateRequired>false</UpdateRequired>
+    <MapFileExtensions>true</MapFileExtensions>
+    <ApplicationRevision>0</ApplicationRevision>
+    <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
+    <UseApplicationTrust>false</UseApplicationTrust>
+    <BootstrapperEnabled>true</BootstrapperEnabled>
+    <TargetFrameworkProfile />
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
+    <DebugSymbols>true</DebugSymbols>
+    <DebugType>full</DebugType>
+    <Optimize>false</Optimize>
+    <OutputPath>..\..\console\bin\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+    <NoWarn>1590</NoWarn>
+    <WarningsAsErrors>1571</WarningsAsErrors>
+    <DocumentationFile>..\..\console\bin\Debug\Gendarme.Rules.Ui.xml</DocumentationFile>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
+    <DebugType>pdbonly</DebugType>
+    <Optimize>true</Optimize>
+    <OutputPath>..\..\console\bin\Release\</OutputPath>
+    <DefineConstants>TRACE;RELEASE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+    <DocumentationFile>..\..\console\bin\Release\Gendarme.Rules.Ui.xml</DocumentationFile>
+    <NoWarn>1591</NoWarn>
+    <WarningsAsErrors>1570</WarningsAsErrors>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
+  </PropertyGroup>
+  <ItemGroup>
+    <Reference Include="System" />
+    <Reference Include="System.Core">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+  </ItemGroup>
+  <ItemGroup>
+    <Compile Include="..\..\AssemblyStaticInfo.cs">
+      <Link>AssemblyStaticInfo.cs</Link>
+    </Compile>
+    <Compile Include="AddMatchingArrangeMeasureOverrideRule.cs" />
+    <Compile Include="ExecutableTargetRule.cs" />
+    <Compile Include="GtkSharpExecutableTargetRule.cs" />
+    <Compile Include="SystemWindowsFormsExecutableTargetRule.cs" />
+    <Compile Include="UseSTAThreadAttributeOnSWFEntryPointsRule.cs" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\..\..\..\cecil\Mono.Cecil.csproj">
+      <Project>{D68133BD-1E63-496E-9EDE-4FBDBF77B486}</Project>
+      <Name>Mono.Cecil</Name>
+    </ProjectReference>
+    <ProjectReference Include="..\..\framework\Gendarme.Framework.csproj">
+      <Project>{CD6818D5-B398-486C-B180-92A07B143AFD}</Project>
+      <Name>Gendarme.Framework</Name>
+    </ProjectReference>
+  </ItemGroup>
+  <ItemGroup>
+    <BootstrapperPackage Include="Microsoft.Net.Client.3.5">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1 Client Profile</ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Net.Framework.2.0">
+      <Visible>False</Visible>
+      <ProductName>
+      </ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Net.Framework.3.0">
+      <Visible>False</Visible>
+      <ProductName>
+      </ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5">
+      <Visible>False</Visible>
+      <ProductName>
+      </ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1</ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
+  </ItemGroup>
+  <Import Project="$(MSBuildBinPath)\Microsoft.CSharp.targets" />
   <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
        Other similar extension points exist, see Microsoft.Common.targets.
   <Target Name="BeforeBuild">
   </Target>
   <Target Name="AfterBuild">
   </Target>
-  -->
-  <ProjectExtensions>
-    <MonoDevelop>
-      <Properties>
-        <MonoDevelop.Autotools.MakefileInfo IntegrationEnabled="true" RelativeMakefileName="Makefile.am" IsAutotoolsProject="true" RelativeConfigureInPath="../../..">
-          <BuildFilesVar Sync="true" Name="rules_sources" />
-          <DeployFilesVar />
-          <ResourcesVar />
-          <OthersVar />
-          <GacRefVar />
-          <AsmRefVar />
-          <ProjectRefVar />
-        </MonoDevelop.Autotools.MakefileInfo>
-      </Properties>
-    </MonoDevelop>
-    <VisualStudio />
-  </ProjectExtensions>
+  -->
+  <ProjectExtensions>
+    <MonoDevelop>
+      <Properties>
+        <MonoDevelop.Autotools.MakefileInfo IntegrationEnabled="true" RelativeMakefileName="Makefile.am" IsAutotoolsProject="true" RelativeConfigureInPath="../../..">
+          <BuildFilesVar Sync="true" Name="rules_sources" />
+          <DeployFilesVar />
+          <ResourcesVar />
+          <OthersVar />
+          <GacRefVar />
+          <AsmRefVar />
+          <ProjectRefVar />
+        </MonoDevelop.Autotools.MakefileInfo>
+      </Properties>
+    </MonoDevelop>
+    <VisualStudio />
+  </ProjectExtensions>
 </Project>
\ No newline at end of file
diff --git a/gendarme/rules/Gendarme.Rules.Ui/README.md b/gendarme/rules/Gendarme.Rules.Ui/README.md
new file mode 100644
index 0000000..b107d14
--- /dev/null
+++ b/gendarme/rules/Gendarme.Rules.Ui/README.md
@@ -0,0 +1,9 @@
+# Gendarme.Rules.Ui Rules
+
+You can access the latest rules documentation from our [[wiki|https://github.com/spouliot/gendarme/wiki/Gendarme.Rules.Ui(git)]] pages.
+
+
+## Feedback
+
+Please report any documentation errors, typos or suggestions to the [[Gendarme Mailing List|https://groups.google.com/forum/?fromgroups#!forum/gendarme]]. Thanks!
+
diff --git a/gendarme/rules/Gendarme.Rules.Ui/Test/Tests.Rules.Ui.csproj b/gendarme/rules/Gendarme.Rules.Ui/Test/Tests.Rules.Ui.csproj
index 1122d10..902d880 100644
--- a/gendarme/rules/Gendarme.Rules.Ui/Test/Tests.Rules.Ui.csproj
+++ b/gendarme/rules/Gendarme.Rules.Ui/Test/Tests.Rules.Ui.csproj
@@ -1,5 +1,5 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
-<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="3.5">
+<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="4.0">
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
     <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
@@ -12,9 +12,11 @@
     <AssemblyName>Tests.Rules.Ui</AssemblyName>
     <FileUpgradeFlags>
     </FileUpgradeFlags>
-    <OldToolsVersion>2.0</OldToolsVersion>
+    <OldToolsVersion>3.5</OldToolsVersion>
     <UpgradeBackupLocation>
     </UpgradeBackupLocation>
+    <IsWebBootstrapper>true</IsWebBootstrapper>
+    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
     <PublishUrl>http://localhost/Tests.Rules.Ui/</PublishUrl>
     <Install>true</Install>
     <InstallFrom>Web</InstallFrom>
@@ -27,10 +29,9 @@
     <MapFileExtensions>true</MapFileExtensions>
     <ApplicationRevision>0</ApplicationRevision>
     <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
-    <IsWebBootstrapper>true</IsWebBootstrapper>
     <UseApplicationTrust>false</UseApplicationTrust>
     <BootstrapperEnabled>true</BootstrapperEnabled>
-    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <TargetFrameworkProfile />
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
     <DebugSymbols>true</DebugSymbols>
@@ -40,6 +41,7 @@
     <DefineConstants>DEBUG;TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
     <DebugType>pdbonly</DebugType>
@@ -48,6 +50,7 @@
     <DefineConstants>TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <ItemGroup>
     <Reference Include="nunit.framework, Version=2.4.8.0, Culture=neutral, PublicKeyToken=96d09a1eb7f44a77, processorArchitecture=MSIL">
@@ -64,6 +67,7 @@
     <Reference Include="System.Core">
       <RequiredTargetFramework>3.5</RequiredTargetFramework>
     </Reference>
+    <Reference Include="System.Xaml" />
     <Reference Include="WindowsBase">
       <RequiredTargetFramework>3.0</RequiredTargetFramework>
     </Reference>
@@ -94,14 +98,33 @@
     </ProjectReference>
   </ItemGroup>
   <ItemGroup>
+    <BootstrapperPackage Include="Microsoft.Net.Client.3.5">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1 Client Profile</ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
     <BootstrapperPackage Include="Microsoft.Net.Framework.2.0">
       <Visible>False</Visible>
+      <ProductName>
+      </ProductName>
+      <Install>false</Install>
     </BootstrapperPackage>
     <BootstrapperPackage Include="Microsoft.Net.Framework.3.0">
       <Visible>False</Visible>
+      <ProductName>
+      </ProductName>
+      <Install>false</Install>
     </BootstrapperPackage>
     <BootstrapperPackage Include="Microsoft.Net.Framework.3.5">
       <Visible>False</Visible>
+      <ProductName>
+      </ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1</ProductName>
+      <Install>false</Install>
     </BootstrapperPackage>
   </ItemGroup>
   <Import Project="$(MSBuildBinPath)\Microsoft.CSharp.targets" />
diff --git a/gendarme/rules/Gendarme.Rules.Ui/UseSTAThreadAttributeOnSWFEntryPointsRule.cs b/gendarme/rules/Gendarme.Rules.Ui/UseSTAThreadAttributeOnSWFEntryPointsRule.cs
index 5d0cf60..7460b54 100644
--- a/gendarme/rules/Gendarme.Rules.Ui/UseSTAThreadAttributeOnSWFEntryPointsRule.cs
+++ b/gendarme/rules/Gendarme.Rules.Ui/UseSTAThreadAttributeOnSWFEntryPointsRule.cs
@@ -92,9 +92,6 @@ namespace Gendarme.Rules.UI {
 
 		private const string SystemWindowsForms = "System.Windows.Forms";
 
-		private const string STAThread = "System.STAThreadAttribute";
-		private const string MTAThread = "System.MTAThreadAttribute";
-
 		public RuleResult CheckAssembly (AssemblyDefinition assembly)
 		{
 			MethodDefinition entry_point = assembly.EntryPoint;
@@ -115,8 +112,8 @@ namespace Gendarme.Rules.UI {
 			if (!referencesSWF)
 				return RuleResult.DoesNotApply;
 
-			bool hasSTA = entry_point.HasAttribute (STAThread);
-			bool hasMTA = entry_point.HasAttribute (MTAThread);
+			bool hasSTA = entry_point.HasAttribute ("System", "STAThreadAttribute");
+			bool hasMTA = entry_point.HasAttribute ("System", "MTAThreadAttribute");
 
 			// success if only [STAThread] attribute is present
 			if (hasSTA && !hasMTA)
diff --git a/gendarme/rules/README.md b/gendarme/rules/README.md
new file mode 100644
index 0000000..30a91a3
--- /dev/null
+++ b/gendarme/rules/README.md
@@ -0,0 +1,31 @@
+# Gendarme Rules Assemblies
+
+Documentation for each assembly is available on [[Gendarme|http://www.mono-project.com/Gendarme]]'s wiki.
+
+* [[Gendarme.Rules.BadPractice|https://github.com/spouliot/gendarme/wiki/Gendarme.Rules.BadPractice(git)]]
+* [[Gendarme.Rules.Concurrency|https://github.com/spouliot/gendarme/wiki/Gendarme.Rules.Concurrency(git)]]
+* [[Gendarme.Rules.Correctness|https://github.com/spouliot/gendarme/wiki/Gendarme.Rules.Correctness(git)]]
+* [[Gendarme.Rules.Design|https://github.com/spouliot/gendarme/wiki/Gendarme.Rules.Design(git)]]
+* [[Gendarme.Rules.Design.Generic|https://github.com/spouliot/gendarme/wiki/Gendarme.Rules.Design.Generic(git)]]
+* [[Gendarme.Rules.Design.Linq|https://github.com/spouliot/gendarme/wiki/Gendarme.Rules.Design.Linq(git)]]
+* [[Gendarme.Rules.Exceptions|https://github.com/spouliot/gendarme/wiki/Gendarme.Rules.Exceptions(git)]]
+* [[Gendarme.Rules.Gendarme|https://github.com/spouliot/gendarme/wiki/Gendarme.Rules.Gendarme(git)]]
+* [[Gendarme.Rules.Globalization|https://github.com/spouliot/gendarme/wiki/Gendarme.Rules.Globalization(git)]]
+* [[Gendarme.Rules.Interoperability|https://github.com/spouliot/gendarme/wiki/Gendarme.Rules.Interoperability(git)]]
+* [[Gendarme.Rules.Interoperability.Com|https://github.com/spouliot/gendarme/wiki/Gendarme.Rules.Interoperability.Com(git)]]
+* [[Gendarme.Rules.Maintainability|https://github.com/spouliot/gendarme/wiki/Gendarme.Rules.Maintainability(git)]]
+* [[Gendarme.Rules.NUnit|https://github.com/spouliot/gendarme/wiki/Gendarme.Rules.NUnit(git)]]
+* [[Gendarme.Rules.Naming|https://github.com/spouliot/gendarme/wiki/Gendarme.Rules.Naming(git)]]
+* [[Gendarme.Rules.Performance|https://github.com/spouliot/gendarme/wiki/Gendarme.Rules.Performance(git)]]
+* [[Gendarme.Rules.Portability|https://github.com/spouliot/gendarme/wiki/Gendarme.Rules.Portability(git)]]
+* [[Gendarme.Rules.Security|https://github.com/spouliot/gendarme/wiki/Gendarme.Rules.Security(git)]]
+* [[Gendarme.Rules.Security.Cas|https://github.com/spouliot/gendarme/wiki/Gendarme.Rules.Security.Cas(git)]]
+* [[Gendarme.Rules.Serialization|https://github.com/spouliot/gendarme/wiki/Gendarme.Rules.Serialization(git)]]
+* [[Gendarme.Rules.Smells|https://github.com/spouliot/gendarme/wiki/Gendarme.Rules.Smells(git)]]
+* [[Gendarme.Rules.Ui|https://github.com/spouliot/gendarme/wiki/Gendarme.Rules.Ui(git)]]
+
+
+## Feedback
+
+Please report any documentation errors, typos or suggestions to the [[Gendarme Mailing List|https://groups.google.com/forum/?fromgroups#!forum/gendarme]]. Thanks!
+
diff --git a/gendarme/rules/Test.Rules/Makefile.am b/gendarme/rules/Test.Rules/Makefile.am
index 428350d..e3f3ae4 100644
--- a/gendarme/rules/Test.Rules/Makefile.am
+++ b/gendarme/rules/Test.Rules/Makefile.am
@@ -5,7 +5,7 @@ test_SCRIPTS =
 test_DATA = 
 
 framework=../../bin/Gendarme.Framework.dll
-common_tests=../Test.Rules/Test.Rules.dll
+common_tests=Test.Rules.dll
 
 EXTRA_DIST = $(test_sources) Test.Rules.csproj
 CLEANFILES = Test.Rules.dll Test.Rules.dll.mdb $(common_tests)
@@ -24,8 +24,8 @@ test_sources =  \
 
 test_build_sources = $(addprefix $(srcdir)/, $(test_sources))
 
-$(common_tests): $(test_build_sources)
-	$(GMCS) -target:library $(TESTS_OPTIONS) -pkg:mono-nunit -r:$(CECIL_ASM) -r:$(framework) -out:$@ $(test_build_sources)
+$(common_tests): $(test_build_sources) $(framework)
+	$(MCS) -target:library $(TESTS_OPTIONS) -pkg:mono-nunit -r:$(CECIL_ASM) -r:$(framework) -out:$@ $(test_build_sources)
 
 all: $(common_tests)
 
diff --git a/gendarme/rules/Test.Rules/Test.Rules.csproj b/gendarme/rules/Test.Rules/Test.Rules.csproj
index 8da60d8..9ee6d88 100755
--- a/gendarme/rules/Test.Rules/Test.Rules.csproj
+++ b/gendarme/rules/Test.Rules/Test.Rules.csproj
@@ -1,5 +1,5 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
     <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
@@ -10,8 +10,28 @@
     <AppDesignerFolder>Properties</AppDesignerFolder>
     <RootNamespace>Test.Rules</RootNamespace>
     <AssemblyName>Test.Rules</AssemblyName>
-    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
     <FileAlignment>512</FileAlignment>
+    <FileUpgradeFlags>
+    </FileUpgradeFlags>
+    <OldToolsVersion>3.5</OldToolsVersion>
+    <UpgradeBackupLocation />
+    <PublishUrl>publish\</PublishUrl>
+    <Install>true</Install>
+    <InstallFrom>Disk</InstallFrom>
+    <UpdateEnabled>false</UpdateEnabled>
+    <UpdateMode>Foreground</UpdateMode>
+    <UpdateInterval>7</UpdateInterval>
+    <UpdateIntervalUnits>Days</UpdateIntervalUnits>
+    <UpdatePeriodically>false</UpdatePeriodically>
+    <UpdateRequired>false</UpdateRequired>
+    <MapFileExtensions>true</MapFileExtensions>
+    <ApplicationRevision>0</ApplicationRevision>
+    <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
+    <IsWebBootstrapper>false</IsWebBootstrapper>
+    <UseApplicationTrust>false</UseApplicationTrust>
+    <BootstrapperEnabled>true</BootstrapperEnabled>
+    <TargetFrameworkProfile />
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
     <DebugSymbols>true</DebugSymbols>
@@ -21,6 +41,7 @@
     <DefineConstants>DEBUG;TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
     <DebugType>pdbonly</DebugType>
@@ -29,6 +50,7 @@
     <DefineConstants>TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <ItemGroup>
     <Reference Include="nunit.framework, Version=2.4.8.0, Culture=neutral, PublicKeyToken=96d09a1eb7f44a77, processorArchitecture=MSIL">
@@ -61,6 +83,23 @@
       <Name>Gendarme.Framework</Name>
     </ProjectReference>
   </ItemGroup>
+  <ItemGroup>
+    <BootstrapperPackage Include="Microsoft.Net.Client.3.5">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1 Client Profile</ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Windows.Installer.3.1">
+      <Visible>False</Visible>
+      <ProductName>Windows Installer 3.1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+  </ItemGroup>
   <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
   <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
        Other similar extension points exist, see Microsoft.Common.targets.
diff --git a/gendarme/rules/common.make b/gendarme/rules/common.make
index 5e864e4..05eb8dd 100644
--- a/gendarme/rules/common.make
+++ b/gendarme/rules/common.make
@@ -39,13 +39,13 @@ rules_doc = $(rules_doc_zip) $(rules_doc_source) $(rules_doc_tree)
 generated_doc = doc/generated/index.xml
 
 $(rules_dll): $(rules_build_sources) $(framework)
-	$(GMCS) -target:library $(EXTRA_RULES_OPTIONS) -nowarn:1591 -doc:$(rules_dll).doc \
+	$(MCS) -target:library $(EXTRA_RULES_OPTIONS) -nowarn:1591 -doc:$(rules_dll).doc \
 		-r:$(CECIL_ASM) -r:$(framework) -out:$@ $(rules_build_sources)
 
 tests_build_sources = $(addprefix $(srcdir)/Test/, $(tests_sources))
 
 $(tests_dll): $(tests_build_sources) $(rules_dll) $(EXTRA_TESTS_DEPS)
-	$(GMCS) -target:library $(EXTRA_TESTS_OPTIONS) -r:$(CECIL_ASM) -r:$(framework) \
+	$(MCS) -target:library $(EXTRA_TESTS_OPTIONS) -r:$(CECIL_ASM) -r:$(framework) \
 		-r:$(rules_dll) -r:$(common_tests) -pkg:mono-nunit -out:$@ $(tests_build_sources)
 
 rule: $(rules_dll)
@@ -54,7 +54,7 @@ test: $(tests_dll)
 
 run-test: test
 	cp ../../bin/gendarme.exe.config $(tests_dll).config
-	MONO_PATH=../../bin/:../Test.Rules/:$(MONO_PATH) nunit-console2 $(tests_dll)
+	MONO_PATH=../../bin/:../Test.Rules/:$(MONO_PATH) $(prefix)/bin/mono $(prefix)/lib/mono/4.0/nunit-console.exe $(tests_dll)
 
 self-test: $(rules_dll)
 	mono --debug $(console_runner) $(rules_dll)
diff --git a/gendarme/self-test.ignore b/gendarme/self-test.ignore
index 0bf06ca..3daebf3 100644
--- a/gendarme/self-test.ignore
+++ b/gendarme/self-test.ignore
@@ -24,12 +24,14 @@ M: System.Void Gendarme.Rules.Concurrency.DoNotLockOnWeakIdentityObjectsRule::An
 # all > 200 rules expose a Check* method that does not check for null (by contract) but we need code contracts to show this
 M: Gendarme.Framework.RuleResult Gendarme.Rules.BadPractice.AvoidAssemblyVersionMismatchRule::CheckAssembly(Mono.Cecil.AssemblyDefinition)
 M: Gendarme.Framework.RuleResult Gendarme.Rules.BadPractice.AvoidCallingProblematicMethodsRule::CheckMethod(Mono.Cecil.MethodDefinition)
+M: Gendarme.Framework.RuleResult Gendarme.Rules.BadPractice.AvoidNullCheckWithAsOperatorRule::CheckMethod(Mono.Cecil.MethodDefinition)
 M: Gendarme.Framework.RuleResult Gendarme.Rules.BadPractice.AvoidVisibleConstantFieldRule::CheckType(Mono.Cecil.TypeDefinition)
 M: Gendarme.Framework.RuleResult Gendarme.Rules.BadPractice.CheckNewExceptionWithoutThrowingRule::CheckMethod(Mono.Cecil.MethodDefinition)
 M: Gendarme.Framework.RuleResult Gendarme.Rules.BadPractice.CheckNewThreadWithoutStartRule::CheckMethod(Mono.Cecil.MethodDefinition)
 M: Gendarme.Framework.RuleResult Gendarme.Rules.BadPractice.CloneMethodShouldNotReturnNullRule::CheckMethod(Mono.Cecil.MethodDefinition)
 M: Gendarme.Framework.RuleResult Gendarme.Rules.BadPractice.ConstructorShouldNotCallVirtualMethodsRule::CheckType(Mono.Cecil.TypeDefinition)
 M: Gendarme.Framework.RuleResult Gendarme.Rules.BadPractice.DisableDebuggingCodeRule::CheckMethod(Mono.Cecil.MethodDefinition)
+M: Gendarme.Framework.RuleResult Gendarme.Rules.BadPractice.DoNotDecreaseVisibilityRule::CheckMethod(Mono.Cecil.MethodDefinition)
 M: Gendarme.Framework.RuleResult Gendarme.Rules.BadPractice.DoNotForgetNotImplementedMethodsRule::CheckMethod(Mono.Cecil.MethodDefinition)
 M: Gendarme.Framework.RuleResult Gendarme.Rules.BadPractice.DoNotUseEnumIsAssignableFromRule::CheckMethod(Mono.Cecil.MethodDefinition)
 M: Gendarme.Framework.RuleResult Gendarme.Rules.BadPractice.DoNotUseGetInterfaceToCheckAssignabilityRule::CheckMethod(Mono.Cecil.MethodDefinition)
@@ -58,6 +60,7 @@ M: Gendarme.Framework.RuleResult Gendarme.Rules.Correctness.DoNotRecurseInEquali
 M: Gendarme.Framework.RuleResult Gendarme.Rules.Correctness.BadRecursiveInvocationRule::CheckMethod(Mono.Cecil.MethodDefinition)
 M: Gendarme.Framework.RuleResult Gendarme.Rules.Correctness.CallingEqualsWithNullArgRule::CheckMethod(Mono.Cecil.MethodDefinition)
 M: Gendarme.Framework.RuleResult Gendarme.Rules.Correctness.CheckParametersNullityInVisibleMethodsRule::CheckMethod(Mono.Cecil.MethodDefinition)
+M: Gendarme.Framework.RuleResult Gendarme.Rules.Correctness.DeclareEventsExplicitlyRule::CheckType(Mono.Cecil.TypeDefinition)
 M: Gendarme.Framework.RuleResult Gendarme.Rules.Correctness.DisposableFieldsShouldBeDisposedRule::CheckType(Mono.Cecil.TypeDefinition)
 M: Gendarme.Framework.RuleResult Gendarme.Rules.Correctness.DoNotRoundIntegersRule::CheckMethod(Mono.Cecil.MethodDefinition)
 M: Gendarme.Framework.RuleResult Gendarme.Rules.Correctness.EnsureLocalDisposalRule::CheckMethod(Mono.Cecil.MethodDefinition)
@@ -75,6 +78,9 @@ M: Gendarme.Framework.RuleResult Gendarme.Rules.Correctness.ReviewSelfAssignment
 M: Gendarme.Framework.RuleResult Gendarme.Rules.Correctness.ReviewUselessControlFlowRule::CheckMethod(Mono.Cecil.MethodDefinition)
 M: Gendarme.Framework.RuleResult Gendarme.Rules.Correctness.ReviewUseOfInt64BitsToDoubleRule::CheckMethod(Mono.Cecil.MethodDefinition)
 M: Gendarme.Framework.RuleResult Gendarme.Rules.Correctness.ReviewUseOfModuloOneOnIntegersRule::CheckMethod(Mono.Cecil.MethodDefinition)
+M: Gendarme.Framework.RuleResult Gendarme.Rules.Correctness.TypesShouldBeDisposableBaseRule::CheckType(Mono.Cecil.TypeDefinition)
+M: Gendarme.Framework.RuleResult Gendarme.Rules.Correctness.TypesWithDisposableFieldsShouldBeDisposableRule::CheckType(Mono.Cecil.TypeDefinition)
+M: Gendarme.Framework.RuleResult Gendarme.Rules.Correctness.TypesWithNativeFieldsShouldBeDisposableRule::CheckType(Mono.Cecil.TypeDefinition)
 M: Gendarme.Framework.RuleResult Gendarme.Rules.Correctness.UseNoInliningWithGetCallingAssemblyRule::CheckMethod(Mono.Cecil.MethodDefinition)
 M: Gendarme.Framework.RuleResult Gendarme.Rules.Correctness.UseValueInPropertySetterRule::CheckMethod(Mono.Cecil.MethodDefinition)
 M: Gendarme.Framework.RuleResult Gendarme.Rules.Design.AbstractTypesShouldNotHavePublicConstructorsRule::CheckType(Mono.Cecil.TypeDefinition)
@@ -91,6 +97,7 @@ M: Gendarme.Framework.RuleResult Gendarme.Rules.Design.ConsiderConvertingMethodT
 M: Gendarme.Framework.RuleResult Gendarme.Rules.Design.ConsiderUsingStaticTypeRule::CheckType(Mono.Cecil.TypeDefinition)
 M: Gendarme.Framework.RuleResult Gendarme.Rules.Design.DeclareEventHandlersCorrectlyRule::CheckType(Mono.Cecil.TypeDefinition)
 M: Gendarme.Framework.RuleResult Gendarme.Rules.Design.DisposableTypesShouldHaveFinalizerRule::CheckType(Mono.Cecil.TypeDefinition)
+M: Gendarme.Framework.RuleResult Gendarme.Rules.Design.DoNotDeclareSettersOnCollectionPropertiesRule::CheckType(Mono.Cecil.TypeDefinition)
 M: Gendarme.Framework.RuleResult Gendarme.Rules.Design.DoNotDeclareVirtualMethodsInSealedTypeRule::CheckType(Mono.Cecil.TypeDefinition)
 M: Gendarme.Framework.RuleResult Gendarme.Rules.Design.DoNotDeclareProtectedMembersInSealedTypeRule::CheckType(Mono.Cecil.TypeDefinition)
 M: Gendarme.Framework.RuleResult Gendarme.Rules.Design.EnsureSymmetryForOverloadedOperatorsRule::CheckType(Mono.Cecil.TypeDefinition)
@@ -109,8 +116,6 @@ M: Gendarme.Framework.RuleResult Gendarme.Rules.Design.ProvideAlternativeNamesFo
 M: Gendarme.Framework.RuleResult Gendarme.Rules.Design.ProvideTryParseAlternativeRule::CheckType(Mono.Cecil.TypeDefinition)
 M: Gendarme.Framework.RuleResult Gendarme.Rules.Design.StronglyTypedRule::CheckType(Mono.Cecil.TypeDefinition)
 M: Gendarme.Framework.RuleResult Gendarme.Rules.Design.TypesShouldBeInsideNamespacesRule::CheckType(Mono.Cecil.TypeDefinition)
-M: Gendarme.Framework.RuleResult Gendarme.Rules.Design.TypesWithDisposableFieldsShouldBeDisposableRule::CheckType(Mono.Cecil.TypeDefinition)
-M: Gendarme.Framework.RuleResult Gendarme.Rules.Design.TypesWithNativeFieldsShouldBeDisposableRule::CheckType(Mono.Cecil.TypeDefinition)
 M: Gendarme.Framework.RuleResult Gendarme.Rules.Design.UseFlagsAttributeRule::CheckType(Mono.Cecil.TypeDefinition)
 M: Gendarme.Framework.RuleResult Gendarme.Rules.Design.UseCorrectDisposeSignaturesRule::CheckType(Mono.Cecil.TypeDefinition)
 M: Gendarme.Framework.RuleResult Gendarme.Rules.Design.Generic.AvoidExcessiveParametersOnGenericTypesRule::CheckType(Mono.Cecil.TypeDefinition)
@@ -119,9 +124,9 @@ M: Gendarme.Framework.RuleResult Gendarme.Rules.Design.Generic.DoNotDeclareStati
 M: Gendarme.Framework.RuleResult Gendarme.Rules.Design.Generic.DoNotExposeGenericListsRule::CheckType(Mono.Cecil.TypeDefinition)
 M: Gendarme.Framework.RuleResult Gendarme.Rules.Design.Generic.ImplementGenericCollectionInterfacesRule::CheckType(Mono.Cecil.TypeDefinition)
 M: Gendarme.Framework.RuleResult Gendarme.Rules.Design.Generic.PreferGenericsOverRefObjectRule::CheckMethod(Mono.Cecil.MethodDefinition)
-M: Gendarme.Framework.RuleResult Gendarme.Rules.Globalization.SatelliteResourceMismatchRule::CheckAssembly(Mono.Cecil.AssemblyDefinition)
 M: Gendarme.Framework.RuleResult Gendarme.Rules.Exceptions.AvoidArgumentExceptionDefaultConstructorRule::CheckMethod(Mono.Cecil.MethodDefinition)
 M: Gendarme.Framework.RuleResult Gendarme.Rules.Exceptions.DoNotDestroyStackTraceRule::CheckMethod(Mono.Cecil.MethodDefinition)
+M: Gendarme.Framework.RuleResult Gendarme.Rules.Exceptions.DoNotThrowInNonCatchClausesRule::CheckMethod(Mono.Cecil.MethodDefinition)
 M: Gendarme.Framework.RuleResult Gendarme.Rules.Exceptions.DoNotThrowInUnexpectedLocationRule::CheckMethod(Mono.Cecil.MethodDefinition)
 M: Gendarme.Framework.RuleResult Gendarme.Rules.Exceptions.DoNotSwallowErrorsCatchingNonSpecificExceptionsRule::CheckMethod(Mono.Cecil.MethodDefinition)
 M: Gendarme.Framework.RuleResult Gendarme.Rules.Exceptions.ExceptionShouldBeVisibleRule::CheckType(Mono.Cecil.TypeDefinition)
@@ -132,6 +137,8 @@ M: Gendarme.Framework.RuleResult Gendarme.Rules.Gendarme.DefectsMustBeReportedRu
 M: Gendarme.Framework.RuleResult Gendarme.Rules.Gendarme.DoNotThrowExceptionRule::CheckMethod(Mono.Cecil.MethodDefinition)
 M: Gendarme.Framework.RuleResult Gendarme.Rules.Gendarme.MissingEngineDependencyRule::CheckType(Mono.Cecil.TypeDefinition)
 M: Gendarme.Framework.RuleResult Gendarme.Rules.Gendarme.UseCorrectSuffixRule::CheckType(Mono.Cecil.TypeDefinition)
+M: Gendarme.Framework.RuleResult Gendarme.Rules.Globalization.PreferOverrideBaseRule::CheckMethod(Mono.Cecil.MethodDefinition)
+M: Gendarme.Framework.RuleResult Gendarme.Rules.Globalization.SatelliteResourceMismatchRule::CheckAssembly(Mono.Cecil.AssemblyDefinition)
 M: Gendarme.Framework.RuleResult Gendarme.Rules.Interoperability.CentralizePInvokesIntoNativeMethodsTypeRule::CheckType(Mono.Cecil.TypeDefinition)
 M: Gendarme.Framework.RuleResult Gendarme.Rules.Interoperability.CentralizePInvokesIntoNativeMethodsTypeRule::CheckMethod(Mono.Cecil.MethodDefinition)
 M: Gendarme.Framework.RuleResult Gendarme.Rules.Interoperability.DelegatesPassedToNativeCodeMustIncludeExceptionHandlingRule::CheckMethod(Mono.Cecil.MethodDefinition)
@@ -279,6 +286,7 @@ M: System.Void Gendarme.Rules.Concurrency.DoNotLockOnWeakIdentityObjectsRule::An
 # different code path / switch
 M: System.Void Gendarme.Rules.Correctness.ProvideValidXmlStringRule::CheckCall(Mono.Cecil.MethodDefinition,Mono.Cecil.Cil.Instruction,Mono.Cecil.MethodReference)
 M: System.Void Gendarme.Rules.Correctness.ProvideValidXPathExpressionRule::CheckCall(Mono.Cecil.MethodDefinition,Mono.Cecil.Cil.Instruction,Mono.Cecil.MethodReference)
+M: System.Boolean Gendarme.Rules.Concurrency.DoNotLockOnWeakIdentityObjectsRule::IsWeakSealedType(Mono.Cecil.TypeReference)
 
 # mono bug wrt metatoken id with generics
 R: Gendarme.Rules.Performance.AvoidUncalledPrivateCodeRule
@@ -298,7 +306,7 @@ M: Gendarme.Framework.RuleResult Gendarme.Rules.Design.AvoidSmallNamespaceRule::
 M: System.Void Gendarme.Rules.Design.AvoidSmallNamespaceRule::TearDown()
 M: Gendarme.Framework.RuleResult Gendarme.Rules.Design.InternalNamespacesShouldNotExposeTypesRule::CheckAssembly(Mono.Cecil.AssemblyDefinition)
 M: System.Void Gendarme.Rules.Interoperability.Com.MarkComSourceInterfacesAsIDispatchRule::FindInterfaces()
-M: System.Boolean Gendarme.Rules.Smells.AvoidSpeculativeGeneralityRule::HasExpectedInheritedTypeCount(Mono.Cecil.MemberReference,System.Int32)
+M: System.Boolean Gendarme.Rules.Smells.AvoidSpeculativeGeneralityRule::HasExpectedInheritedTypeCount(Mono.Cecil.TypeReference,System.Int32)
 M: System.Void Gendarme.XmlResultWriter::CreateDefects()
 M: System.Boolean Gendarme.Wizard::UpdateActiveRules()
 M: System.Void Gendarme.Framework.Engines.SuppressMessageEngine::AddIgnore(Mono.Cecil.IMetadataTokenProvider,System.Collections.Generic.IEnumerable`1<System.String>)
@@ -344,6 +352,9 @@ T: Gendarme.Rules.Performance.ReviewLinqMethodRule
 T: Gendarme.Rules.Design.StronglyTypedRule
 # 2.8+
 M: System.String Gendarme.Rules.Maintainability.PreferStringIsNullOrEmptyRule::GetName(Mono.Cecil.MethodDefinition,Mono.Cecil.Cil.Instruction)
+# ParseSeverity(System.String) and ParseConfidence(System.String) are very similar
+T: Gendarme.ConsoleRunner
+
 R: Gendarme.Rules.Smells.AvoidCodeDuplicatedInSiblingClassesRule
 M: Gendarme.Framework.RuleResult Gendarme.Rules.Correctness.AvoidFloatingPointEqualityRule::CheckMethod(Mono.Cecil.MethodDefinition)
 # CheckType and GetEngineDependencyValue
@@ -354,6 +365,7 @@ T: Gendarme.Rules.Gendarme.GendarmeRule
 R: Gendarme.Rules.Smells.AvoidSpeculativeGeneralityRule
 T: Gendarme.Framework.EngineController
 T: Gendarme.Framework.Helpers.MethodSignatures
+T: Gendarme.Framework.Rocks.ParameterRocks
 
 # FIXME - note: some seems to be related to an xMCS bug
 R: Gendarme.Rules.Performance.AvoidMethodWithLargeMaximumStackSizeRule
@@ -414,6 +426,7 @@ R: Gendarme.Rules.Maintainability.AvoidUnnecessarySpecializationRule
 M: System.Boolean Gendarme.Rules.Interoperability.Com.ComRocks::IsTypeComVisible(Mono.Cecil.TypeDefinition)
 M: System.Boolean Gendarme.Rules.Performance.AvoidUnnecessaryOverridesRule::IsBase(Mono.Cecil.MethodReference,Mono.Cecil.MethodReference)
 M: System.Boolean Gendarme.Rules.Correctness.BadRecursiveInvocationRule::CompareMethods(Mono.Cecil.MethodReference,Mono.Cecil.MethodReference,System.Boolean)
+M: System.Boolean Gendarme.Rules.Naming.ParameterNamesShouldMatchOverriddenMethodRule::SignatureMatches(Mono.Cecil.MethodReference,Mono.Cecil.MethodReference,System.Boolean)
 
 # ---------------------------------------------------------
 # These are all OK.
@@ -458,11 +471,6 @@ M: Gendarme.Framework.RuleResult Gendarme.Rules.Interoperability.DelegatesPassed
 # FIXME the last one needs validation
 M: System.Boolean Gendarme.Wizard::CouldCopyReport(System.String&,System.String)
 
-# OK - Version and Guid sadly do not provide a TryParse method (at least they did not before FX4.0 - FIXME once we update)
-R: Gendarme.Rules.Performance.DoNotIgnoreMethodResultRule
-M: System.Boolean Gendarme.Rules.Correctness.AttributeStringLiteralsShouldParseCorrectlyRule::TryParseVersion(System.String)
-M: System.Boolean Gendarme.Rules.Correctness.AttributeStringLiteralsShouldParseCorrectlyRule::TryParseGuid(System.String)
-
 # OK - MethodSignatures use the CLR names for operators that starts with "op_"
 R: Gendarme.Rules.Naming.AvoidNonAlphanumericIdentifierRule
 T: Gendarme.Framework.Helpers.MethodSignatures
@@ -527,12 +535,6 @@ R: Gendarme.Rules.Smells.AvoidCodeDuplicatedInSameClassRule
 # OK - (CSC only) GetLoadSlot and GetStoreSlot are identical except for the switch/case (load versus store instructions) - delegating calls won't change defect
 T: Gendarme.Framework.Helpers.StackEntryAnalysis
 
-# FX4 related - will be fixed once we move to FX4 (likely for Gendarme 3.0)
-R: Gendarme.Rules.Maintainability.AvoidUnnecessarySpecializationRule
-# use ISet<H>
-M: System.Void Gendarme.Rules.Performance.AvoidUninstantiatedInternalClassesRule::AddType(System.Collections.Generic.HashSet`1<Mono.Cecil.TypeReference>,Mono.Cecil.TypeReference)
-M: System.Void Gendarme.Rules.Performance.AvoidUncalledPrivateCodeRule::BuildMethodUsage(System.Collections.Generic.HashSet`1<System.UInt32>,Mono.Cecil.MethodDefinition)
-
 # OK
 R: Gendarme.Rules.Naming.AvoidRedundancyInTypeNameRule
 # ComRocks is not directly used
@@ -566,3 +568,12 @@ T: Gendarme.Rules.UI.GtkSharpExecutableTargetRule
 # OK - Gendarme.Framework.Rule may throw exceptions as it is not a real rule
 R: Gendarme.Rules.Gendarme.DoNotThrowExceptionRule
 T: Gendarme.Framework.Rule
+
+# Type::op_[Ine|e]quality is new and marked as MonoTODO but it does (at least) the same job as the earlier FX provided
+R: Gendarme.Rules.Portability.MonoCompatibilityReviewRule
+M: System.Void Gendarme.Framework.Rocks.ModuleRocks::LoadDebuggingSymbols(Mono.Cecil.ModuleDefinition)
+M: System.Void Gendarme.Framework.Rocks.ModuleRocks::.cctor()
+M: System.Void Gendarme.Framework.EngineDependencyAttribute::.ctor(System.Type)
+M: System.Type Gendarme.Framework.Rule::get_Type()
+M: System.Security.IPermission Gendarme.Rules.Security.Cas.SecurityDeclarationRocks::CreatePermission(Mono.Cecil.SecurityDeclaration,Mono.Cecil.SecurityAttribute)
+
diff --git a/gendarme/swf-wizard-runner/GuiRunner.cs b/gendarme/swf-wizard-runner/GuiRunner.cs
index 385406e..b34d5cb 100644
--- a/gendarme/swf-wizard-runner/GuiRunner.cs
+++ b/gendarme/swf-wizard-runner/GuiRunner.cs
@@ -28,6 +28,7 @@
 
 using System;
 using System.Collections.Generic;
+using System.Globalization;
 using System.IO;
 using System.Reflection;
 using System.Text;
@@ -110,11 +111,11 @@ namespace Gendarme {
 				TearDown ();
 			}
 			catch (Exception e) {
-				if (CurrentRule != null)
-					unexpected.AppendFormat ("Rule:\t{0}{1}{1}", CurrentRule, Environment.NewLine);
+				if (CurrentRule != null) 
+					unexpected.Append ("Rule:\t").Append (CurrentRule).AppendLine ().AppendLine ();
 				if (CurrentTarget != null)
-					unexpected.AppendFormat ("Target:\t{0}{1}{1}", CurrentTarget, Environment.NewLine);
-				unexpected.AppendFormat ("Stack trace: {0}", e);
+					unexpected.Append ("Target:\t").Append (CurrentTarget).AppendLine ().AppendLine ();
+				unexpected.Append ("Stack trace: ").Append (e);
 			}
 		}
 
diff --git a/gendarme/swf-wizard-runner/Properties/Resources.Designer.cs b/gendarme/swf-wizard-runner/Properties/Resources.Designer.cs
old mode 100644
new mode 100755
index c588026..9a1518f
--- a/gendarme/swf-wizard-runner/Properties/Resources.Designer.cs
+++ b/gendarme/swf-wizard-runner/Properties/Resources.Designer.cs
@@ -1,7 +1,7 @@
-﻿//------------------------------------------------------------------------------
+//------------------------------------------------------------------------------
 // <auto-generated>
 //     This code was generated by a tool.
-//     Runtime Version:2.0.50727.1433
+//     Runtime Version:4.0.30319.1
 //
 //     Changes to this file may cause incorrect behavior and will be lost if
 //     the code is regenerated.
@@ -19,7 +19,7 @@ namespace Gendarme.Properties {
     // class via a tool like ResGen or Visual Studio.
     // To add or remove a member, edit your .ResX file then rerun ResGen
     // with the /str option, or rebuild your VS project.
-    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "2.0.0.0")]
+    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
     [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
     [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
     internal class Resources {
diff --git a/gendarme/swf-wizard-runner/Properties/Settings.Designer.cs b/gendarme/swf-wizard-runner/Properties/Settings.Designer.cs
old mode 100644
new mode 100755
index c7479ed..ad7c2d2
--- a/gendarme/swf-wizard-runner/Properties/Settings.Designer.cs
+++ b/gendarme/swf-wizard-runner/Properties/Settings.Designer.cs
@@ -1,7 +1,7 @@
 //------------------------------------------------------------------------------
 // <auto-generated>
 //     This code was generated by a tool.
-//     Runtime Version:2.0.50727.3053
+//     Runtime Version:4.0.30319.1
 //
 //     Changes to this file may cause incorrect behavior and will be lost if
 //     the code is regenerated.
@@ -12,7 +12,7 @@ namespace Gendarme.Properties {
     
     
     [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
-    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "9.0.0.0")]
+    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "10.0.0.0")]
     internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase {
         
         private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));
diff --git a/gendarme/swf-wizard-runner/Wizard.Designer.cs b/gendarme/swf-wizard-runner/Wizard.Designer.cs
index c92554a..9977480 100644
--- a/gendarme/swf-wizard-runner/Wizard.Designer.cs
+++ b/gendarme/swf-wizard-runner/Wizard.Designer.cs
@@ -146,7 +146,7 @@ namespace Gendarme {
 			this.label1.Padding = new System.Windows.Forms.Padding (12, 0, 0, 1);
 			this.label1.Size = new System.Drawing.Size (265, 14);
 			this.label1.TabIndex = 1;
-			this.label1.Text = "Copyright © 2005-2010 Novell, Inc. and contributors";
+			this.label1.Text = "Copyright © 2005-2011 Novell, Inc. and contributors";
 			// 
 			// welcome_link_label
 			// 
diff --git a/gendarme/swf-wizard-runner/Wizard.cs b/gendarme/swf-wizard-runner/Wizard.cs
index 0739ca1..7465b19 100644
--- a/gendarme/swf-wizard-runner/Wizard.cs
+++ b/gendarme/swf-wizard-runner/Wizard.cs
@@ -30,6 +30,7 @@ using System;
 using System.Collections.Specialized;
 using System.Collections.Generic;
 using System.Diagnostics;
+using System.Globalization;
 using System.IO;
 using System.Windows.Forms;
 
@@ -98,7 +99,7 @@ namespace Gendarme {
 			if ((v.Major == 0) && (v.Minor == 0))
 				welcome_gendarme_label.Text = "Gendarme (development snapshot)";
 			else
-				welcome_gendarme_label.Text = String.Format ("Gendarme, version {0}", v);
+				welcome_gendarme_label.Text = String.Format (CultureInfo.CurrentCulture, "Gendarme, version {0}", v);
 
 			assembly_loader = UpdateAssemblies;
 
@@ -265,7 +266,7 @@ namespace Gendarme {
 			next_button.Enabled = has_files;
 			remove_file_button.Enabled = has_files;
 			if (has_files) {
-				add_files_count_label.Text = String.Format ("{0} assembl{1} selected",
+				add_files_count_label.Text = String.Format (CultureInfo.CurrentCulture, "{0} assembl{1} selected",
 					files_count, files_count == 1 ? "y" : "ies");
 			} else {
 				add_files_count_label.Text = "No assembly selected.";
@@ -344,7 +345,8 @@ namespace Gendarme {
 			// asynchronously load assemblies (or the one that changed)
 			assemblies_loading = assembly_loader.BeginInvoke (EndCallback, assembly_loader);
 
-			rules_count_label.Text = String.Format ("{0} rules are available.", Runner.Rules.Count);
+			rules_count_label.Text = String.Format (CultureInfo.CurrentCulture, 
+				"{0} rules are available.", Runner.Rules.Count);
 			if (rules_loading == null)
 				throw new InvalidOperationException ("rules_loading");
 
@@ -390,7 +392,8 @@ namespace Gendarme {
 					parent.Checked = true;
 			}
 			foreach (TreeNode node in rules_tree_view.Nodes) {
-				node.ToolTipText = String.Format ("{0} rules available", node.Nodes.Count);
+				node.ToolTipText = String.Format (CultureInfo.CurrentCulture,
+					"{0} rules available", node.Nodes.Count);
 			}
 			nodes.Clear ();
 			rules_tree_view.AfterCheck += RulesTreeViewAfterCheck;
@@ -527,8 +530,8 @@ namespace Gendarme {
 			// update UI before waiting for assemblies to be loaded
 			progress_bar.Value = 0;
 			next_button.Enabled = false;
-			analyze_status_label.Text = String.Format ("Processing assembly 1 of {0}",
-				assemblies.Count);
+			analyze_status_label.Text = String.Format (CultureInfo.CurrentCulture,
+				"Processing assembly 1 of {0}", assemblies.Count);
 			analyze_defect_label.Text = "Defects Found: 0";
 			// make sure all assemblies are loaded into memory
 			assemblies_loading.AsyncWaitHandle.WaitOne ();
@@ -597,7 +600,8 @@ namespace Gendarme {
 
 		private bool ConfirmAnalyzeAbort (bool quit)
 		{
-			string message = String.Format ("Abort the current analysis being executed {0}Gendarme ?",
+			string message = String.Format (CultureInfo.CurrentCulture,
+				"Abort the current analysis being executed {0}Gendarme ?",
 				quit ? "and quit " : String.Empty);
 			return (MessageBox.Show (this, message, "Gendarme", MessageBoxButtons.YesNo, MessageBoxIcon.Question,
 				MessageBoxDefaultButton.Button2) == DialogResult.Yes);
@@ -610,7 +614,8 @@ namespace Gendarme {
 		internal void PreAssemblyUpdate (RunnerEventArgs e)
 		{
 			progress_bar.Value = counter++;
-			analyze_status_label.Text = String.Format ("Processing assembly {0} of {1}",
+			analyze_status_label.Text = String.Format (CultureInfo.CurrentCulture,
+				"Processing assembly {0} of {1}",
 				counter, e.Runner.Assemblies.Count);
 			analyze_assembly_label.Text = "Assembly: " + e.CurrentAssembly.Name.FullName;
 		}
@@ -621,7 +626,8 @@ namespace Gendarme {
 		/// <param name="e">RunnerEventArgs that contains the Assembly being analyzed and the Runner</param>
 		internal void PostTypeUpdate (RunnerEventArgs e)
 		{
-			analyze_defect_label.Text = String.Format ("Defects Found: {0}", e.Runner.Defects.Count);
+			analyze_defect_label.Text = String.Format (CultureInfo.CurrentCulture, 
+				"Defects Found: {0}", e.Runner.Defects.Count);
 		}
 
 		#endregion
@@ -633,8 +639,9 @@ namespace Gendarme {
 			bool has_defects = (Runner.Defects.Count > 0);
 			save_report_button.Enabled = has_defects;
 			view_report_button.Enabled = has_defects;
-			report_subtitle_label.Text = String.Format ("Gendarme has found {0} defects during analysis.",
-				has_defects ? Runner.Defects.Count.ToString () : "no");
+			report_subtitle_label.Text = String.Format (CultureInfo.CurrentCulture,
+				"Gendarme has found {0} defects during analysis.",
+				has_defects ? Runner.Defects.Count.ToString (CultureInfo.CurrentCulture) : "no");
 			cancel_button.Text = "Close";
 			next_button.Enabled = false;
 
diff --git a/gendarme/swf-wizard-runner/swf-wizard-runner.csproj b/gendarme/swf-wizard-runner/swf-wizard-runner.csproj
index b54da3b..4f52a11 100644
--- a/gendarme/swf-wizard-runner/swf-wizard-runner.csproj
+++ b/gendarme/swf-wizard-runner/swf-wizard-runner.csproj
@@ -1,5 +1,5 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
     <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
@@ -10,9 +10,29 @@
     <AppDesignerFolder>Properties</AppDesignerFolder>
     <RootNamespace>Gendarme</RootNamespace>
     <AssemblyName>GendarmeWizard</AssemblyName>
-    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
     <FileAlignment>512</FileAlignment>
     <ApplicationIcon>Resources\gendarme.ico</ApplicationIcon>
+    <FileUpgradeFlags>
+    </FileUpgradeFlags>
+    <OldToolsVersion>3.5</OldToolsVersion>
+    <UpgradeBackupLocation />
+    <PublishUrl>publish\</PublishUrl>
+    <Install>true</Install>
+    <InstallFrom>Disk</InstallFrom>
+    <UpdateEnabled>false</UpdateEnabled>
+    <UpdateMode>Foreground</UpdateMode>
+    <UpdateInterval>7</UpdateInterval>
+    <UpdateIntervalUnits>Days</UpdateIntervalUnits>
+    <UpdatePeriodically>false</UpdatePeriodically>
+    <UpdateRequired>false</UpdateRequired>
+    <MapFileExtensions>true</MapFileExtensions>
+    <ApplicationRevision>0</ApplicationRevision>
+    <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
+    <IsWebBootstrapper>false</IsWebBootstrapper>
+    <UseApplicationTrust>false</UseApplicationTrust>
+    <BootstrapperEnabled>true</BootstrapperEnabled>
+    <TargetFrameworkProfile />
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
     <DebugSymbols>true</DebugSymbols>
@@ -22,6 +42,7 @@
     <DefineConstants>DEBUG;TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
     <DebugType>pdbonly</DebugType>
@@ -30,6 +51,7 @@
     <DefineConstants>TRACE;RELEASE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <ItemGroup>
     <Reference Include="System" />
@@ -39,7 +61,7 @@
     <Reference Include="System.Drawing" />
     <Reference Include="System.Windows.Forms" />
     <Reference Include="System.Xml" />
-    <Reference Include="System.Xml.Linq, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089, processorArchitecture=MSIL" />
+    <Reference Include="System.Xml.Linq" />
   </ItemGroup>
   <ItemGroup>
     <Compile Include="..\AssemblyStaticInfo.cs" />
@@ -50,6 +72,16 @@
     <Compile Include="..\console\XmlResultWriter.cs" />
     <Compile Include="GuiRunner.cs" />
     <Compile Include="Page.cs" />
+    <Compile Include="Properties\Resources.Designer.cs">
+      <AutoGen>True</AutoGen>
+      <DesignTime>True</DesignTime>
+      <DependentUpon>Resources.resx</DependentUpon>
+    </Compile>
+    <Compile Include="Properties\Settings.Designer.cs">
+      <AutoGen>True</AutoGen>
+      <DesignTimeSharedInput>True</DesignTimeSharedInput>
+      <DependentUpon>Settings.settings</DependentUpon>
+    </Compile>
     <Compile Include="Wizard.cs">
       <SubType>Form</SubType>
     </Compile>
@@ -64,16 +96,12 @@
     <EmbeddedResource Include="Properties\Resources.resx">
       <SubType>Designer</SubType>
       <Generator>ResXFileCodeGenerator</Generator>
+      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
     </EmbeddedResource>
-    <Compile Include="Properties\Resources.Designer.cs">
-      <DependentUpon>Resources.resx</DependentUpon>
-    </Compile>
     <None Include="Properties\Settings.settings">
       <Generator>SettingsSingleFileGenerator</Generator>
+      <LastGenOutput>Settings.Designer.cs</LastGenOutput>
     </None>
-    <Compile Include="Properties\Settings.Designer.cs">
-      <DependentUpon>Settings.settings</DependentUpon>
-    </Compile>
     <EmbeddedResource Include="..\console\gendarme.xsl" />
     <None Include="Resources\gendarme.png" />
   </ItemGroup>
@@ -90,6 +118,23 @@
   <ItemGroup>
     <Content Include="Resources\gendarme.ico" />
   </ItemGroup>
+  <ItemGroup>
+    <BootstrapperPackage Include="Microsoft.Net.Client.3.5">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1 Client Profile</ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Windows.Installer.3.1">
+      <Visible>False</Visible>
+      <ProductName>Windows Installer 3.1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+  </ItemGroup>
   <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
   <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
        Other similar extension points exist, see Microsoft.Common.targets.
diff --git a/gendarme/tools/supported/Makefile.am b/gendarme/tools/supported/Makefile.am
index 4f8f0a9..8590cf2 100644
--- a/gendarme/tools/supported/Makefile.am
+++ b/gendarme/tools/supported/Makefile.am
@@ -1,2 +1,2 @@
-SUBDIRS = gd2i
+SUBDIRS = gd2i templates
 
diff --git a/gendarme/tools/supported/gd2i/Makefile.am b/gendarme/tools/supported/gd2i/Makefile.am
index 0ad49f3..c698ed5 100644
--- a/gendarme/tools/supported/gd2i/Makefile.am
+++ b/gendarme/tools/supported/gd2i/Makefile.am
@@ -12,7 +12,7 @@ gd2i_sources =  \
 	gd2i.cs
 
 $(gd2i_SCRIPTS):  $(gd2i_sources)
-	$(GMCS) -d:CODE_ANALYSIS -debug $^ -out:$@
+	$(MCS) -d:CODE_ANALYSIS -debug $^ -out:$@
 
 update: $(gd2i_SCRIPTS)
 	mono --debug $(gd2i_SCRIPTS) ../../../bin/self-test.xml ../../../self-test.ignore
diff --git a/gendarme/tools/supported/gd2i/gd2i.csproj b/gendarme/tools/supported/gd2i/gd2i.csproj
index ec2aa2d..84105de 100644
--- a/gendarme/tools/supported/gd2i/gd2i.csproj
+++ b/gendarme/tools/supported/gd2i/gd2i.csproj
@@ -1,60 +1,99 @@
-<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <PropertyGroup>
-    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
-    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
-    <ProductVersion>9.0.30729</ProductVersion>
-    <SchemaVersion>2.0</SchemaVersion>
-    <ProjectGuid>{627AA224-D043-4CF4-A783-72546E6ACFDD}</ProjectGuid>
-    <OutputType>Exe</OutputType>
-    <AppDesignerFolder>Properties</AppDesignerFolder>
-    <RootNamespace>gd2i</RootNamespace>
-    <AssemblyName>gd2i</AssemblyName>
-    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
-    <FileAlignment>512</FileAlignment>
-  </PropertyGroup>
-  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
-    <DebugSymbols>true</DebugSymbols>
-    <DebugType>full</DebugType>
-    <Optimize>false</Optimize>
-    <OutputPath>bin\Debug\</OutputPath>
-    <DefineConstants>TRACE;DEBUG;CODE_ANALYSIS</DefineConstants>
-    <ErrorReport>prompt</ErrorReport>
-    <WarningLevel>4</WarningLevel>
-  </PropertyGroup>
-  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
-    <DebugType>pdbonly</DebugType>
-    <Optimize>true</Optimize>
-    <OutputPath>bin\Release\</OutputPath>
-    <DefineConstants>TRACE</DefineConstants>
-    <ErrorReport>prompt</ErrorReport>
-    <WarningLevel>4</WarningLevel>
-  </PropertyGroup>
-  <ItemGroup>
-    <Reference Include="System" />
-    <Reference Include="System.Core">
-      <RequiredTargetFramework>3.5</RequiredTargetFramework>
-    </Reference>
-    <Reference Include="System.Xml" />
-  </ItemGroup>
-  <ItemGroup>
-    <Compile Include="..\..\..\AssemblyStaticInfo.cs">
-      <Link>AssemblyStaticInfo.cs</Link>
-    </Compile>
-    <Compile Include="..\..\..\console\Options.cs">
-      <Link>Options.cs</Link>
-    </Compile>
-    <Compile Include="gd2i.cs" />
-  </ItemGroup>
-  <ItemGroup>
-    <Folder Include="Properties\" />
-  </ItemGroup>
-  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
+    <ProductVersion>9.0.30729</ProductVersion>
+    <SchemaVersion>2.0</SchemaVersion>
+    <ProjectGuid>{627AA224-D043-4CF4-A783-72546E6ACFDD}</ProjectGuid>
+    <OutputType>Exe</OutputType>
+    <AppDesignerFolder>Properties</AppDesignerFolder>
+    <RootNamespace>gd2i</RootNamespace>
+    <AssemblyName>gd2i</AssemblyName>
+    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
+    <FileAlignment>512</FileAlignment>
+    <FileUpgradeFlags>
+    </FileUpgradeFlags>
+    <OldToolsVersion>3.5</OldToolsVersion>
+    <UpgradeBackupLocation />
+    <PublishUrl>publish\</PublishUrl>
+    <Install>true</Install>
+    <InstallFrom>Disk</InstallFrom>
+    <UpdateEnabled>false</UpdateEnabled>
+    <UpdateMode>Foreground</UpdateMode>
+    <UpdateInterval>7</UpdateInterval>
+    <UpdateIntervalUnits>Days</UpdateIntervalUnits>
+    <UpdatePeriodically>false</UpdatePeriodically>
+    <UpdateRequired>false</UpdateRequired>
+    <MapFileExtensions>true</MapFileExtensions>
+    <ApplicationRevision>0</ApplicationRevision>
+    <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
+    <IsWebBootstrapper>false</IsWebBootstrapper>
+    <UseApplicationTrust>false</UseApplicationTrust>
+    <BootstrapperEnabled>true</BootstrapperEnabled>
+    <TargetFrameworkProfile />
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
+    <DebugSymbols>true</DebugSymbols>
+    <DebugType>full</DebugType>
+    <Optimize>false</Optimize>
+    <OutputPath>bin\Debug\</OutputPath>
+    <DefineConstants>TRACE;DEBUG;CODE_ANALYSIS</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
+    <DebugType>pdbonly</DebugType>
+    <Optimize>true</Optimize>
+    <OutputPath>bin\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
+  </PropertyGroup>
+  <ItemGroup>
+    <Reference Include="System" />
+    <Reference Include="System.Core">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+    <Reference Include="System.Xml" />
+  </ItemGroup>
+  <ItemGroup>
+    <Compile Include="..\..\..\AssemblyStaticInfo.cs">
+      <Link>AssemblyStaticInfo.cs</Link>
+    </Compile>
+    <Compile Include="..\..\..\console\Options.cs">
+      <Link>Options.cs</Link>
+    </Compile>
+    <Compile Include="gd2i.cs" />
+  </ItemGroup>
+  <ItemGroup>
+    <Folder Include="Properties\" />
+  </ItemGroup>
+  <ItemGroup>
+    <BootstrapperPackage Include="Microsoft.Net.Client.3.5">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1 Client Profile</ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Windows.Installer.3.1">
+      <Visible>False</Visible>
+      <ProductName>Windows Installer 3.1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+  </ItemGroup>
+  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
   <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
        Other similar extension points exist, see Microsoft.Common.targets.
   <Target Name="BeforeBuild">
   </Target>
   <Target Name="AfterBuild">
   </Target>
-  -->
+  -->
 </Project>
\ No newline at end of file
diff --git a/gendarme/tools/supported/templates/.gitignore b/gendarme/tools/supported/templates/.gitignore
new file mode 100644
index 0000000..c4c4ffc
--- /dev/null
+++ b/gendarme/tools/supported/templates/.gitignore
@@ -0,0 +1 @@
+*.zip
diff --git a/gendarme/tools/supported/templates/AssemblyRule.cs b/gendarme/tools/supported/templates/AssemblyRule.cs
new file mode 100644
index 0000000..80e77c1
--- /dev/null
+++ b/gendarme/tools/supported/templates/AssemblyRule.cs
@@ -0,0 +1,65 @@
+// 
+// $rootnamespace$.$safeitemname$
+//
+// Authors:
+//	$name$ <$email$>
+//
+// Copyright (C) $year$ $name$
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+using System;
+
+using Mono.Cecil;
+using Mono.Cecil.Cil;
+
+using Gendarme.Framework;
+using Gendarme.Framework.Engines;
+using Gendarme.Framework.Helpers;
+using Gendarme.Framework.Rocks;
+
+namespace $rootnamespace$ {
+
+	/// <summary>
+	/// TODO: Add a summary of the rule.
+	/// </summary>
+	/// <example>
+	/// Bad example:
+	/// <code>
+	/// TODO: Add an example where the rule would fail.
+	/// </code>
+	/// </example>
+	/// <example>
+	/// Good example:
+	/// <code>
+	/// TODO: Show how to fix the bad example.
+	/// </code>
+	/// </example>
+
+	// TODO: Describe the problem and solution
+	[Problem ("")]
+	[Solution ("")]
+	public class $safeitemname$ : Rule, IAssemblyRule {
+		public RuleResult CheckAssembly (AssemblyDefinition assembly)
+		{
+			// TODO: Write the rule.
+			return RuleResult.Success;
+		}
+	}
+}
diff --git a/gendarme/tools/supported/templates/AssemblyRule.vstemplate b/gendarme/tools/supported/templates/AssemblyRule.vstemplate
new file mode 100644
index 0000000..9715194
--- /dev/null
+++ b/gendarme/tools/supported/templates/AssemblyRule.vstemplate
@@ -0,0 +1,24 @@
+<VSTemplate Version="3.0.0" xmlns="http://schemas.microsoft.com/developer/vstemplate/2005" Type="Item">
+  <TemplateData>
+    <DefaultName>Assembly Rule.cs</DefaultName>
+    <Name>Assembly Rule</Name>
+    <Description>A gendarme rule that checks an assembly.</Description>
+    <ProjectType>CSharp</ProjectType>
+    <SortOrder>10</SortOrder>
+    <Icon>__TemplateIcon.ico</Icon>
+  </TemplateData>
+  <TemplateContent>
+    <References>
+      <Reference>
+        <Assembly>Mono.Cecil</Assembly>
+      </Reference>
+      <Reference>
+        <Assembly>Gendarme.Framework</Assembly>
+      </Reference>
+      <Reference>
+        <Assembly>System.Core</Assembly>
+      </Reference>
+    </References>
+    <ProjectItem SubType="Code" TargetFileName="$fileinputname$.cs" ReplaceParameters="true">AssemblyRule.cs</ProjectItem>
+  </TemplateContent>
+</VSTemplate>
\ No newline at end of file
diff --git a/gendarme/tools/supported/templates/AssemblyTest.cs b/gendarme/tools/supported/templates/AssemblyTest.cs
new file mode 100644
index 0000000..77d5c06
--- /dev/null
+++ b/gendarme/tools/supported/templates/AssemblyTest.cs
@@ -0,0 +1,64 @@
+// 
+// $rootnamespace$.$safeitemname$
+//
+// Authors:
+//	$name$ <$email$>
+//
+// Copyright (C) $year$ $name$
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+using System;
+using System.Reflection;
+
+using Mono.Cecil;
+// TODO: Add using for the project of the rule being tested.
+// using Gendarme.Rules. ;
+
+using NUnit.Framework;
+using Test.Rules.Fixtures;
+using Test.Rules.Helpers;
+using Test.Rules.Definitions;
+
+namespace $rootnamespace$ {
+
+	[TestFixture]
+	public class $safeitemname$ : AssemblyRuleTestFixture</* TODO: Add rule's type */> {
+		[Test]
+		public void DoesNotApply ()
+		{
+			// TODO: Write tests that don't apply.
+			// AssertRuleDoesNotApply (assembly);
+		}
+
+		[Test]
+		public void Good ()
+		{
+			// TODO: Write tests that should succeed.
+			// AssertRuleSuccess (assembly);
+		}
+
+		[Test]
+		public void Bad ()
+		{
+			// TODO: Write tests that should fail.
+			// AssertRuleFailure (assembly);
+		}
+	}
+}
diff --git a/gendarme/tools/supported/templates/AssemblyTest.vstemplate b/gendarme/tools/supported/templates/AssemblyTest.vstemplate
new file mode 100644
index 0000000..9c8c0f0
--- /dev/null
+++ b/gendarme/tools/supported/templates/AssemblyTest.vstemplate
@@ -0,0 +1,27 @@
+<VSTemplate Version="3.0.0" xmlns="http://schemas.microsoft.com/developer/vstemplate/2005" Type="Item">
+  <TemplateData>
+    <DefaultName>Assembly Rule Test.cs</DefaultName>
+    <Name>Assembly Rule Test</Name>
+    <Description>A unit test for a gendarme assembly rule.</Description>
+    <ProjectType>CSharp</ProjectType>
+    <SortOrder>10</SortOrder>
+    <Icon>__TemplateIcon.ico</Icon>
+  </TemplateData>
+  <TemplateContent>
+    <References>
+      <Reference>
+        <Assembly>Mono.Cecil</Assembly>
+      </Reference>
+      <Reference>
+        <Assembly>Gendarme.Framework</Assembly>
+      </Reference>
+      <Reference>
+        <Assembly>Test.Rules</Assembly>
+      </Reference>
+      <Reference>
+        <Assembly>System.Core</Assembly>
+      </Reference>
+    </References>
+    <ProjectItem SubType="Code" TargetFileName="$fileinputname$.cs" ReplaceParameters="true">AssemblyTest.cs</ProjectItem>
+  </TemplateContent>
+</VSTemplate>
\ No newline at end of file
diff --git a/gendarme/tools/supported/templates/Makefile.am b/gendarme/tools/supported/templates/Makefile.am
new file mode 100644
index 0000000..885e9e8
--- /dev/null
+++ b/gendarme/tools/supported/templates/Makefile.am
@@ -0,0 +1,102 @@
+EXTRA_DIST = README README.vsnet \
+	AssemblyRule.cs AssemblyRule.vstemplate \
+	AssemblyTest.cs AssemblyTest.vstemplate \
+	TypeRule.cs TypeRule.vstemplate \
+	TypeTest.cs TypeTest.vstemplate \
+	MethodRule.cs MethodRule.vstemplate \
+	MethodTest.cs MethodTest.vstemplate \
+	Templates.RuleProject.csproj Templates.RuleProject.vstemplate \
+	Templates.TestProject.csproj Templates.TestProject.vstemplate
+
+GENDARME_ICON = ../../../swf-wizard-runner/Resources/gendarme.ico
+
+vsnet-item-assembly-rule:
+	mkdir -p temp
+	cp $(GENDARME_ICON) temp/__TemplateIcon.ico
+	cp AssemblyRule.cs temp/AssemblyRule.cs
+	cp AssemblyRule.vstemplate temp/MyTemplate.vstemplate
+	zip -j "Templates\ItemTemplates\Visual C#\Gendarme Items\Assembly Rule.zip" temp/*
+	rm -rf temp/*
+
+vsnet-item-assembly-test:
+	mkdir -p temp
+	cp $(GENDARME_ICON) temp/__TemplateIcon.ico
+	cp AssemblyTest.cs temp/AssemblyTest.cs
+	cp AssemblyTest.vstemplate temp/MyTemplate.vstemplate
+	zip -j "Templates\ItemTemplates\Visual C#\Gendarme Items\Assembly Rule Test.zip" temp/*
+	rm -rf temp/*
+
+vsnet-item-method-rule:
+	mkdir -p temp
+	cp $(GENDARME_ICON) temp/__TemplateIcon.ico
+	cp MethodRule.cs temp/MethodRule.cs
+	cp MethodRule.vstemplate temp/MyTemplate.vstemplate
+	zip -j "Templates\ItemTemplates\Visual C#\Gendarme Items\Method Rule.zip" temp/*
+	rm -rf temp/*
+
+vsnet-item-method-test:
+	mkdir -p temp
+	cp $(GENDARME_ICON) temp/__TemplateIcon.ico
+	cp MethodTest.cs temp/MethodTest.cs
+	cp MethodTest.vstemplate temp/MyTemplate.vstemplate
+	zip -j "Templates\ItemTemplates\Visual C#\Gendarme Items\Method Rule Test.zip" temp/*
+	rm -rf temp/*
+
+vsnet-item-type-rule:
+	mkdir -p temp
+	cp $(GENDARME_ICON) temp/__TemplateIcon.ico
+	cp TypeRule.cs temp/TypeRule.cs
+	cp TypeRule.vstemplate temp/MyTemplate.vstemplate
+	zip -j "Templates\ItemTemplates\Visual C#\Gendarme Items\Type Rule.zip" temp/*
+	rm -rf temp/*
+
+vsnet-item-type-test:
+	mkdir -p temp
+	cp $(GENDARME_ICON) temp/__TemplateIcon.ico
+	cp TypeTest.cs temp/TypeTest.cs
+	cp TypeTest.vstemplate temp/MyTemplate.vstemplate
+	zip -j "Templates\ItemTemplates\Visual C#\Gendarme Items\Type Rule Test.zip" temp/*
+	rm -rf temp/*
+
+vsnet-item-templates: vsnet-item-assembly-rule vsnet-item-assembly-test \
+	vsnet-item-method-rule vsnet-item-method-test \
+	vsnet-item-type-rule vsnet-item-type-test
+
+vsnet-project-rules:
+	mkdir -p temp
+	cp $(GENDARME_ICON) temp/__TemplateIcon.ico
+	cp Templates.RuleProject.csproj temp/Templates.RuleProject.csproj
+	cp Templates.RuleProject.vstemplate temp/MyTemplate.vstemplate
+	zip -j "Templates\ProjectTemplates\Visual C#\Gendarme Projects\Rule Assembly.zip" temp/*
+	rm -rf temp/*
+
+vsnet-project-tests:
+	mkdir -p temp
+	cp $(GENDARME_ICON) temp/__TemplateIcon.ico
+	cp Templates.TestProject.csproj temp/Templates.TestProject.csproj
+	cp Templates.TestProject.vstemplate temp/MyTemplate.vstemplate
+	zip -j "Templates\ProjectTemplates\Visual C#\Gendarme Projects\Rule Test Assembly.zip" temp/*
+	rm -rf temp/*
+
+vsnet-project-templates: vsnet-project-rules vsnet-project-tests
+
+vsnet: vsnet-item-templates vsnet-project-templates
+	zip gendarme-vsnet-templates.zip README.vsnet \
+		"Templates\ItemTemplates\Visual C#\Gendarme Items\Assembly Rule.zip" \
+		"Templates\ItemTemplates\Visual C#\Gendarme Items\Assembly Rule Test.zip" \
+		"Templates\ItemTemplates\Visual C#\Gendarme Items\Method Rule.zip" \
+		"Templates\ItemTemplates\Visual C#\Gendarme Items\Method Rule Test.zip" \
+		"Templates\ItemTemplates\Visual C#\Gendarme Items\Type Rule.zip" \
+		"Templates\ItemTemplates\Visual C#\Gendarme Items\Type Rule Test.zip" \
+		"Templates\ProjectTemplates\Visual C#\Gendarme Projects\Rule Assembly.zip" \
+		"Templates\ProjectTemplates\Visual C#\Gendarme Projects\Rule Test Assembly.zip"
+	rmdir temp
+
+gendarme-vsnet-templates.zip: vsnet
+
+all: gendarme-vsnet-templates.zip
+
+clean:
+	rm -f *.zip
+	rm -rf temp
+
diff --git a/gendarme/tools/supported/templates/MethodRule.cs b/gendarme/tools/supported/templates/MethodRule.cs
new file mode 100644
index 0000000..bd0911a
--- /dev/null
+++ b/gendarme/tools/supported/templates/MethodRule.cs
@@ -0,0 +1,65 @@
+// 
+// $rootnamespace$.$safeitemname$
+//
+// Authors:
+//	$name$ <$email$>
+//
+// Copyright (C) $year$ $name$
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+using System;
+
+using Mono.Cecil;
+using Mono.Cecil.Cil;
+
+using Gendarme.Framework;
+using Gendarme.Framework.Engines;
+using Gendarme.Framework.Helpers;
+using Gendarme.Framework.Rocks;
+
+namespace $rootnamespace$ {
+
+	/// <summary>
+	/// TODO: Add a summary of the rule.
+	/// </summary>
+	/// <example>
+	/// Bad example:
+	/// <code>
+	/// TODO: Add an example where the rule would fail.
+	/// </code>
+	/// </example>
+	/// <example>
+	/// Good example:
+	/// <code>
+	/// TODO: Show how to fix the bad example.
+	/// </code>
+	/// </example>
+
+	// TODO: Describe the problem and solution
+	[Problem ("")]
+	[Solution ("")]
+	public class $safeitemname$ : Rule, IMethodRule {
+		public RuleResult CheckMethod (MethodDefinition method)
+		{
+			// TODO: Write the rule.
+			return RuleResult.Success;
+		}
+	}
+}
diff --git a/gendarme/tools/supported/templates/MethodRule.vstemplate b/gendarme/tools/supported/templates/MethodRule.vstemplate
new file mode 100644
index 0000000..5942dbd
--- /dev/null
+++ b/gendarme/tools/supported/templates/MethodRule.vstemplate
@@ -0,0 +1,24 @@
+<VSTemplate Version="3.0.0" xmlns="http://schemas.microsoft.com/developer/vstemplate/2005" Type="Item">
+  <TemplateData>
+    <DefaultName>Method Rule.cs</DefaultName>
+    <Name>Method Rule</Name>
+    <Description>A gendarme rule that checks a method.</Description>
+    <ProjectType>CSharp</ProjectType>
+    <SortOrder>10</SortOrder>
+    <Icon>__TemplateIcon.ico</Icon>
+  </TemplateData>
+  <TemplateContent>
+    <References>
+      <Reference>
+        <Assembly>Mono.Cecil</Assembly>
+      </Reference>
+      <Reference>
+        <Assembly>Gendarme.Framework</Assembly>
+      </Reference>
+      <Reference>
+        <Assembly>System.Core</Assembly>
+      </Reference>
+    </References>
+    <ProjectItem SubType="Code" TargetFileName="$fileinputname$.cs" ReplaceParameters="true">MethodRule.cs</ProjectItem>
+  </TemplateContent>
+</VSTemplate>
\ No newline at end of file
diff --git a/gendarme/tools/supported/templates/MethodTest.cs b/gendarme/tools/supported/templates/MethodTest.cs
new file mode 100644
index 0000000..4f70412
--- /dev/null
+++ b/gendarme/tools/supported/templates/MethodTest.cs
@@ -0,0 +1,64 @@
+// 
+// $rootnamespace$.$safeitemname$
+//
+// Authors:
+//	$name$ <$email$>
+//
+// Copyright (C) $year$ $name$
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+using System;
+using System.Reflection;
+
+using Mono.Cecil;
+// TODO: Add using for the project of the rule being tested.
+// using Gendarme.Rules. ;
+
+using NUnit.Framework;
+using Test.Rules.Fixtures;
+using Test.Rules.Helpers;
+using Test.Rules.Definitions;
+
+namespace $rootnamespace$ {
+
+	[TestFixture]
+	public class $safeitemname$ : MethodRuleTestFixture</* TODO: Add rule's type */> {
+		[Test]
+		public void DoesNotApply ()
+		{
+			// TODO: Write tests that don't apply.
+			// AssertRuleDoesNotApply (method);
+		}
+
+		[Test]
+		public void Good ()
+		{
+			// TODO: Write tests that should succeed.
+			// AssertRuleSuccess (method);
+		}
+
+		[Test]
+		public void Bad ()
+		{
+			// TODO: Write tests that should fail.
+			// AssertRuleFailure (method);
+		}
+	}
+}
diff --git a/gendarme/tools/supported/templates/MethodTest.vstemplate b/gendarme/tools/supported/templates/MethodTest.vstemplate
new file mode 100644
index 0000000..c9e9cd7
--- /dev/null
+++ b/gendarme/tools/supported/templates/MethodTest.vstemplate
@@ -0,0 +1,27 @@
+<VSTemplate Version="3.0.0" xmlns="http://schemas.microsoft.com/developer/vstemplate/2005" Type="Item">
+  <TemplateData>
+    <DefaultName>Method Rule Test.cs</DefaultName>
+    <Name>Method Rule Test</Name>
+    <Description>A unit test for a gendarme method rule.</Description>
+    <ProjectType>CSharp</ProjectType>
+    <SortOrder>10</SortOrder>
+    <Icon>__TemplateIcon.ico</Icon>
+  </TemplateData>
+  <TemplateContent>
+    <References>
+      <Reference>
+        <Assembly>Mono.Cecil</Assembly>
+      </Reference>
+      <Reference>
+        <Assembly>Gendarme.Framework</Assembly>
+      </Reference>
+      <Reference>
+        <Assembly>Test.Rules</Assembly>
+      </Reference>
+      <Reference>
+        <Assembly>System.Core</Assembly>
+      </Reference>
+    </References>
+    <ProjectItem SubType="Code" TargetFileName="$fileinputname$.cs" ReplaceParameters="true">MethodTest.cs</ProjectItem>
+  </TemplateContent>
+</VSTemplate>
\ No newline at end of file
diff --git a/gendarme/tools/supported/templates/README b/gendarme/tools/supported/templates/README
new file mode 100644
index 0000000..13a814b
--- /dev/null
+++ b/gendarme/tools/supported/templates/README
@@ -0,0 +1,8 @@
+Here are uncompressed C# templates for Gendarme rules, tests and projects.
+
+To build the compressed templates required by VS.NET (2008/2010) just issue a:
+
+% make vsnet
+
+and read the README.vsnet file (also part of the archive).
+
diff --git a/gendarme/tools/supported/templates/README.vsnet b/gendarme/tools/supported/templates/README.vsnet
new file mode 100644
index 0000000..9ffcf5e
--- /dev/null
+++ b/gendarme/tools/supported/templates/README.vsnet
@@ -0,0 +1,12 @@
+Gendarme Item/Project Templates for Visual Studio
+
+To Install:
+- Extract this file to your My Documents\Visual Studio 20x folder.
+- Optionally, open the .vstemplate file in each item template.
+  In the <TemplateContent> section, add the following:
+    <CustomParameters>
+        <CustomParameter Name="$name$" Value="(your name)"/>
+        <CustomParameter Name="$email$" Value="(your email)"/>
+    </CustomParameters>
+  This will allow your name and e-mail address to be automatically
+  entered into rules and tests you create.
\ No newline at end of file
diff --git a/gendarme/tools/supported/templates/Templates.RuleProject.csproj b/gendarme/tools/supported/templates/Templates.RuleProject.csproj
new file mode 100644
index 0000000..4208f3e
--- /dev/null
+++ b/gendarme/tools/supported/templates/Templates.RuleProject.csproj
@@ -0,0 +1,57 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+    <Platform Condition=" '$(Platform)' == '' ">x86</Platform>
+    <ProductVersion>8.0.30703</ProductVersion>
+    <SchemaVersion>2.0</SchemaVersion>
+    <ProjectGuid>{BDADA65A-2C52-42C3-A7E4-A824FCDF4C9D}</ProjectGuid>
+    <OutputType>Exe</OutputType>
+    <AppDesignerFolder>Properties</AppDesignerFolder>
+    <RootNamespace>$safeprojectname$</RootNamespace>
+    <AssemblyName>$safeprojectname$</AssemblyName>
+    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
+    <TargetFrameworkProfile>Client</TargetFrameworkProfile>
+    <FileAlignment>512</FileAlignment>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|x86' ">
+    <PlatformTarget>x86</PlatformTarget>
+    <DebugSymbols>true</DebugSymbols>
+    <DebugType>full</DebugType>
+    <Optimize>false</Optimize>
+    <OutputPath>bin\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|x86' ">
+    <PlatformTarget>x86</PlatformTarget>
+    <DebugType>pdbonly</DebugType>
+    <Optimize>true</Optimize>
+    <OutputPath>bin\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <ItemGroup>
+    <Reference Include="System" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\..\..\cecil\Mono.Cecil.csproj">
+      <Project>{D68133BD-1E63-496E-9EDE-4FBDBF77B486}</Project>
+      <Name>Mono.Cecil</Name>
+    </ProjectReference>
+    <ProjectReference Include="..\framework\Gendarme.Framework.csproj">
+      <Project>{CD6818D5-B398-486C-B180-92A07B143AFD}</Project>
+      <Name>Gendarme.Framework</Name>
+    </ProjectReference>
+  </ItemGroup>
+  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
+  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+       Other similar extension points exist, see Microsoft.Common.targets.
+  <Target Name="BeforeBuild">
+  </Target>
+  <Target Name="AfterBuild">
+  </Target>
+  -->
+</Project>
\ No newline at end of file
diff --git a/gendarme/tools/supported/templates/Templates.RuleProject.vstemplate b/gendarme/tools/supported/templates/Templates.RuleProject.vstemplate
new file mode 100644
index 0000000..41afb51
--- /dev/null
+++ b/gendarme/tools/supported/templates/Templates.RuleProject.vstemplate
@@ -0,0 +1,19 @@
+<VSTemplate Version="3.0.0" xmlns="http://schemas.microsoft.com/developer/vstemplate/2005" Type="Project">
+  <TemplateData>
+    <Name>Rule Assembly</Name>
+    <Description>An assembly containing gendarme rules.</Description>
+    <ProjectType>CSharp</ProjectType>
+    <ProjectSubType>
+    </ProjectSubType>
+    <SortOrder>1000</SortOrder>
+    <CreateNewFolder>true</CreateNewFolder>
+    <DefaultName>Rule Assembly</DefaultName>
+    <ProvideDefaultName>true</ProvideDefaultName>
+    <LocationField>Enabled</LocationField>
+    <EnableLocationBrowseButton>true</EnableLocationBrowseButton>
+    <Icon>__TemplateIcon.ico</Icon>
+  </TemplateData>
+  <TemplateContent>
+    <Project TargetFileName="Templates.RuleProject.csproj" File="Templates.RuleProject.csproj" ReplaceParameters="true" />
+  </TemplateContent>
+</VSTemplate>
\ No newline at end of file
diff --git a/gendarme/tools/supported/templates/Templates.TestProject.csproj b/gendarme/tools/supported/templates/Templates.TestProject.csproj
new file mode 100644
index 0000000..6dd3298
--- /dev/null
+++ b/gendarme/tools/supported/templates/Templates.TestProject.csproj
@@ -0,0 +1,62 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+    <Platform Condition=" '$(Platform)' == '' ">x86</Platform>
+    <ProductVersion>8.0.30703</ProductVersion>
+    <SchemaVersion>2.0</SchemaVersion>
+    <ProjectGuid>{0B35C07C-19E8-40D0-8634-FE3929DBB8C7}</ProjectGuid>
+    <OutputType>Exe</OutputType>
+    <AppDesignerFolder>Properties</AppDesignerFolder>
+    <RootNamespace>$safeprojectname$</RootNamespace>
+    <AssemblyName>$safeprojectname$</AssemblyName>
+    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
+    <TargetFrameworkProfile>Client</TargetFrameworkProfile>
+    <FileAlignment>512</FileAlignment>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|x86' ">
+    <PlatformTarget>x86</PlatformTarget>
+    <DebugSymbols>true</DebugSymbols>
+    <DebugType>full</DebugType>
+    <Optimize>false</Optimize>
+    <OutputPath>bin\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|x86' ">
+    <PlatformTarget>x86</PlatformTarget>
+    <DebugType>pdbonly</DebugType>
+    <Optimize>true</Optimize>
+    <OutputPath>bin\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\..\..\cecil\Mono.Cecil.csproj">
+      <Project>{D68133BD-1E63-496E-9EDE-4FBDBF77B486}</Project>
+      <Name>Mono.Cecil</Name>
+    </ProjectReference>
+    <ProjectReference Include="..\framework\Gendarme.Framework.csproj">
+      <Project>{CD6818D5-B398-486C-B180-92A07B143AFD}</Project>
+      <Name>Gendarme.Framework</Name>
+    </ProjectReference>
+    <ProjectReference Include="..\rules\Test.Rules\Test.Rules.csproj">
+      <Project>{069148AF-86AB-4EE3-BFB9-429AE722461F}</Project>
+      <Name>Test.Rules</Name>
+    </ProjectReference>
+  </ItemGroup>
+  <ItemGroup>
+    <Reference Include="nunit.framework, Version=2.5.3.9345, Culture=neutral, PublicKeyToken=96d09a1eb7f44a77, processorArchitecture=MSIL" />
+    <Reference Include="System" />
+  </ItemGroup>
+  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
+  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+       Other similar extension points exist, see Microsoft.Common.targets.
+  <Target Name="BeforeBuild">
+  </Target>
+  <Target Name="AfterBuild">
+  </Target>
+  -->
+</Project>
\ No newline at end of file
diff --git a/gendarme/tools/supported/templates/Templates.TestProject.vstemplate b/gendarme/tools/supported/templates/Templates.TestProject.vstemplate
new file mode 100644
index 0000000..2d87449
--- /dev/null
+++ b/gendarme/tools/supported/templates/Templates.TestProject.vstemplate
@@ -0,0 +1,19 @@
+<VSTemplate Version="3.0.0" xmlns="http://schemas.microsoft.com/developer/vstemplate/2005" Type="Project">
+  <TemplateData>
+    <Name>Rule Test Assembly</Name>
+    <Description>An assembly of unit tests for gendarme rules.</Description>
+    <ProjectType>CSharp</ProjectType>
+    <ProjectSubType>
+    </ProjectSubType>
+    <SortOrder>1000</SortOrder>
+    <CreateNewFolder>true</CreateNewFolder>
+    <DefaultName>Rule Test Assembly</DefaultName>
+    <ProvideDefaultName>true</ProvideDefaultName>
+    <LocationField>Enabled</LocationField>
+    <EnableLocationBrowseButton>true</EnableLocationBrowseButton>
+    <Icon>__TemplateIcon.ico</Icon>
+  </TemplateData>
+  <TemplateContent>
+    <Project TargetFileName="Templates.TestProject.csproj" File="Templates.TestProject.csproj" ReplaceParameters="true" />
+  </TemplateContent>
+</VSTemplate>
\ No newline at end of file
diff --git a/gendarme/tools/supported/templates/TypeRule.cs b/gendarme/tools/supported/templates/TypeRule.cs
new file mode 100644
index 0000000..fce1256
--- /dev/null
+++ b/gendarme/tools/supported/templates/TypeRule.cs
@@ -0,0 +1,65 @@
+// 
+// $rootnamespace$.$safeitemname$
+//
+// Authors:
+//	$name$ <$email$>
+//
+// Copyright (C) $year$ $name$
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+using System;
+
+using Mono.Cecil;
+using Mono.Cecil.Cil;
+
+using Gendarme.Framework;
+using Gendarme.Framework.Engines;
+using Gendarme.Framework.Helpers;
+using Gendarme.Framework.Rocks;
+
+namespace $rootnamespace$ {
+
+	/// <summary>
+	/// TODO: Add a summary of the rule.
+	/// </summary>
+	/// <example>
+	/// Bad example:
+	/// <code>
+	/// TODO: Add an example where the rule would fail.
+	/// </code>
+	/// </example>
+	/// <example>
+	/// Good example:
+	/// <code>
+	/// TODO: Show how to fix the bad example.
+	/// </code>
+	/// </example>
+
+	// TODO: Describe the problem and solution
+	[Problem ("")]
+	[Solution ("")]
+	public class $safeitemname$ : Rule, ITypeRule {
+		public RuleResult CheckType (TypeDefinition type)
+		{
+			// TODO: Write the rule.
+			return RuleResult.Success;
+		}
+	}
+}
diff --git a/gendarme/tools/supported/templates/TypeRule.vstemplate b/gendarme/tools/supported/templates/TypeRule.vstemplate
new file mode 100644
index 0000000..3a0e9c1
--- /dev/null
+++ b/gendarme/tools/supported/templates/TypeRule.vstemplate
@@ -0,0 +1,24 @@
+<VSTemplate Version="3.0.0" xmlns="http://schemas.microsoft.com/developer/vstemplate/2005" Type="Item">
+  <TemplateData>
+    <DefaultName>Type Rule.cs</DefaultName>
+    <Name>Type Rule</Name>
+    <Description>A gendarme rule that checks a type.</Description>
+    <ProjectType>CSharp</ProjectType>
+    <SortOrder>10</SortOrder>
+    <Icon>__TemplateIcon.ico</Icon>
+  </TemplateData>
+  <TemplateContent>
+    <References>
+      <Reference>
+        <Assembly>Mono.Cecil</Assembly>
+      </Reference>
+      <Reference>
+        <Assembly>Gendarme.Framework</Assembly>
+      </Reference>
+      <Reference>
+        <Assembly>System.Core</Assembly>
+      </Reference>
+    </References>
+    <ProjectItem SubType="Code" TargetFileName="$fileinputname$.cs" ReplaceParameters="true">TypeRule.cs</ProjectItem>
+  </TemplateContent>
+</VSTemplate>
\ No newline at end of file
diff --git a/gendarme/tools/supported/templates/TypeTest.cs b/gendarme/tools/supported/templates/TypeTest.cs
new file mode 100644
index 0000000..92af871
--- /dev/null
+++ b/gendarme/tools/supported/templates/TypeTest.cs
@@ -0,0 +1,64 @@
+// 
+// $rootnamespace$.$safeitemname$
+//
+// Authors:
+//	$name$ <$email$>
+//
+// Copyright (C) $year$ $name$
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+using System;
+using System.Reflection;
+
+using Mono.Cecil;
+// TODO: Add using for the project of the rule being tested.
+// using Gendarme.Rules. ;
+
+using NUnit.Framework;
+using Test.Rules.Fixtures;
+using Test.Rules.Helpers;
+using Test.Rules.Definitions;
+
+namespace $rootnamespace$ {
+
+	[TestFixture]
+	public class $safeitemname$ : TypeRuleTestFixture</* TODO: Add rule's type */> {
+		[Test]
+		public void DoesNotApply ()
+		{
+			// TODO: Write tests that don't apply.
+			// AssertRuleDoesNotApply<type> ();
+		}
+
+		[Test]
+		public void Good ()
+		{
+			// TODO: Write tests that should succeed.
+			// AssertRuleSuccess<type> ();
+		}
+
+		[Test]
+		public void Bad ()
+		{
+			// TODO: Write tests that should fail.
+			// AssertRuleFailure<type> ();
+		}
+	}
+}
diff --git a/gendarme/tools/supported/templates/TypeTest.vstemplate b/gendarme/tools/supported/templates/TypeTest.vstemplate
new file mode 100644
index 0000000..2e0c866
--- /dev/null
+++ b/gendarme/tools/supported/templates/TypeTest.vstemplate
@@ -0,0 +1,27 @@
+<VSTemplate Version="3.0.0" xmlns="http://schemas.microsoft.com/developer/vstemplate/2005" Type="Item">
+  <TemplateData>
+    <DefaultName>Type Rule Test.cs</DefaultName>
+    <Name>Type Rule Test</Name>
+    <Description>A unit test for a gendarme type rule.</Description>
+    <ProjectType>CSharp</ProjectType>
+    <SortOrder>10</SortOrder>
+    <Icon>__TemplateIcon.ico</Icon>
+  </TemplateData>
+  <TemplateContent>
+    <References>
+      <Reference>
+        <Assembly>Mono.Cecil</Assembly>
+      </Reference>
+      <Reference>
+        <Assembly>Gendarme.Framework</Assembly>
+      </Reference>
+      <Reference>
+        <Assembly>Test.Rules</Assembly>
+      </Reference>
+      <Reference>
+        <Assembly>System.Core</Assembly>
+      </Reference>
+    </References>
+    <ProjectItem SubType="Code" TargetFileName="$fileinputname$.cs" ReplaceParameters="true">TypeTest.cs</ProjectItem>
+  </TemplateContent>
+</VSTemplate>
\ No newline at end of file
diff --git a/gendarme/tools/unsupported/mapper/FxCopMapBuilder.cs b/gendarme/tools/unsupported/mapper/FxCopMapBuilder.cs
index 7d2eee2..c62919f 100644
--- a/gendarme/tools/unsupported/mapper/FxCopMapBuilder.cs
+++ b/gendarme/tools/unsupported/mapper/FxCopMapBuilder.cs
@@ -222,7 +222,8 @@ namespace FxCopMapBuilder {
 					idName [0], idName [1], rule.Attribute ("category").Value);
 			}
 			if (rule.Attribute ("type").Value == "gendarme") {
-				return String.Format ("[[{0}]]", rule.Attribute ("id").Value);
+				return String.Format ("[[{1}|{0}.{1}{2}]]", rule.Attribute ("category").Value, 
+					rule.Attribute ("id").Value, "(2.10)");
 			}
 			return String.Empty;
 		}
diff --git a/gendarme/tools/unsupported/mapper/Makefile.am b/gendarme/tools/unsupported/mapper/Makefile.am
index a283bee..ae79ba4 100644
--- a/gendarme/tools/unsupported/mapper/Makefile.am
+++ b/gendarme/tools/unsupported/mapper/Makefile.am
@@ -7,7 +7,7 @@ mapper_sources =  \
 	FxCopRule.cs
 
 mapper.exe: $(mapper_sources)
-	$(GMCS) -debug $^ -out:$@ -r:System.Xml.Linq.dll -r:$(CECIL_ASM)
+	$(MCS) -debug $^ -out:$@ -r:System.Xml.Linq.dll -r:$(CECIL_ASM)
 
 clean:
 	rm -f mapper.exe*
diff --git a/gendarme/tools/unsupported/mapper/fxcop.missing b/gendarme/tools/unsupported/mapper/fxcop.missing
index 556c2fc..919df45 100644
--- a/gendarme/tools/unsupported/mapper/fxcop.missing
+++ b/gendarme/tools/unsupported/mapper/fxcop.missing
@@ -3,7 +3,6 @@ CA1025	Replace repetitive arguments with params array
 CA1026	Default parameters should not be used                                                        http://msdn.microsoft.com/en-us/library/ms182135.aspx
 CA1033	Interface methods should be callable by child types                                          http://msdn.microsoft.com/en-us/library/ms182153.aspx
 CA1046	Do not overload operator equals on reference types                                           http://msdn.microsoft.com/en-us/library/ms182145.aspx
-CA1052	Static holder types should be sealed                                                         http://msdn.microsoft.com/en-us/library/ms182168.aspx
 CA1058	Types should not extend certain base types                                                   http://msdn.microsoft.com/en-us/library/ms182171.aspx
 CA1061	Do not hide base class methods                                                               http://msdn.microsoft.com/en-us/library/ms182143.aspx
 CA1063	Implement IDisposable correctly                                                              http://msdn.microsoft.com/en-us/library/ms244737.aspx
@@ -14,10 +13,7 @@ CA1300	Specify MessageBoxOptions
 CA1301	Avoid duplicate accelerators                                                                 http://msdn.microsoft.com/en-us/library/ms182185.aspx
 CA1302	Do not hardcode locale specific strings                                                      http://msdn.microsoft.com/en-us/library/ms182186.aspx
 CA1303	Do not pass literals as localized parameters                                                 http://msdn.microsoft.com/en-us/library/ms182187.aspx
-CA1304	Specify CultureInfo                                                                          http://msdn.microsoft.com/en-us/library/ms182189.aspx
-CA1305	Specify IFormatProvider                                                                      http://msdn.microsoft.com/en-us/library/ms182190.aspx
 CA1306	Set locale for data types                                                                    http://msdn.microsoft.com/en-us/library/ms182188.aspx
-CA1307	Specify StringComparison                                                                     http://msdn.microsoft.com/en-us/library/bb386080.aspx
 CA1308	Normalize strings to uppercase                                                               http://msdn.microsoft.com/en-us/library/bb386042.aspx
 CA1309	Use ordinal StringComparison                                                                 http://msdn.microsoft.com/en-us/library/bb385972.aspx
 
@@ -40,7 +36,6 @@ CA1717	Only FlagsAttribute enums should have plural names
 CA1719	Parameter names should not match member names                                                http://msdn.microsoft.com/en-us/library/ms182252.aspx
 CA1720	Identifiers should not contain type names                                                    http://msdn.microsoft.com/en-us/library/bb531486.aspx
 CA1721	Property names should not match get methods                                                  http://msdn.microsoft.com/en-us/library/ms182253.aspx
-CA1724	Type Names Should Not Match Namespaces                                                       http://msdn.microsoft.com/en-us/library/ms182257.aspx
 
 Microsoft.Performance
 CA1810	Initialize reference type static fields inline                                               http://msdn.microsoft.com/en-us/library/ms182275.aspx
@@ -97,9 +92,6 @@ CA2207	Initialize value type static fields inline
 CA2212	Do not mark serviced components with WebMethod                                               http://msdn.microsoft.com/en-us/library/ms182336.aspx
 CA2215	Dispose methods should call base class dispose                                               http://msdn.microsoft.com/en-us/library/ms182330.aspx
 CA2217	Do not mark enums with FlagsAttribute                                                        http://msdn.microsoft.com/en-us/library/ms182335.aspx
-CA2219	Do not raise exceptions in exception clauses                                                 http://msdn.microsoft.com/en-us/library/bb386041.aspx
-CA2222	Do not decrease inherited member visibility                                                  http://msdn.microsoft.com/en-us/library/ms182332.aspx
 CA2223	Members should differ by more than return type                                               http://msdn.microsoft.com/en-us/library/ms182352.aspx
-CA2227	Collection properties should be read only                                                    http://msdn.microsoft.com/en-us/library/ms182327.aspx
 CA2228	Do not ship unreleased resource formats                                                      http://msdn.microsoft.com/en-us/library/ms182339.aspx
 CA2233	Operations should not overflow                                                               http://msdn.microsoft.com/en-us/library/ms182354.aspx
diff --git a/gendarme/tools/unsupported/typeref/Makefile.am b/gendarme/tools/unsupported/typeref/Makefile.am
index 436189e..e1ba4d3 100644
--- a/gendarme/tools/unsupported/typeref/Makefile.am
+++ b/gendarme/tools/unsupported/typeref/Makefile.am
@@ -6,7 +6,7 @@ typeref_sources =  \
 	typeref.cs
 
 typeref.exe:  $(typeref_sources)
-	$(GMCS) -debug $^ -out:$@ -r:$(CECIL_ASM)
+	$(MCS) -debug $^ -out:$@ -r:$(CECIL_ASM)
 
 clean:
 	rm -f typeref.exe*
diff --git a/gendarme/tools/unsupported/typeref/typeref.csproj b/gendarme/tools/unsupported/typeref/typeref.csproj
index 25854ee..09d805d 100644
--- a/gendarme/tools/unsupported/typeref/typeref.csproj
+++ b/gendarme/tools/unsupported/typeref/typeref.csproj
@@ -1,5 +1,5 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
     <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
@@ -10,8 +10,28 @@
     <AppDesignerFolder>Properties</AppDesignerFolder>
     <RootNamespace>typeref</RootNamespace>
     <AssemblyName>typeref</AssemblyName>
-    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
     <FileAlignment>512</FileAlignment>
+    <FileUpgradeFlags>
+    </FileUpgradeFlags>
+    <OldToolsVersion>3.5</OldToolsVersion>
+    <UpgradeBackupLocation />
+    <PublishUrl>publish\</PublishUrl>
+    <Install>true</Install>
+    <InstallFrom>Disk</InstallFrom>
+    <UpdateEnabled>false</UpdateEnabled>
+    <UpdateMode>Foreground</UpdateMode>
+    <UpdateInterval>7</UpdateInterval>
+    <UpdateIntervalUnits>Days</UpdateIntervalUnits>
+    <UpdatePeriodically>false</UpdatePeriodically>
+    <UpdateRequired>false</UpdateRequired>
+    <MapFileExtensions>true</MapFileExtensions>
+    <ApplicationRevision>0</ApplicationRevision>
+    <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
+    <IsWebBootstrapper>false</IsWebBootstrapper>
+    <UseApplicationTrust>false</UseApplicationTrust>
+    <BootstrapperEnabled>true</BootstrapperEnabled>
+    <TargetFrameworkProfile />
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
     <DebugSymbols>true</DebugSymbols>
@@ -21,6 +41,7 @@
     <DefineConstants>DEBUG;TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
     <DebugType>pdbonly</DebugType>
@@ -29,6 +50,7 @@
     <DefineConstants>TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <ItemGroup>
     <Reference Include="System" />
@@ -51,6 +73,23 @@
   <ItemGroup>
     <Folder Include="Properties\" />
   </ItemGroup>
+  <ItemGroup>
+    <BootstrapperPackage Include="Microsoft.Net.Client.3.5">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1 Client Profile</ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Windows.Installer.3.1">
+      <Visible>False</Visible>
+      <ProductName>Windows Installer 3.1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+  </ItemGroup>
   <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
   <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
        Other similar extension points exist, see Microsoft.Common.targets.
diff --git a/gendarme/tools/unsupported/xmldoc2wiki/Makefile.am b/gendarme/tools/unsupported/xmldoc2wiki/Makefile.am
index ff0167b..55fb249 100644
--- a/gendarme/tools/unsupported/xmldoc2wiki/Makefile.am
+++ b/gendarme/tools/unsupported/xmldoc2wiki/Makefile.am
@@ -6,7 +6,7 @@ xmldoc2wiki_sources =  \
 	xmldoc2wiki.cs
 
 xmldoc2wiki.exe: $(xmldoc2wiki_sources)
-	$(GMCS) -debug $^ -out:$@ -r:System.Xml.Linq.dll
+	$(MCS) -debug $^ -out:$@ -r:System.Xml.Linq.dll
 
 clean:
 	rm -f xmldoc2wiki.exe*
diff --git a/gendarme/tools/unsupported/xmldoc2wiki/README b/gendarme/tools/unsupported/xmldoc2wiki/README
index 764df91..ce17af9 100644
--- a/gendarme/tools/unsupported/xmldoc2wiki/README
+++ b/gendarme/tools/unsupported/xmldoc2wiki/README
@@ -11,5 +11,16 @@ Examples:
   xmldoc2wiki bin/*.xml 2-8-doc
 
 Local wiki access:
-  You can access the wiki locally by using github's gollum: https://github.com/github/gollum#readme
-  The installation is pretty simple, don't forget to install rdiscount gem that provides Markdown support.
+
+  a) Install gollum (https://github.com/github/gollum#readme). This requires Ruby.
+
+	% gem install gollum
+
+  b) Install rdiscount (http://daringfireball.net/projects/markdown/) for Markdown support
+
+	% gem install rdiscount
+
+  c) Install Pygments (http://pygments.org/) for syntax highlightning. This requires Python.
+
+	% easy_install Pygments
+
diff --git a/gendarme/tools/unsupported/xmldoc2wiki/xmldoc2wiki.cs b/gendarme/tools/unsupported/xmldoc2wiki/xmldoc2wiki.cs
index 4fbca7f..5fbc2dd 100644
--- a/gendarme/tools/unsupported/xmldoc2wiki/xmldoc2wiki.cs
+++ b/gendarme/tools/unsupported/xmldoc2wiki/xmldoc2wiki.cs
@@ -1,3 +1,31 @@
+// 
+// Gendarme's xmldoc2wiki tool
+//
+// Authors:
+//	Sebastien Pouliot <sebastien@ximian.com>
+//	Yuri Stuken <stuken.yuri@gmail.com>
+//
+// Copyright (C) 2010-2011 Novell, Inc (http://www.novell.com)
+// Copyright (C) 2010 Yuri Stuken
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
 using System;
 using System.IO;
 using System.Collections.Generic;
@@ -11,6 +39,7 @@ static class Program {
 	static HashSet<string> assembliesIndex = new HashSet<string> ();
 
 	static string outputdir;
+	static string version = "git";
 
 	static string CleanUp (this string s)
 	{
@@ -18,20 +47,6 @@ static class Program {
 		return Regex.Replace (s, @"([\`\*])", @"\$1");
 	}
 
-	static void Header (TextWriter tw)
-	{
-		// tw.WriteLine ("# Rules");
-		// tw.WriteLine ();
-	}
-
-	static void Footer (TextWriter tw)
-	{
-		tw.WriteLine (@"## Feedback
-
-Please report any documentation errors, typos or suggestions to the 
-[[Gendarme Google Group|http://groups.google.com/group/gendarme]]. Thanks!");
-	}
-
 	static void AppendIndentedLine (StringBuilder sb, string line, int indentation)
 	{
 		for (int i = 0; i < indentation; i++)
@@ -168,6 +183,7 @@ Please report any documentation errors, typos or suggestions to the
 				ProcessText (tw, description.Nodes ());
 		}
 		tw.AppendLine ();
+		tw.AppendLine (); // make sure the following text is not part of the last item on the list
 	}
 
 	static void ProcessRules (IEnumerable<XElement> rules, string assembly)
@@ -207,83 +223,104 @@ Please report any documentation errors, typos or suggestions to the
 
 			rulesIndex.Add (name);
 
-			TextWriter writer = File.CreateText (Path.Combine(Path.Combine(outputdir, assembly), Path.ChangeExtension (name, "md")));
-			Header (writer);
-
-			rsb.AppendFormat ("# {0}", name);
-			rsb.AppendFormat ("{1}**{0}**{1}{1}", assembly, Environment.NewLine);
-			rsb.AppendLine ("## Description");
-
-			//			tw.WriteLine (ProcessSummary (item));
-			ProcessText (rsb, item.Nodes ());
-			rsb.AppendLine ();
-			rsb.AppendLine ();
-
-			var examples = member.Elements ("example");
-			if (examples != null)
-				rsb.AppendLine ("## Examples");
-			foreach (XNode example in examples.Nodes ()) {
-				XText node = (example as XText);
-				if (node != null) {
-					string text = example.ToString ().CleanUp ().Replace ("Bad", "**Bad**");
-					text = text.Replace ("Good", "**Good**");
-					rsb.AppendFormat ("{0}{1}{1}", text.Trim (), Environment.NewLine);
-					continue;
-				}
+			string rule_file = String.Format ("{0}{1}{2}{1}{3}.{4}({2}).md", 
+				outputdir, Path.DirectorySeparatorChar, version, assembly, name);
+			using (TextWriter writer = File.CreateText (rule_file)) {
+				rsb.AppendFormat ("# {0}{1}{1}", name, Environment.NewLine);
+				rsb.AppendFormat ("Assembly: **[[{0}|{0}({1})]]**<br/>", assembly, version);
+				rsb.AppendFormat ("Version: **{0}**{1}{1}", version, Environment.NewLine);
+				rsb.AppendLine ("## Description");
+
+				//			tw.WriteLine (ProcessSummary (item));
+				ProcessText (rsb, item.Nodes ());
+				rsb.AppendLine ();
+				rsb.AppendLine ();
+
+				var examples = member.Elements ("example");
+				if (examples != null)
+					rsb.AppendLine ("## Examples");
+				foreach (XNode example in examples.Nodes ()) {
+					XText node = (example as XText);
+					if (node != null) {
+						string text = example.ToString ().CleanUp ().Replace ("Bad", "**Bad**");
+						text = text.Replace ("Good", "**Good**");
+						rsb.AppendFormat ("{0}{1}{1}", text.Trim (), Environment.NewLine);
+						continue;
+					}
+
+					XElement code = (example as XElement);
+					if (code == null)
+						continue;
 
-				XElement code = (example as XElement);
-				if (code == null)
-					continue;
-
-				switch (code.Name.LocalName) {
-				case "code":
-					rsb.AppendFormat ("```csharp{1}{0}{1}```{1}{1}", ProcessCode (code.Value),
-						Environment.NewLine);
-					break;
-				case "c":
-					rsb.AppendFormat (" {0}{1}{1}", code.Value, Environment.NewLine);
-					break;
+					switch (code.Name.LocalName) {
+					case "code":
+						rsb.AppendFormat ("```csharp{1}{0}{1}```{1}{1}", ProcessCode (code.Value),
+							Environment.NewLine);
+						break;
+					case "c":
+						rsb.AppendFormat (" {0}{1}{1}", code.Value, Environment.NewLine);
+						break;
+					}
 				}
-			}
 
-			XElement container = member.Element ("remarks");
-			if (container != null) {
-				IEnumerable<XNode> remarks = container.Nodes ();
-				if (remarks.Count () > 0) {
-					rsb.AppendFormat ("## Notes{0}{0}", Environment.NewLine);
-					rsb.Append ("* ");
+				XElement container = member.Element ("remarks");
+				if (container != null) {
+					IEnumerable<XNode> remarks = container.Nodes ();
+					if (remarks.Count () > 0) {
+						rsb.AppendFormat ("## Notes{0}{0}", Environment.NewLine);
+						rsb.Append ("* ");
 
-					ProcessText (rsb, remarks);
+						ProcessText (rsb, remarks);
+						rsb.AppendLine ();
+					}
+				}
+
+				StringBuilder psb;
+				if (properties.TryGetValue (name, out psb)) {
+					rsb.AppendFormat ("## Configuration{0}{0}", Environment.NewLine);
+					rsb.AppendFormat ("Some elements of this rule can be customized to better fit your needs.{0}{0}", Environment.NewLine);
+					rsb.Append (psb);
 					rsb.AppendLine ();
 				}
-			}
 
-			StringBuilder psb;
-			if (properties.TryGetValue (name, out psb)) {
-				rsb.AppendFormat ("## Configuration{0}{0}", Environment.NewLine);
-				rsb.AppendFormat ("Some elements of this rule can be customized to better fit your needs.{0}{0}", Environment.NewLine);
-				rsb.Append (psb);
-				rsb.AppendLine ();
-			}
+				writer.WriteLine (rsb);
 
-			writer.WriteLine (rsb);
+				if (version == "git") {
+					writer.WriteLine ();
+					writer.WriteLine (@"## Source code
 
-			Footer (writer);
-			writer.Close ();
+You can browse the latest [[source code|https://github.com/mono/mono-tools/tree/master/gendarme/rules/{0}/{1}.cs]] of this rule on github.com", assembly, name);
+				}
+			}
 		}
 
 		var rulesList =
 			from rule in rulesIndex
 			orderby rule
 			select rule;
-		TextWriter indexWriter = File.CreateText (Path.Combine(outputdir, Path.Combine(assembly, assembly + ".md")));
 
-		foreach (var rule in rulesList) {
-			indexWriter.WriteLine ("[[{0}]]  ", rule);
-		}
+		string assembly_index = String.Format ("{0}{1}{2}{1}{3}({2}).md", 
+			outputdir, Path.DirectorySeparatorChar, version, assembly);
+
+		using (TextWriter writer = File.CreateText (assembly_index)) {
+			writer.WriteLine ("# {0} Rules", assembly);
+			writer.WriteLine ();
+			writer.WriteLine ("The following ({0}) rules are available in version [[{1}|Gendarme.Rules({1})]] of {2}:", 
+				rulesList.Count (), version, assembly);
+			writer.WriteLine ();
+			foreach (var rule in rulesList) {
+				writer.WriteLine ("* [[{0}|{1}.{0}({2})]]  ", rule, assembly, version);
+			}
+
+			if (version == "git") {
+				writer.WriteLine ();
+				writer.WriteLine (@"## Source code
 
-		indexWriter.Close ();
+You can browse the latest [[source code|https://github.com/mono/mono-tools/tree/master/gendarme/rules/{0}]] of this assembly on github.com", assembly);
+			}
 
+			writer.WriteLine ();
+		}
 	}
 
 	static void ProcessFile (string filename)
@@ -294,15 +331,14 @@ Please report any documentation errors, typos or suggestions to the
 			orderby (string)member.Attribute ("name") ascending
 			select member;
 
-		string assembly =
+		string assembly = Path.GetFileName (
 			(from a in doc.Descendants ("assembly")
-			 select a.Element ("name").Value).FirstOrDefault();
-		
-		if (assembly == null || !assembly.StartsWith("Gendarme"))
+			 select a.Element ("name").Value).FirstOrDefault ());
+
+		if (assembly == null || !assembly.StartsWith ("Gendarme"))
 			return;
 
 		assembliesIndex.Add (assembly);
-		Directory.CreateDirectory (Path.Combine(outputdir, assembly));
 		ProcessRules (members, assembly); 
 	}
 
@@ -310,40 +346,99 @@ Please report any documentation errors, typos or suggestions to the
 	{
 		string [] files;
 		if (args.Length < 1) {
-			Console.WriteLine ("Usage: xmldoc2wiki filepattern [outputdir]");
+			Console.WriteLine ("Usage: xmldoc2wiki filepattern [--out outputdir] [--version version]");
 			return;
 		}
 
-		int index = args [0].LastIndexOfAny (new char [] { '/', '\\' });
-		string dir, pattern;
-		if (index >= 0) {
-			dir = args [0].Substring (0, index);
-			pattern = args [0].Substring (args [0].LastIndexOfAny (new char [] { '/', '\\' }) + 1);
-		} else {
-			dir = ".";
-			pattern = args [0];
+		outputdir = ".";
+		version = "git";
+
+		List<string> filenames = new List<string> ();
+		for (int i = 0; i < args.Length; i++) {
+			string arg = args [i];
+			switch (arg) {
+			case "--version":
+				version = args [++i];
+				break;
+			case "--out":
+				outputdir = args [++i];
+				break;
+			default:
+				int index = arg.LastIndexOfAny (new char [] { '/', '\\' });
+				string dir, pattern;
+				if (index >= 0) {
+					dir = arg.Substring (0, index);
+					pattern = arg.Substring (index + 1);
+				} else {
+					dir = ".";
+					pattern = arg;
+				}
+
+				files = Directory.GetFiles (dir, pattern);
+				foreach (string file in files) {
+					filenames.Add (file);
+				}
+				break;
+			}
 		}
 
-		files = Directory.GetFiles (dir, pattern);
-		if (args.Length >= 2)
-			outputdir = args [1];
-		else
-			outputdir = ".";
+		string subdir = Path.Combine (outputdir, version);
+		if (!Directory.Exists (subdir))
+			Directory.CreateDirectory (subdir);
 
-		foreach (string file in files) {
+		foreach (string file in filenames) {
+			Console.WriteLine ("processing {0}", file);
 			ProcessFile (file);
 		}
 
-		TextWriter writer = File.CreateText (Path.Combine(outputdir, "index.md"));
+		CreateVersionIndex ();
+		CreateFooterFile ();
+	}
+
+	static void CreateVersionIndex ()
+	{
+		string rules_index = String.Format ("{0}{1}{2}{1}Gendarme.Rules({2}).md", 
+			outputdir, Path.DirectorySeparatorChar, version);
+
+		using (TextWriter writer = File.CreateText (rules_index)) {
+			writer.WriteLine ("# Gendarme Rules Documentation Index");
+			writer.WriteLine ();
+
+			var assemblies =
+				from assembly in assembliesIndex
+				orderby assembly
+				select assembly;
+
+			writer.WriteLine ("The following ({0}) assemblies are available in version {1}:", 
+				assemblies.Count (), version);
+			writer.WriteLine ();
+
+			foreach (var assembly in assemblies) {
+				writer.WriteLine ("* [[{0}|{0}({1})]]  ", assembly, version);
+			}
+
+			if (version == "git") {
+				writer.WriteLine ();
+				writer.WriteLine (@"## Source code
 
-		var assemblies =
-			from assembly in assembliesIndex
-			orderby assembly
-			select assembly;
+* Latest [[source code|https://github.com/mono/mono-tools/tree/master/gendarme/rules/]] for Gendarme's rules is available on github.com
+* Documentation is produced using gendarme's `xmldoc2wiki` (unsupported) tool which [[source code|https://github.com/mono/mono-tools/tree/master/gendarme/tools/unsupported/xmldoc2wiki]] is also available on github.com");
+			}
 
-		foreach (var assembly in assemblies) {
-			writer.WriteLine ("[[{0}]]  ", assembly);
+			writer.WriteLine ();
 		}
-		writer.Close ();
 	}
-}
\ No newline at end of file
+
+	static void CreateFooterFile ()
+	{
+		string footer = String.Format ("{0}{1}{2}{1}_Footer.md", outputdir, Path.DirectorySeparatorChar, version);
+
+		using (TextWriter writer = File.CreateText (footer)) {
+			writer.WriteLine (@"## Feedback
+
+Note that this page was autogenerated ({0}) based on the `xmldoc` comments inside the rules source code and cannot be edited from this wiki.
+Please report any documentation errors, typos or suggestions to the 
+[[Gendarme Google Group|http://groups.google.com/group/gendarme]]. Thanks!", DateTime.Now);
+ 		}
+	}
+}
diff --git a/gendarme/tools/unsupported/xmldoc2wiki/xmldoc2wiki.csproj b/gendarme/tools/unsupported/xmldoc2wiki/xmldoc2wiki.csproj
index db2fbf3..ee295fe 100644
--- a/gendarme/tools/unsupported/xmldoc2wiki/xmldoc2wiki.csproj
+++ b/gendarme/tools/unsupported/xmldoc2wiki/xmldoc2wiki.csproj
@@ -1,60 +1,99 @@
-<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <PropertyGroup>
-    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
-    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
-    <ProductVersion>9.0.30729</ProductVersion>
-    <SchemaVersion>2.0</SchemaVersion>
-    <ProjectGuid>{AF174688-A979-4B3C-BE21-1C1BE8A0358E}</ProjectGuid>
-    <OutputType>Exe</OutputType>
-    <AppDesignerFolder>Properties</AppDesignerFolder>
-    <RootNamespace>xmldoc2wiki</RootNamespace>
-    <AssemblyName>xmldoc2wiki</AssemblyName>
-    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
-    <FileAlignment>512</FileAlignment>
-  </PropertyGroup>
-  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
-    <DebugSymbols>true</DebugSymbols>
-    <DebugType>full</DebugType>
-    <Optimize>false</Optimize>
-    <OutputPath>bin\Debug\</OutputPath>
-    <DefineConstants>DEBUG;TRACE</DefineConstants>
-    <ErrorReport>prompt</ErrorReport>
-    <WarningLevel>4</WarningLevel>
-  </PropertyGroup>
-  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
-    <DebugType>pdbonly</DebugType>
-    <Optimize>true</Optimize>
-    <OutputPath>bin\Release\</OutputPath>
-    <DefineConstants>TRACE</DefineConstants>
-    <ErrorReport>prompt</ErrorReport>
-    <WarningLevel>4</WarningLevel>
-  </PropertyGroup>
-  <ItemGroup>
-    <Reference Include="System" />
-    <Reference Include="System.Core">
-      <RequiredTargetFramework>3.5</RequiredTargetFramework>
-    </Reference>
-    <Reference Include="System.Xml.Linq">
-      <RequiredTargetFramework>3.5</RequiredTargetFramework>
-    </Reference>
-    <Reference Include="System.Xml" />
-  </ItemGroup>
-  <ItemGroup>
-    <Compile Include="..\..\..\AssemblyStaticInfo.cs">
-      <Link>AssemblyStaticInfo.cs</Link>
-    </Compile>
-    <Compile Include="xmldoc2wiki.cs" />
-  </ItemGroup>
-  <ItemGroup>
-    <Folder Include="Properties\" />
-  </ItemGroup>
-  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
+    <ProductVersion>9.0.30729</ProductVersion>
+    <SchemaVersion>2.0</SchemaVersion>
+    <ProjectGuid>{AF174688-A979-4B3C-BE21-1C1BE8A0358E}</ProjectGuid>
+    <OutputType>Exe</OutputType>
+    <AppDesignerFolder>Properties</AppDesignerFolder>
+    <RootNamespace>xmldoc2wiki</RootNamespace>
+    <AssemblyName>xmldoc2wiki</AssemblyName>
+    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
+    <FileAlignment>512</FileAlignment>
+    <FileUpgradeFlags>
+    </FileUpgradeFlags>
+    <OldToolsVersion>3.5</OldToolsVersion>
+    <UpgradeBackupLocation />
+    <PublishUrl>publish\</PublishUrl>
+    <Install>true</Install>
+    <InstallFrom>Disk</InstallFrom>
+    <UpdateEnabled>false</UpdateEnabled>
+    <UpdateMode>Foreground</UpdateMode>
+    <UpdateInterval>7</UpdateInterval>
+    <UpdateIntervalUnits>Days</UpdateIntervalUnits>
+    <UpdatePeriodically>false</UpdatePeriodically>
+    <UpdateRequired>false</UpdateRequired>
+    <MapFileExtensions>true</MapFileExtensions>
+    <ApplicationRevision>0</ApplicationRevision>
+    <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
+    <IsWebBootstrapper>false</IsWebBootstrapper>
+    <UseApplicationTrust>false</UseApplicationTrust>
+    <BootstrapperEnabled>true</BootstrapperEnabled>
+    <TargetFrameworkProfile />
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
+    <DebugSymbols>true</DebugSymbols>
+    <DebugType>full</DebugType>
+    <Optimize>false</Optimize>
+    <OutputPath>bin\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
+    <DebugType>pdbonly</DebugType>
+    <Optimize>true</Optimize>
+    <OutputPath>bin\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
+  </PropertyGroup>
+  <ItemGroup>
+    <Reference Include="System" />
+    <Reference Include="System.Core">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+    <Reference Include="System.Xml.Linq">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+    <Reference Include="System.Xml" />
+  </ItemGroup>
+  <ItemGroup>
+    <Compile Include="..\..\..\AssemblyStaticInfo.cs">
+      <Link>AssemblyStaticInfo.cs</Link>
+    </Compile>
+    <Compile Include="xmldoc2wiki.cs" />
+  </ItemGroup>
+  <ItemGroup>
+    <Folder Include="Properties\" />
+  </ItemGroup>
+  <ItemGroup>
+    <BootstrapperPackage Include="Microsoft.Net.Client.3.5">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1 Client Profile</ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Windows.Installer.3.1">
+      <Visible>False</Visible>
+      <ProductName>Windows Installer 3.1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+  </ItemGroup>
+  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
   <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
        Other similar extension points exist, see Microsoft.Common.targets.
   <Target Name="BeforeBuild">
   </Target>
   <Target Name="AfterBuild">
   </Target>
-  -->
+  -->
 </Project>
\ No newline at end of file
diff --git a/gendarme/wix/Product.wxs b/gendarme/wix/Product.wxs
index cce4d8d..cd04e05 100644
--- a/gendarme/wix/Product.wxs
+++ b/gendarme/wix/Product.wxs
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <?define ProductShortName = "Gendarme" ?>
-<?define ProductVersion = "2.10.0" ?>
-<?define ProductVersionText = "2.10" ?>
+<?define ProductVersion = "2.11.0" ?>
+<?define ProductVersionText = "2.11" ?>
 <?define Manufacturer = "Novell" ?>
 <?define UpgradeCode = "D7C83968-DEF2-4614-81F2-A3EEFC9BC6B3" ?>
 
@@ -92,10 +92,10 @@
       <RemoveExistingProducts After="InstallValidate" />
     </InstallExecuteSequence>
 
-    <!-- Ensure .Net Framework 3.5 is installed -->
-    <PropertyRef Id="NETFRAMEWORK35" />
-    <Condition Message="This setup requires the .NET Framework 3.5 to be installed.">
-      <![CDATA[Installed OR NETFRAMEWORK35]]>
+    <!-- Ensure .Net Framework 4.0 is installed -->
+    <PropertyRef Id="NETFRAMEWORK40FULL" />
+    <Condition Message="This setup requires the .NET Framework 4.0 (full) to be installed.">
+      <![CDATA[Installed OR NETFRAMEWORK40FULL]]>
     </Condition>
 
     <!-- This enables the license screen and where to install screen -->
diff --git a/gendarme/wix/license.rtf b/gendarme/wix/license.rtf
index 8bd49b0..45c52b3 100644
--- a/gendarme/wix/license.rtf
+++ b/gendarme/wix/license.rtf
@@ -1,5 +1,5 @@
 {\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fswiss\fprq2\fcharset0 Arial;}}
-{\*\generator Msftedit 5.41.21.2508;}\viewkind4\uc1\pard\f0\fs20 Copyright (c) 2005-2010 Novell, Inc and the individuals listed on the ChangeLog entries.\par
+{\*\generator Msftedit 5.41.21.2508;}\viewkind4\uc1\pard\f0\fs20 Copyright (c) 2005-2011 Novell, Inc and the individuals listed on the ChangeLog entries.\par
 \par
 Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\par
 \par
@@ -7,4 +7,4 @@ The above copyright notice and this permission notice shall be included in all c
 \par
 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\par
 }
- 
\ No newline at end of file
+ 
diff --git a/gsharp/Main.cs b/gsharp/Main.cs
index 84899b8..52ed96a 100644
--- a/gsharp/Main.cs
+++ b/gsharp/Main.cs
@@ -19,6 +19,7 @@ namespace Mono.CSharp.Gui
 		public static bool Attached;
 		public static bool HostHasGtkRunning;
 		public static bool Debug;
+		static Evaluator evaluator;
 		
 		public static void ShowHelp (OptionSet p)
 		{
@@ -59,10 +60,10 @@ namespace Mono.CSharp.Gui
 			else
 				Start ("C# InteractiveBase Shell", extra);
 		}
-
+		
 		static void AssemblyLoaded (object sender, AssemblyLoadEventArgs e)
 		{
-			Evaluator.ReferenceAssembly (e.LoadedAssembly);
+			evaluator.ReferenceAssembly (e.LoadedAssembly);
 		}
 
 		internal static object RenderBitmaps (object o)
@@ -92,7 +93,7 @@ namespace Mono.CSharp.Gui
 			InteractiveGraphicsBase.Attached = true;
 			Gtk.Application.Invoke (delegate {
 				try {
-					Evaluator.Init (new string [0]);
+					evaluator = new Evaluator (new CompilerContext (new CompilerSettings (), new ConsoleReportPrinter ()));
 				} catch {
 					return;
 				}
@@ -103,7 +104,7 @@ namespace Mono.CSharp.Gui
 					
 					// Add all currently loaded assemblies
 					foreach (Assembly a in AppDomain.CurrentDomain.GetAssemblies ())
-						Evaluator.ReferenceAssembly (a);
+						evaluator.ReferenceAssembly (a);
 					
 					Start (String.Format ("Attached C# Interactive Shell at Process {0}", Process.GetCurrentProcess ().Id), null);
 				} finally {
@@ -129,7 +130,6 @@ namespace Mono.CSharp.Gui
 			if (files != null)
 				m.LoadFiles (files, false);
 			m.ShowAll ();
-			Evaluator.DescribeTypeExpressions = true;
 
 			if (!HostHasGtkRunning){
 				try {
@@ -146,4 +146,4 @@ namespace Mono.CSharp.Gui
 			}
 		}
 	}
-}
\ No newline at end of file
+}
diff --git a/gsharp/MainWindow.cs b/gsharp/MainWindow.cs
index 34c24e4..f5da16a 100644
--- a/gsharp/MainWindow.cs
+++ b/gsharp/MainWindow.cs
@@ -80,7 +80,7 @@ namespace Mono.CSharp.Gui
 			}
 				
 			foreach (string file in libraries){
-				Evaluator.LoadAssembly (file);
+				Shell.Evaluator.LoadAssembly (file);
 			}
 			
 			foreach (string file in sources){
@@ -101,7 +101,7 @@ namespace Mono.CSharp.Gui
 			object result;
 
 			try {
-				input = Evaluator.Evaluate (input, out result, out result_set);
+				input = Shell.Evaluator.Evaluate (input, out result, out result_set);
 			} catch (Exception e){
 				Console.WriteLine (e);
 				return null;
diff --git a/gsharp/Shell.cs b/gsharp/Shell.cs
index 05d5695..5f41ea5 100644
--- a/gsharp/Shell.cs
+++ b/gsharp/Shell.cs
@@ -50,7 +50,9 @@ namespace Mono.CSharp.Gui
 	public class Shell : TextView
 	{        
 		TextMark end_of_last_processing;
-		string expr = null;
+		string expr;
+		Evaluator evaluator;
+		CompilerContext context;
 
 		List<string> history = new List<string> ();
 		int history_cursor;
@@ -72,10 +74,14 @@ namespace Mono.CSharp.Gui
 			Buffer.InsertWithTagsByName (ref end, "Mono C# Shell, type 'help;' for help\n\nEnter statements or expressions below.\n", "Comment");
 			ShowPrompt (false);
 			
-			Evaluator.Init (new string [0]);
-			Evaluator.SetInteractiveBaseClass (typeof (InteractiveGraphicsBase));
-			Evaluator.Run ("LoadAssembly (\"System.Drawing\");");
-			Evaluator.Run ("using System; using System.Linq; using System.Collections; using System.Collections.Generic; using System.Drawing;");
+			
+			context = new CompilerContext (new CompilerSettings (), new ConsoleReportPrinter ());
+			evaluator = new Evaluator (context);
+			evaluator.DescribeTypeExpressions = true;
+			
+			evaluator.InteractiveBaseClass = typeof (InteractiveGraphicsBase);
+			evaluator.Run ("LoadAssembly (\"System.Drawing\");");
+			evaluator.Run ("using System; using System.Linq; using System.Collections; using System.Collections.Generic; using System.Drawing;");
 
 			if (!MainClass.Debug){
 				GuiStream error_stream = new GuiStream ("Error", (x, y) => Output (x, y));
@@ -139,16 +145,18 @@ namespace Mono.CSharp.Gui
 			object result;
 			bool result_set;
 			StringWriter errorwriter = new StringWriter ();
-
-			Evaluator.MessageOutput = errorwriter;
+			
+			var old_printer = context.Report.SetPrinter (new StreamReportPrinter (errorwriter));
 			
 			try {
-				res = Evaluator.Evaluate (s, out result, out result_set);
+				res = evaluator.Evaluate (s, out result, out result_set);
 			} catch (Exception e){
 				expr = null;
 				ShowError (e.ToString ());
 				ShowPrompt (true, false);
 				return true;
+			} finally {
+				context.Report.SetPrinter (old_printer);
 			}
 
 			// Partial input
@@ -262,7 +270,7 @@ namespace Mono.CSharp.Gui
 			case Gdk.Key.Tab:
 				string saved_text = InputLine;
 				string prefix;
-				string [] completions = Evaluator.GetCompletions (LineUntilCursor, out prefix);
+				string [] completions = evaluator.GetCompletions (LineUntilCursor, out prefix);
 				if (completions == null)
 					return true;
 
@@ -405,6 +413,12 @@ namespace Mono.CSharp.Gui
 		TextIter Cursor {
 			get { return Buffer.GetIterAtMark(Buffer.InsertMark); }
 		}
+		
+		public Evaluator Evaluator {
+			get {
+				return evaluator;
+			}
+		}		
 
 		string InputLine {
 			get { return Buffer.GetText(InputLineBegin, InputLineEnd, false); }
diff --git a/gsharp/gtk-gui/Mono.CSharp.Gui.DescribeType.cs b/gsharp/gtk-gui/Mono.CSharp.Gui.DescribeType.cs
index 21e9c5b..7e04ad0 100644
--- a/gsharp/gtk-gui/Mono.CSharp.Gui.DescribeType.cs
+++ b/gsharp/gtk-gui/Mono.CSharp.Gui.DescribeType.cs
@@ -1,105 +1,93 @@
-// ------------------------------------------------------------------------------
-//  <autogenerated>
-//      This code was generated by a tool.
-//      
-// 
-//      Changes to this file may cause incorrect behavior and will be lost if 
-//      the code is regenerated.
-//  </autogenerated>
-// ------------------------------------------------------------------------------
 
-namespace Mono.CSharp.Gui {
-    
-    
-    public partial class DescribeType {
-        
-        private Gtk.HBox hbox1;
-        
-        private Gtk.Label label1;
-        
-        private Gtk.Entry entry1;
-        
-        private Gtk.Button buttonCancel;
-        
-        private Gtk.Button buttonOk;
-        
-        protected virtual void Build() {
-            Stetic.Gui.Initialize(this);
-            // Widget Mono.CSharp.Gui.DescribeType
-            this.Name = "Mono.CSharp.Gui.DescribeType";
-            this.WindowPosition = ((Gtk.WindowPosition)(4));
-            // Internal child Mono.CSharp.Gui.DescribeType.VBox
-            Gtk.VBox w1 = this.VBox;
-            w1.Name = "dialog1_VBox";
-            w1.BorderWidth = ((uint)(2));
-            // Container child dialog1_VBox.Gtk.Box+BoxChild
-            this.hbox1 = new Gtk.HBox();
-            this.hbox1.Name = "hbox1";
-            this.hbox1.Spacing = 6;
-            // Container child hbox1.Gtk.Box+BoxChild
-            this.label1 = new Gtk.Label();
-            this.label1.Name = "label1";
-            this.label1.Xpad = 5;
-            this.label1.Ypad = 15;
-            this.label1.LabelProp = Mono.Unix.Catalog.GetString("Type name:");
-            this.hbox1.Add(this.label1);
-            Gtk.Box.BoxChild w2 = ((Gtk.Box.BoxChild)(this.hbox1[this.label1]));
-            w2.Position = 0;
-            w2.Expand = false;
-            w2.Fill = false;
-            // Container child hbox1.Gtk.Box+BoxChild
-            this.entry1 = new Gtk.Entry();
-            this.entry1.CanDefault = true;
-            this.entry1.CanFocus = true;
-            this.entry1.Name = "entry1";
-            this.entry1.IsEditable = true;
-            this.entry1.InvisibleChar = '●';
-            this.hbox1.Add(this.entry1);
-            Gtk.Box.BoxChild w3 = ((Gtk.Box.BoxChild)(this.hbox1[this.entry1]));
-            w3.Position = 1;
-            w1.Add(this.hbox1);
-            Gtk.Box.BoxChild w4 = ((Gtk.Box.BoxChild)(w1[this.hbox1]));
-            w4.Position = 0;
-            w4.Expand = false;
-            w4.Fill = false;
-            // Internal child Mono.CSharp.Gui.DescribeType.ActionArea
-            Gtk.HButtonBox w5 = this.ActionArea;
-            w5.Name = "dialog1_ActionArea";
-            w5.Spacing = 6;
-            w5.BorderWidth = ((uint)(5));
-            w5.LayoutStyle = ((Gtk.ButtonBoxStyle)(4));
-            // Container child dialog1_ActionArea.Gtk.ButtonBox+ButtonBoxChild
-            this.buttonCancel = new Gtk.Button();
-            this.buttonCancel.CanDefault = true;
-            this.buttonCancel.CanFocus = true;
-            this.buttonCancel.Name = "buttonCancel";
-            this.buttonCancel.UseStock = true;
-            this.buttonCancel.UseUnderline = true;
-            this.buttonCancel.Label = "gtk-cancel";
-            this.AddActionWidget(this.buttonCancel, -6);
-            Gtk.ButtonBox.ButtonBoxChild w6 = ((Gtk.ButtonBox.ButtonBoxChild)(w5[this.buttonCancel]));
-            w6.Expand = false;
-            w6.Fill = false;
-            // Container child dialog1_ActionArea.Gtk.ButtonBox+ButtonBoxChild
-            this.buttonOk = new Gtk.Button();
-            this.buttonOk.CanDefault = true;
-            this.buttonOk.CanFocus = true;
-            this.buttonOk.Name = "buttonOk";
-            this.buttonOk.UseStock = true;
-            this.buttonOk.UseUnderline = true;
-            this.buttonOk.Label = "gtk-ok";
-            this.AddActionWidget(this.buttonOk, -5);
-            Gtk.ButtonBox.ButtonBoxChild w7 = ((Gtk.ButtonBox.ButtonBoxChild)(w5[this.buttonOk]));
-            w7.Position = 1;
-            w7.Expand = false;
-            w7.Fill = false;
-            if ((this.Child != null)) {
-                this.Child.ShowAll();
-            }
-            this.DefaultWidth = 284;
-            this.DefaultHeight = 133;
-            this.Show();
-            this.entry1.Activated += new System.EventHandler(this.OnEntry1Activated);
-        }
-    }
+// This file has been generated by the GUI designer. Do not modify.
+namespace Mono.CSharp.Gui
+{
+	public partial class DescribeType
+	{
+		private global::Gtk.HBox hbox1;
+		private global::Gtk.Label label1;
+		private global::Gtk.Entry entry1;
+		private global::Gtk.Button buttonCancel;
+		private global::Gtk.Button buttonOk;
+
+		protected virtual void Build ()
+		{
+			global::Stetic.Gui.Initialize (this);
+			// Widget Mono.CSharp.Gui.DescribeType
+			this.Name = "Mono.CSharp.Gui.DescribeType";
+			this.WindowPosition = ((global::Gtk.WindowPosition)(4));
+			// Internal child Mono.CSharp.Gui.DescribeType.VBox
+			global::Gtk.VBox w1 = this.VBox;
+			w1.Name = "dialog1_VBox";
+			w1.BorderWidth = ((uint)(2));
+			// Container child dialog1_VBox.Gtk.Box+BoxChild
+			this.hbox1 = new global::Gtk.HBox ();
+			this.hbox1.Name = "hbox1";
+			this.hbox1.Spacing = 6;
+			// Container child hbox1.Gtk.Box+BoxChild
+			this.label1 = new global::Gtk.Label ();
+			this.label1.Name = "label1";
+			this.label1.Xpad = 5;
+			this.label1.Ypad = 15;
+			this.label1.LabelProp = global::Mono.Unix.Catalog.GetString ("Type name:");
+			this.hbox1.Add (this.label1);
+			global::Gtk.Box.BoxChild w2 = ((global::Gtk.Box.BoxChild)(this.hbox1 [this.label1]));
+			w2.Position = 0;
+			w2.Expand = false;
+			w2.Fill = false;
+			// Container child hbox1.Gtk.Box+BoxChild
+			this.entry1 = new global::Gtk.Entry ();
+			this.entry1.CanDefault = true;
+			this.entry1.CanFocus = true;
+			this.entry1.Name = "entry1";
+			this.entry1.IsEditable = true;
+			this.entry1.InvisibleChar = '●';
+			this.hbox1.Add (this.entry1);
+			global::Gtk.Box.BoxChild w3 = ((global::Gtk.Box.BoxChild)(this.hbox1 [this.entry1]));
+			w3.Position = 1;
+			w1.Add (this.hbox1);
+			global::Gtk.Box.BoxChild w4 = ((global::Gtk.Box.BoxChild)(w1 [this.hbox1]));
+			w4.Position = 0;
+			w4.Expand = false;
+			w4.Fill = false;
+			// Internal child Mono.CSharp.Gui.DescribeType.ActionArea
+			global::Gtk.HButtonBox w5 = this.ActionArea;
+			w5.Name = "dialog1_ActionArea";
+			w5.Spacing = 6;
+			w5.BorderWidth = ((uint)(5));
+			w5.LayoutStyle = ((global::Gtk.ButtonBoxStyle)(4));
+			// Container child dialog1_ActionArea.Gtk.ButtonBox+ButtonBoxChild
+			this.buttonCancel = new global::Gtk.Button ();
+			this.buttonCancel.CanDefault = true;
+			this.buttonCancel.CanFocus = true;
+			this.buttonCancel.Name = "buttonCancel";
+			this.buttonCancel.UseStock = true;
+			this.buttonCancel.UseUnderline = true;
+			this.buttonCancel.Label = "gtk-cancel";
+			this.AddActionWidget (this.buttonCancel, -6);
+			global::Gtk.ButtonBox.ButtonBoxChild w6 = ((global::Gtk.ButtonBox.ButtonBoxChild)(w5 [this.buttonCancel]));
+			w6.Expand = false;
+			w6.Fill = false;
+			// Container child dialog1_ActionArea.Gtk.ButtonBox+ButtonBoxChild
+			this.buttonOk = new global::Gtk.Button ();
+			this.buttonOk.CanDefault = true;
+			this.buttonOk.CanFocus = true;
+			this.buttonOk.Name = "buttonOk";
+			this.buttonOk.UseStock = true;
+			this.buttonOk.UseUnderline = true;
+			this.buttonOk.Label = "gtk-ok";
+			this.AddActionWidget (this.buttonOk, -5);
+			global::Gtk.ButtonBox.ButtonBoxChild w7 = ((global::Gtk.ButtonBox.ButtonBoxChild)(w5 [this.buttonOk]));
+			w7.Position = 1;
+			w7.Expand = false;
+			w7.Fill = false;
+			if ((this.Child != null)) {
+				this.Child.ShowAll ();
+			}
+			this.DefaultWidth = 284;
+			this.DefaultHeight = 133;
+			this.Show ();
+			this.entry1.Activated += new global::System.EventHandler (this.OnEntry1Activated);
+		}
+	}
 }
diff --git a/gsharp/gtk-gui/Mono.CSharp.Gui.MainWindow.cs b/gsharp/gtk-gui/Mono.CSharp.Gui.MainWindow.cs
index 7fb30cf..ad540d7 100644
--- a/gsharp/gtk-gui/Mono.CSharp.Gui.MainWindow.cs
+++ b/gsharp/gtk-gui/Mono.CSharp.Gui.MainWindow.cs
@@ -1,226 +1,193 @@
-// ------------------------------------------------------------------------------
-//  <autogenerated>
-//      This code was generated by a tool.
-//      
-// 
-//      Changes to this file may cause incorrect behavior and will be lost if 
-//      the code is regenerated.
-//  </autogenerated>
-// ------------------------------------------------------------------------------
 
-namespace Mono.CSharp.Gui {
-    
-    
-    public partial class MainWindow {
-        
-        private Gtk.UIManager UIManager;
-        
-        private Gtk.Action FileAction;
-        
-        private Gtk.Action QuitAction;
-        
-        private Gtk.Action AttachToProcessAction;
-        
-        private Gtk.Action HelpAction;
-        
-        private Gtk.Action AboutAction;
-        
-        private Gtk.Action ViewAction;
-        
-        private Gtk.ToggleAction gtkpane;
-        
-        private Gtk.Action ToolsAction;
-        
-        private Gtk.Action DescribeTypeAction;
-        
-        private Gtk.VBox vbox1;
-        
-        private Gtk.MenuBar menubar1;
-        
-        private Gtk.Notebook notebook1;
-        
-        private Gtk.HPaned hpaned;
-        
-        private Gtk.EventBox paned_container;
-        
-        private Gtk.VBox vbox2;
-        
-        private Gtk.Expander expander1;
-        
-        private Gtk.Label label4;
-        
-        private Gtk.Label GtkLabel4;
-        
-        private Gtk.EventBox eventbox;
-        
-        private Gtk.Label label1;
-        
-        private Gtk.EventBox standalone_container;
-        
-        private Gtk.Notebook shellnotebook;
-        
-        private Gtk.ScrolledWindow sw;
-        
-        private Gtk.Label label3;
-        
-        private Gtk.Label label2;
-        
-        protected virtual void Build() {
-            Stetic.Gui.Initialize(this);
-            // Widget Mono.CSharp.Gui.MainWindow
-            this.UIManager = new Gtk.UIManager();
-            Gtk.ActionGroup w1 = new Gtk.ActionGroup("Default");
-            this.FileAction = new Gtk.Action("FileAction", Mono.Unix.Catalog.GetString("_File"), null, null);
-            this.FileAction.ShortLabel = Mono.Unix.Catalog.GetString("File");
-            w1.Add(this.FileAction, null);
-            this.QuitAction = new Gtk.Action("QuitAction", Mono.Unix.Catalog.GetString("_Quit"), null, "gtk-quit");
-            this.QuitAction.ShortLabel = Mono.Unix.Catalog.GetString("_Quit");
-            w1.Add(this.QuitAction, null);
-            this.AttachToProcessAction = new Gtk.Action("AttachToProcessAction", Mono.Unix.Catalog.GetString("Attach to Process"), null, null);
-            this.AttachToProcessAction.ShortLabel = Mono.Unix.Catalog.GetString("Attach to Process");
-            w1.Add(this.AttachToProcessAction, null);
-            this.HelpAction = new Gtk.Action("HelpAction", Mono.Unix.Catalog.GetString("Help"), null, null);
-            this.HelpAction.ShortLabel = Mono.Unix.Catalog.GetString("Help");
-            w1.Add(this.HelpAction, null);
-            this.AboutAction = new Gtk.Action("AboutAction", Mono.Unix.Catalog.GetString("About"), null, null);
-            this.AboutAction.ShortLabel = Mono.Unix.Catalog.GetString("About");
-            w1.Add(this.AboutAction, null);
-            this.ViewAction = new Gtk.Action("ViewAction", Mono.Unix.Catalog.GetString("View"), null, null);
-            this.ViewAction.ShortLabel = Mono.Unix.Catalog.GetString("View");
-            w1.Add(this.ViewAction, null);
-            this.gtkpane = new Gtk.ToggleAction("gtkpane", Mono.Unix.Catalog.GetString("Gtk Pane"), null, null);
-            this.gtkpane.ShortLabel = Mono.Unix.Catalog.GetString("Gtk Pane");
-            w1.Add(this.gtkpane, null);
-            this.ToolsAction = new Gtk.Action("ToolsAction", Mono.Unix.Catalog.GetString("_Tools"), null, null);
-            this.ToolsAction.ShortLabel = Mono.Unix.Catalog.GetString("_Tools");
-            w1.Add(this.ToolsAction, null);
-            this.DescribeTypeAction = new Gtk.Action("DescribeTypeAction", Mono.Unix.Catalog.GetString("Describe Type"), null, null);
-            this.DescribeTypeAction.ShortLabel = Mono.Unix.Catalog.GetString("Describe Type");
-            w1.Add(this.DescribeTypeAction, null);
-            this.UIManager.InsertActionGroup(w1, 0);
-            this.AddAccelGroup(this.UIManager.AccelGroup);
-            this.Name = "Mono.CSharp.Gui.MainWindow";
-            this.Title = Mono.Unix.Catalog.GetString("MainWindow");
-            this.WindowPosition = ((Gtk.WindowPosition)(4));
-            this.DefaultWidth = 600;
-            this.DefaultHeight = 500;
-            // Container child Mono.CSharp.Gui.MainWindow.Gtk.Container+ContainerChild
-            this.vbox1 = new Gtk.VBox();
-            this.vbox1.Name = "vbox1";
-            this.vbox1.Spacing = 6;
-            // Container child vbox1.Gtk.Box+BoxChild
-            this.UIManager.AddUiFromString("<ui><menubar name='menubar1'><menu name='FileAction' action='FileAction'><menuitem name='AttachToProcessAction' action='AttachToProcessAction'/><separator/><menuitem name='QuitAction' action='QuitAction'/></menu><menu name='ViewAction' action='ViewAction'><menuitem name='gtkpane' action='gtkpane'/></menu><menu name='ToolsAction' action='ToolsAction'><menuitem name='DescribeTypeAction' action='DescribeTypeAction'/></menu><menu name='HelpAction' action='HelpAction'><menuitem name='AboutAction' action='AboutAction'/></menu></menubar></ui>");
-            this.menubar1 = ((Gtk.MenuBar)(this.UIManager.GetWidget("/menubar1")));
-            this.menubar1.Name = "menubar1";
-            this.vbox1.Add(this.menubar1);
-            Gtk.Box.BoxChild w2 = ((Gtk.Box.BoxChild)(this.vbox1[this.menubar1]));
-            w2.Position = 0;
-            w2.Expand = false;
-            w2.Fill = false;
-            // Container child vbox1.Gtk.Box+BoxChild
-            this.notebook1 = new Gtk.Notebook();
-            this.notebook1.CanFocus = true;
-            this.notebook1.Name = "notebook1";
-            this.notebook1.CurrentPage = 0;
-            this.notebook1.ShowBorder = false;
-            this.notebook1.ShowTabs = false;
-            // Container child notebook1.Gtk.Notebook+NotebookChild
-            this.hpaned = new Gtk.HPaned();
-            this.hpaned.CanFocus = true;
-            this.hpaned.Name = "hpaned";
-            this.hpaned.Position = 472;
-            // Container child hpaned.Gtk.Paned+PanedChild
-            this.paned_container = new Gtk.EventBox();
-            this.paned_container.Name = "paned_container";
-            this.hpaned.Add(this.paned_container);
-            Gtk.Paned.PanedChild w3 = ((Gtk.Paned.PanedChild)(this.hpaned[this.paned_container]));
-            w3.Resize = false;
-            // Container child hpaned.Gtk.Paned+PanedChild
-            this.vbox2 = new Gtk.VBox();
-            this.vbox2.Name = "vbox2";
-            this.vbox2.Spacing = 6;
-            // Container child vbox2.Gtk.Box+BoxChild
-            this.expander1 = new Gtk.Expander(null);
-            this.expander1.CanFocus = true;
-            this.expander1.Name = "expander1";
-            this.expander1.Expanded = true;
-            // Container child expander1.Gtk.Container+ContainerChild
-            this.label4 = new Gtk.Label();
-            this.label4.Name = "label4";
-            this.label4.Xpad = 10;
-            this.label4.Xalign = 0.1F;
-            this.label4.LabelProp = Mono.Unix.Catalog.GetString("Set the contents of this pane by adding Gtk.Widgets children to the <b>PaneContainer</b> property.  The PaneContainer is a Gtk.EventBox.   \n\nTry it like this:\n\nLoadPackage (\"gtk-sharp-2.0\");\nvar l = new Label (\"Hello world\");\nPaneContainer.Add (l);\nl.ShowAll ();");
-            this.label4.UseMarkup = true;
-            this.label4.Wrap = true;
-            this.expander1.Add(this.label4);
-            this.GtkLabel4 = new Gtk.Label();
-            this.GtkLabel4.Name = "GtkLabel4";
-            this.GtkLabel4.LabelProp = Mono.Unix.Catalog.GetString("<b>PaneContent</b>");
-            this.GtkLabel4.UseMarkup = true;
-            this.GtkLabel4.UseUnderline = true;
-            this.expander1.LabelWidget = this.GtkLabel4;
-            this.vbox2.Add(this.expander1);
-            Gtk.Box.BoxChild w5 = ((Gtk.Box.BoxChild)(this.vbox2[this.expander1]));
-            w5.Position = 0;
-            w5.Expand = false;
-            w5.Fill = false;
-            // Container child vbox2.Gtk.Box+BoxChild
-            this.eventbox = new Gtk.EventBox();
-            this.eventbox.Name = "eventbox";
-            this.vbox2.Add(this.eventbox);
-            Gtk.Box.BoxChild w6 = ((Gtk.Box.BoxChild)(this.vbox2[this.eventbox]));
-            w6.Position = 1;
-            this.hpaned.Add(this.vbox2);
-            this.notebook1.Add(this.hpaned);
-            // Notebook tab
-            this.label1 = new Gtk.Label();
-            this.label1.Name = "label1";
-            this.label1.LabelProp = Mono.Unix.Catalog.GetString("page1");
-            this.notebook1.SetTabLabel(this.hpaned, this.label1);
-            this.label1.ShowAll();
-            // Container child notebook1.Gtk.Notebook+NotebookChild
-            this.standalone_container = new Gtk.EventBox();
-            this.standalone_container.Name = "standalone_container";
-            // Container child standalone_container.Gtk.Container+ContainerChild
-            this.shellnotebook = new Gtk.Notebook();
-            this.shellnotebook.CanFocus = true;
-            this.shellnotebook.Name = "shellnotebook";
-            this.shellnotebook.CurrentPage = 0;
-            this.shellnotebook.ShowTabs = false;
-            this.shellnotebook.Scrollable = true;
-            // Container child shellnotebook.Gtk.Notebook+NotebookChild
-            this.sw = new Gtk.ScrolledWindow();
-            this.sw.CanFocus = true;
-            this.sw.Name = "sw";
-            this.sw.ShadowType = ((Gtk.ShadowType)(1));
-            this.shellnotebook.Add(this.sw);
-            // Notebook tab
-            this.label3 = new Gtk.Label();
-            this.label3.Name = "label3";
-            this.label3.LabelProp = Mono.Unix.Catalog.GetString("C#");
-            this.shellnotebook.SetTabLabel(this.sw, this.label3);
-            this.label3.ShowAll();
-            this.standalone_container.Add(this.shellnotebook);
-            this.notebook1.Add(this.standalone_container);
-            Gtk.Notebook.NotebookChild w11 = ((Gtk.Notebook.NotebookChild)(this.notebook1[this.standalone_container]));
-            w11.Position = 1;
-            // Notebook tab
-            this.label2 = new Gtk.Label();
-            this.label2.Name = "label2";
-            this.label2.LabelProp = Mono.Unix.Catalog.GetString("page2");
-            this.notebook1.SetTabLabel(this.standalone_container, this.label2);
-            this.label2.ShowAll();
-            this.vbox1.Add(this.notebook1);
-            Gtk.Box.BoxChild w12 = ((Gtk.Box.BoxChild)(this.vbox1[this.notebook1]));
-            w12.Position = 1;
-            this.Add(this.vbox1);
-            if ((this.Child != null)) {
-                this.Child.ShowAll();
-            }
-            this.Show();
-            this.QuitAction.Activated += new System.EventHandler(this.OnQuitActionActivated);
-            this.AttachToProcessAction.Activated += new System.EventHandler(this.OnAttachToProcessActionActivated);
-            this.DescribeTypeAction.Activated += new System.EventHandler(this.OnDescribeTypeActionActivated);
-        }
-    }
+// This file has been generated by the GUI designer. Do not modify.
+namespace Mono.CSharp.Gui
+{
+	public partial class MainWindow
+	{
+		private global::Gtk.UIManager UIManager;
+		private global::Gtk.Action FileAction;
+		private global::Gtk.Action QuitAction;
+		private global::Gtk.Action AttachToProcessAction;
+		private global::Gtk.Action HelpAction;
+		private global::Gtk.Action AboutAction;
+		private global::Gtk.Action ViewAction;
+		private global::Gtk.ToggleAction gtkpane;
+		private global::Gtk.Action ToolsAction;
+		private global::Gtk.Action DescribeTypeAction;
+		private global::Gtk.VBox vbox1;
+		private global::Gtk.MenuBar menubar1;
+		private global::Gtk.Notebook notebook1;
+		private global::Gtk.HPaned hpaned;
+		private global::Gtk.EventBox paned_container;
+		private global::Gtk.VBox vbox2;
+		private global::Gtk.Expander expander1;
+		private global::Gtk.Label label4;
+		private global::Gtk.Label GtkLabel4;
+		private global::Gtk.EventBox eventbox;
+		private global::Gtk.Label label1;
+		private global::Gtk.EventBox standalone_container;
+		private global::Gtk.Notebook shellnotebook;
+		private global::Gtk.ScrolledWindow sw;
+		private global::Gtk.Label label3;
+		private global::Gtk.Label label2;
+
+		protected virtual void Build ()
+		{
+			global::Stetic.Gui.Initialize (this);
+			// Widget Mono.CSharp.Gui.MainWindow
+			this.UIManager = new global::Gtk.UIManager ();
+			global::Gtk.ActionGroup w1 = new global::Gtk.ActionGroup ("Default");
+			this.FileAction = new global::Gtk.Action ("FileAction", global::Mono.Unix.Catalog.GetString ("_File"), null, null);
+			this.FileAction.ShortLabel = global::Mono.Unix.Catalog.GetString ("File");
+			w1.Add (this.FileAction, null);
+			this.QuitAction = new global::Gtk.Action ("QuitAction", global::Mono.Unix.Catalog.GetString ("_Quit"), null, "gtk-quit");
+			this.QuitAction.ShortLabel = global::Mono.Unix.Catalog.GetString ("_Quit");
+			w1.Add (this.QuitAction, null);
+			this.AttachToProcessAction = new global::Gtk.Action ("AttachToProcessAction", global::Mono.Unix.Catalog.GetString ("Attach to Process"), null, null);
+			this.AttachToProcessAction.ShortLabel = global::Mono.Unix.Catalog.GetString ("Attach to Process");
+			w1.Add (this.AttachToProcessAction, null);
+			this.HelpAction = new global::Gtk.Action ("HelpAction", global::Mono.Unix.Catalog.GetString ("Help"), null, null);
+			this.HelpAction.ShortLabel = global::Mono.Unix.Catalog.GetString ("Help");
+			w1.Add (this.HelpAction, null);
+			this.AboutAction = new global::Gtk.Action ("AboutAction", global::Mono.Unix.Catalog.GetString ("About"), null, null);
+			this.AboutAction.ShortLabel = global::Mono.Unix.Catalog.GetString ("About");
+			w1.Add (this.AboutAction, null);
+			this.ViewAction = new global::Gtk.Action ("ViewAction", global::Mono.Unix.Catalog.GetString ("View"), null, null);
+			this.ViewAction.ShortLabel = global::Mono.Unix.Catalog.GetString ("View");
+			w1.Add (this.ViewAction, null);
+			this.gtkpane = new global::Gtk.ToggleAction ("gtkpane", global::Mono.Unix.Catalog.GetString ("Gtk Pane"), null, null);
+			this.gtkpane.ShortLabel = global::Mono.Unix.Catalog.GetString ("Gtk Pane");
+			w1.Add (this.gtkpane, null);
+			this.ToolsAction = new global::Gtk.Action ("ToolsAction", global::Mono.Unix.Catalog.GetString ("_Tools"), null, null);
+			this.ToolsAction.ShortLabel = global::Mono.Unix.Catalog.GetString ("_Tools");
+			w1.Add (this.ToolsAction, null);
+			this.DescribeTypeAction = new global::Gtk.Action ("DescribeTypeAction", global::Mono.Unix.Catalog.GetString ("Describe Type"), null, null);
+			this.DescribeTypeAction.ShortLabel = global::Mono.Unix.Catalog.GetString ("Describe Type");
+			w1.Add (this.DescribeTypeAction, null);
+			this.UIManager.InsertActionGroup (w1, 0);
+			this.AddAccelGroup (this.UIManager.AccelGroup);
+			this.Name = "Mono.CSharp.Gui.MainWindow";
+			this.Title = global::Mono.Unix.Catalog.GetString ("MainWindow");
+			this.WindowPosition = ((global::Gtk.WindowPosition)(4));
+			this.DefaultWidth = 600;
+			this.DefaultHeight = 500;
+			// Container child Mono.CSharp.Gui.MainWindow.Gtk.Container+ContainerChild
+			this.vbox1 = new global::Gtk.VBox ();
+			this.vbox1.Name = "vbox1";
+			this.vbox1.Spacing = 6;
+			// Container child vbox1.Gtk.Box+BoxChild
+			this.UIManager.AddUiFromString ("<ui><menubar name='menubar1'><menu name='FileAction' action='FileAction'><menuitem name='AttachToProcessAction' action='AttachToProcessAction'/><separator/><menuitem name='QuitAction' action='QuitAction'/></menu><menu name='ViewAction' action='ViewAction'><menuitem name='gtkpane' action='gtkpane'/></menu><menu name='ToolsAction' action='ToolsAction'><menuitem name='DescribeTypeAction' action='DescribeTypeAction'/></menu><menu name='HelpAction' action='HelpAction'><menuitem name='AboutAction' action='AboutAction'/></menu></menubar></ui>");
+			this.menubar1 = ((global::Gtk.MenuBar)(this.UIManager.GetWidget ("/menubar1")));
+			this.menubar1.Name = "menubar1";
+			this.vbox1.Add (this.menubar1);
+			global::Gtk.Box.BoxChild w2 = ((global::Gtk.Box.BoxChild)(this.vbox1 [this.menubar1]));
+			w2.Position = 0;
+			w2.Expand = false;
+			w2.Fill = false;
+			// Container child vbox1.Gtk.Box+BoxChild
+			this.notebook1 = new global::Gtk.Notebook ();
+			this.notebook1.CanFocus = true;
+			this.notebook1.Name = "notebook1";
+			this.notebook1.CurrentPage = 0;
+			this.notebook1.ShowBorder = false;
+			this.notebook1.ShowTabs = false;
+			// Container child notebook1.Gtk.Notebook+NotebookChild
+			this.hpaned = new global::Gtk.HPaned ();
+			this.hpaned.CanFocus = true;
+			this.hpaned.Name = "hpaned";
+			this.hpaned.Position = 472;
+			// Container child hpaned.Gtk.Paned+PanedChild
+			this.paned_container = new global::Gtk.EventBox ();
+			this.paned_container.Name = "paned_container";
+			this.hpaned.Add (this.paned_container);
+			global::Gtk.Paned.PanedChild w3 = ((global::Gtk.Paned.PanedChild)(this.hpaned [this.paned_container]));
+			w3.Resize = false;
+			// Container child hpaned.Gtk.Paned+PanedChild
+			this.vbox2 = new global::Gtk.VBox ();
+			this.vbox2.Name = "vbox2";
+			this.vbox2.Spacing = 6;
+			// Container child vbox2.Gtk.Box+BoxChild
+			this.expander1 = new global::Gtk.Expander (null);
+			this.expander1.CanFocus = true;
+			this.expander1.Name = "expander1";
+			this.expander1.Expanded = true;
+			// Container child expander1.Gtk.Container+ContainerChild
+			this.label4 = new global::Gtk.Label ();
+			this.label4.Name = "label4";
+			this.label4.Xpad = 10;
+			this.label4.Xalign = 0.1F;
+			this.label4.LabelProp = global::Mono.Unix.Catalog.GetString ("Set the contents of this pane by adding Gtk.Widgets children to the <b>PaneContainer</b> property.  The PaneContainer is a Gtk.EventBox.   \n\nTry it like this:\n\nLoadPackage (\"gtk-sharp-2.0\");\nvar l = new Label (\"Hello world\");\nPaneContainer.Add (l);\nl.ShowAll ();");
+			this.label4.UseMarkup = true;
+			this.label4.Wrap = true;
+			this.expander1.Add (this.label4);
+			this.GtkLabel4 = new global::Gtk.Label ();
+			this.GtkLabel4.Name = "GtkLabel4";
+			this.GtkLabel4.LabelProp = global::Mono.Unix.Catalog.GetString ("<b>PaneContent</b>");
+			this.GtkLabel4.UseMarkup = true;
+			this.GtkLabel4.UseUnderline = true;
+			this.expander1.LabelWidget = this.GtkLabel4;
+			this.vbox2.Add (this.expander1);
+			global::Gtk.Box.BoxChild w5 = ((global::Gtk.Box.BoxChild)(this.vbox2 [this.expander1]));
+			w5.Position = 0;
+			w5.Expand = false;
+			w5.Fill = false;
+			// Container child vbox2.Gtk.Box+BoxChild
+			this.eventbox = new global::Gtk.EventBox ();
+			this.eventbox.Name = "eventbox";
+			this.vbox2.Add (this.eventbox);
+			global::Gtk.Box.BoxChild w6 = ((global::Gtk.Box.BoxChild)(this.vbox2 [this.eventbox]));
+			w6.Position = 1;
+			this.hpaned.Add (this.vbox2);
+			this.notebook1.Add (this.hpaned);
+			// Notebook tab
+			this.label1 = new global::Gtk.Label ();
+			this.label1.Name = "label1";
+			this.label1.LabelProp = global::Mono.Unix.Catalog.GetString ("page1");
+			this.notebook1.SetTabLabel (this.hpaned, this.label1);
+			this.label1.ShowAll ();
+			// Container child notebook1.Gtk.Notebook+NotebookChild
+			this.standalone_container = new global::Gtk.EventBox ();
+			this.standalone_container.Name = "standalone_container";
+			// Container child standalone_container.Gtk.Container+ContainerChild
+			this.shellnotebook = new global::Gtk.Notebook ();
+			this.shellnotebook.CanFocus = true;
+			this.shellnotebook.Name = "shellnotebook";
+			this.shellnotebook.CurrentPage = 0;
+			this.shellnotebook.ShowTabs = false;
+			this.shellnotebook.Scrollable = true;
+			// Container child shellnotebook.Gtk.Notebook+NotebookChild
+			this.sw = new global::Gtk.ScrolledWindow ();
+			this.sw.CanFocus = true;
+			this.sw.Name = "sw";
+			this.sw.ShadowType = ((global::Gtk.ShadowType)(1));
+			this.shellnotebook.Add (this.sw);
+			// Notebook tab
+			this.label3 = new global::Gtk.Label ();
+			this.label3.Name = "label3";
+			this.label3.LabelProp = global::Mono.Unix.Catalog.GetString ("C#");
+			this.shellnotebook.SetTabLabel (this.sw, this.label3);
+			this.label3.ShowAll ();
+			this.standalone_container.Add (this.shellnotebook);
+			this.notebook1.Add (this.standalone_container);
+			global::Gtk.Notebook.NotebookChild w11 = ((global::Gtk.Notebook.NotebookChild)(this.notebook1 [this.standalone_container]));
+			w11.Position = 1;
+			// Notebook tab
+			this.label2 = new global::Gtk.Label ();
+			this.label2.Name = "label2";
+			this.label2.LabelProp = global::Mono.Unix.Catalog.GetString ("page2");
+			this.notebook1.SetTabLabel (this.standalone_container, this.label2);
+			this.label2.ShowAll ();
+			this.vbox1.Add (this.notebook1);
+			global::Gtk.Box.BoxChild w12 = ((global::Gtk.Box.BoxChild)(this.vbox1 [this.notebook1]));
+			w12.Position = 1;
+			this.Add (this.vbox1);
+			if ((this.Child != null)) {
+				this.Child.ShowAll ();
+			}
+			this.Show ();
+			this.QuitAction.Activated += new global::System.EventHandler (this.OnQuitActionActivated);
+			this.AttachToProcessAction.Activated += new global::System.EventHandler (this.OnAttachToProcessActionActivated);
+			this.DescribeTypeAction.Activated += new global::System.EventHandler (this.OnDescribeTypeActionActivated);
+		}
+	}
 }
diff --git a/gsharp/gtk-gui/Mono.CSharp.Gui.ProcessSelector.cs b/gsharp/gtk-gui/Mono.CSharp.Gui.ProcessSelector.cs
index 3ae7cd7..fed8491 100644
--- a/gsharp/gtk-gui/Mono.CSharp.Gui.ProcessSelector.cs
+++ b/gsharp/gtk-gui/Mono.CSharp.Gui.ProcessSelector.cs
@@ -1,108 +1,94 @@
-// ------------------------------------------------------------------------------
-//  <autogenerated>
-//      This code was generated by a tool.
-//      
-// 
-//      Changes to this file may cause incorrect behavior and will be lost if 
-//      the code is regenerated.
-//  </autogenerated>
-// ------------------------------------------------------------------------------
 
-namespace Mono.CSharp.Gui {
-    
-    
-    public partial class ProcessSelector {
-        
-        private Gtk.Frame frame1;
-        
-        private Gtk.Alignment GtkAlignment;
-        
-        private Gtk.ScrolledWindow GtkScrolledWindow;
-        
-        private Gtk.TreeView treeview;
-        
-        private Gtk.Label GtkLabel;
-        
-        private Gtk.Button buttonCancel;
-        
-        private Gtk.Button buttonOk;
-        
-        protected virtual void Build() {
-            Stetic.Gui.Initialize(this);
-            // Widget Mono.CSharp.Gui.ProcessSelector
-            this.Name = "Mono.CSharp.Gui.ProcessSelector";
-            this.Title = Mono.Unix.Catalog.GetString("Select Mono Process to Attach");
-            this.WindowPosition = ((Gtk.WindowPosition)(4));
-            // Internal child Mono.CSharp.Gui.ProcessSelector.VBox
-            Gtk.VBox w1 = this.VBox;
-            w1.Name = "dialog1_VBox";
-            w1.BorderWidth = ((uint)(2));
-            // Container child dialog1_VBox.Gtk.Box+BoxChild
-            this.frame1 = new Gtk.Frame();
-            this.frame1.Name = "frame1";
-            this.frame1.ShadowType = ((Gtk.ShadowType)(0));
-            this.frame1.BorderWidth = ((uint)(2));
-            // Container child frame1.Gtk.Container+ContainerChild
-            this.GtkAlignment = new Gtk.Alignment(0F, 0F, 1F, 1F);
-            this.GtkAlignment.Name = "GtkAlignment";
-            this.GtkAlignment.LeftPadding = ((uint)(12));
-            // Container child GtkAlignment.Gtk.Container+ContainerChild
-            this.GtkScrolledWindow = new Gtk.ScrolledWindow();
-            this.GtkScrolledWindow.Name = "GtkScrolledWindow";
-            this.GtkScrolledWindow.ShadowType = ((Gtk.ShadowType)(1));
-            // Container child GtkScrolledWindow.Gtk.Container+ContainerChild
-            this.treeview = new Gtk.TreeView();
-            this.treeview.CanFocus = true;
-            this.treeview.Name = "treeview";
-            this.GtkScrolledWindow.Add(this.treeview);
-            this.GtkAlignment.Add(this.GtkScrolledWindow);
-            this.frame1.Add(this.GtkAlignment);
-            this.GtkLabel = new Gtk.Label();
-            this.GtkLabel.Name = "GtkLabel";
-            this.GtkLabel.LabelProp = Mono.Unix.Catalog.GetString("<b>Processes:</b>");
-            this.GtkLabel.UseMarkup = true;
-            this.frame1.LabelWidget = this.GtkLabel;
-            w1.Add(this.frame1);
-            Gtk.Box.BoxChild w5 = ((Gtk.Box.BoxChild)(w1[this.frame1]));
-            w5.Position = 0;
-            w5.Padding = ((uint)(3));
-            // Internal child Mono.CSharp.Gui.ProcessSelector.ActionArea
-            Gtk.HButtonBox w6 = this.ActionArea;
-            w6.Name = "dialog1_ActionArea";
-            w6.Spacing = 6;
-            w6.BorderWidth = ((uint)(5));
-            w6.LayoutStyle = ((Gtk.ButtonBoxStyle)(4));
-            // Container child dialog1_ActionArea.Gtk.ButtonBox+ButtonBoxChild
-            this.buttonCancel = new Gtk.Button();
-            this.buttonCancel.CanDefault = true;
-            this.buttonCancel.CanFocus = true;
-            this.buttonCancel.Name = "buttonCancel";
-            this.buttonCancel.UseStock = true;
-            this.buttonCancel.UseUnderline = true;
-            this.buttonCancel.Label = "gtk-cancel";
-            this.AddActionWidget(this.buttonCancel, -6);
-            Gtk.ButtonBox.ButtonBoxChild w7 = ((Gtk.ButtonBox.ButtonBoxChild)(w6[this.buttonCancel]));
-            w7.Expand = false;
-            w7.Fill = false;
-            // Container child dialog1_ActionArea.Gtk.ButtonBox+ButtonBoxChild
-            this.buttonOk = new Gtk.Button();
-            this.buttonOk.CanDefault = true;
-            this.buttonOk.CanFocus = true;
-            this.buttonOk.Name = "buttonOk";
-            this.buttonOk.UseUnderline = true;
-            this.buttonOk.Label = Mono.Unix.Catalog.GetString("_Attach");
-            this.AddActionWidget(this.buttonOk, -5);
-            Gtk.ButtonBox.ButtonBoxChild w8 = ((Gtk.ButtonBox.ButtonBoxChild)(w6[this.buttonOk]));
-            w8.Position = 1;
-            w8.Expand = false;
-            w8.Fill = false;
-            if ((this.Child != null)) {
-                this.Child.ShowAll();
-            }
-            this.DefaultWidth = 400;
-            this.DefaultHeight = 300;
-            this.Show();
-            this.Close += new System.EventHandler(this.OnClose);
-        }
-    }
+// This file has been generated by the GUI designer. Do not modify.
+namespace Mono.CSharp.Gui
+{
+	public partial class ProcessSelector
+	{
+		private global::Gtk.Frame frame1;
+		private global::Gtk.Alignment GtkAlignment;
+		private global::Gtk.ScrolledWindow GtkScrolledWindow;
+		private global::Gtk.TreeView treeview;
+		private global::Gtk.Label GtkLabel;
+		private global::Gtk.Button buttonCancel;
+		private global::Gtk.Button buttonOk;
+
+		protected virtual void Build ()
+		{
+			global::Stetic.Gui.Initialize (this);
+			// Widget Mono.CSharp.Gui.ProcessSelector
+			this.Name = "Mono.CSharp.Gui.ProcessSelector";
+			this.Title = global::Mono.Unix.Catalog.GetString ("Select Mono Process to Attach");
+			this.WindowPosition = ((global::Gtk.WindowPosition)(4));
+			// Internal child Mono.CSharp.Gui.ProcessSelector.VBox
+			global::Gtk.VBox w1 = this.VBox;
+			w1.Name = "dialog1_VBox";
+			w1.BorderWidth = ((uint)(2));
+			// Container child dialog1_VBox.Gtk.Box+BoxChild
+			this.frame1 = new global::Gtk.Frame ();
+			this.frame1.Name = "frame1";
+			this.frame1.ShadowType = ((global::Gtk.ShadowType)(0));
+			this.frame1.BorderWidth = ((uint)(2));
+			// Container child frame1.Gtk.Container+ContainerChild
+			this.GtkAlignment = new global::Gtk.Alignment (0F, 0F, 1F, 1F);
+			this.GtkAlignment.Name = "GtkAlignment";
+			this.GtkAlignment.LeftPadding = ((uint)(12));
+			// Container child GtkAlignment.Gtk.Container+ContainerChild
+			this.GtkScrolledWindow = new global::Gtk.ScrolledWindow ();
+			this.GtkScrolledWindow.Name = "GtkScrolledWindow";
+			this.GtkScrolledWindow.ShadowType = ((global::Gtk.ShadowType)(1));
+			// Container child GtkScrolledWindow.Gtk.Container+ContainerChild
+			this.treeview = new global::Gtk.TreeView ();
+			this.treeview.CanFocus = true;
+			this.treeview.Name = "treeview";
+			this.GtkScrolledWindow.Add (this.treeview);
+			this.GtkAlignment.Add (this.GtkScrolledWindow);
+			this.frame1.Add (this.GtkAlignment);
+			this.GtkLabel = new global::Gtk.Label ();
+			this.GtkLabel.Name = "GtkLabel";
+			this.GtkLabel.LabelProp = global::Mono.Unix.Catalog.GetString ("<b>Processes:</b>");
+			this.GtkLabel.UseMarkup = true;
+			this.frame1.LabelWidget = this.GtkLabel;
+			w1.Add (this.frame1);
+			global::Gtk.Box.BoxChild w5 = ((global::Gtk.Box.BoxChild)(w1 [this.frame1]));
+			w5.Position = 0;
+			w5.Padding = ((uint)(3));
+			// Internal child Mono.CSharp.Gui.ProcessSelector.ActionArea
+			global::Gtk.HButtonBox w6 = this.ActionArea;
+			w6.Name = "dialog1_ActionArea";
+			w6.Spacing = 6;
+			w6.BorderWidth = ((uint)(5));
+			w6.LayoutStyle = ((global::Gtk.ButtonBoxStyle)(4));
+			// Container child dialog1_ActionArea.Gtk.ButtonBox+ButtonBoxChild
+			this.buttonCancel = new global::Gtk.Button ();
+			this.buttonCancel.CanDefault = true;
+			this.buttonCancel.CanFocus = true;
+			this.buttonCancel.Name = "buttonCancel";
+			this.buttonCancel.UseStock = true;
+			this.buttonCancel.UseUnderline = true;
+			this.buttonCancel.Label = "gtk-cancel";
+			this.AddActionWidget (this.buttonCancel, -6);
+			global::Gtk.ButtonBox.ButtonBoxChild w7 = ((global::Gtk.ButtonBox.ButtonBoxChild)(w6 [this.buttonCancel]));
+			w7.Expand = false;
+			w7.Fill = false;
+			// Container child dialog1_ActionArea.Gtk.ButtonBox+ButtonBoxChild
+			this.buttonOk = new global::Gtk.Button ();
+			this.buttonOk.CanDefault = true;
+			this.buttonOk.CanFocus = true;
+			this.buttonOk.Name = "buttonOk";
+			this.buttonOk.UseUnderline = true;
+			this.buttonOk.Label = global::Mono.Unix.Catalog.GetString ("_Attach");
+			this.AddActionWidget (this.buttonOk, -5);
+			global::Gtk.ButtonBox.ButtonBoxChild w8 = ((global::Gtk.ButtonBox.ButtonBoxChild)(w6 [this.buttonOk]));
+			w8.Position = 1;
+			w8.Expand = false;
+			w8.Fill = false;
+			if ((this.Child != null)) {
+				this.Child.ShowAll ();
+			}
+			this.DefaultWidth = 400;
+			this.DefaultHeight = 300;
+			this.Show ();
+			this.Close += new global::System.EventHandler (this.OnClose);
+		}
+	}
 }
diff --git a/gsharp/gtk-gui/generated.cs b/gsharp/gtk-gui/generated.cs
index 8b467a5..9ef3363 100644
--- a/gsharp/gtk-gui/generated.cs
+++ b/gsharp/gtk-gui/generated.cs
@@ -1,35 +1,29 @@
-// ------------------------------------------------------------------------------
-//  <autogenerated>
-//      This code was generated by a tool.
-//      
-// 
-//      Changes to this file may cause incorrect behavior and will be lost if 
-//      the code is regenerated.
-//  </autogenerated>
-// ------------------------------------------------------------------------------
 
-namespace Stetic {
-    
-    
-    internal class Gui {
-        
-        private static bool initialized;
-        
-        internal static void Initialize(Gtk.Widget iconRenderer) {
-            if ((Stetic.Gui.initialized == false)) {
-                Stetic.Gui.initialized = true;
-            }
-        }
-    }
-    
-    internal class ActionGroups {
-        
-        public static Gtk.ActionGroup GetActionGroup(System.Type type) {
-            return Stetic.ActionGroups.GetActionGroup(type.FullName);
-        }
-        
-        public static Gtk.ActionGroup GetActionGroup(string name) {
-            return null;
-        }
-    }
+// This file has been generated by the GUI designer. Do not modify.
+namespace Stetic
+{
+	internal class Gui
+	{
+		private static bool initialized;
+
+		internal static void Initialize (Gtk.Widget iconRenderer)
+		{
+			if ((Stetic.Gui.initialized == false)) {
+				Stetic.Gui.initialized = true;
+			}
+		}
+	}
+
+	internal class ActionGroups
+	{
+		public static Gtk.ActionGroup GetActionGroup (System.Type type)
+		{
+			return Stetic.ActionGroups.GetActionGroup (type.FullName);
+		}
+
+		public static Gtk.ActionGroup GetActionGroup (string name)
+		{
+			return null;
+		}
+	}
 }
diff --git a/gui-compare/CecilMetadata.cs b/gui-compare/CecilMetadata.cs
index 2387b5e..df43b5e 100644
--- a/gui-compare/CecilMetadata.cs
+++ b/gui-compare/CecilMetadata.cs
@@ -923,6 +923,7 @@ namespace GuiCompare {
 		                                               MethodAttributes.Static |
 		                                               MethodAttributes.Abstract |
 		                                               MethodAttributes.HideBySig |
+//		                                               MethodAttributes.HasSecurity |
 		                                               MethodAttributes.SpecialName);
 		public override string GetMemberAccess ()
 		{
@@ -1011,15 +1012,24 @@ namespace GuiCompare {
 			sb.Append ('(');
 			bool first_p = true;
 			foreach (ParameterDefinition p in method_def.Parameters) {
+				TypeReference paramType = p.ParameterType;
 				if (!first_p)
 					sb.Append (", ");
 				first_p = false;
 				if (p.IsIn)
 					sb.Append ("in ");
-				else if (p.IsOut)
+				else if (paramType.IsByReference) {
+					if (beautify) {
+						sb.Append (p.IsOut ? "out " : "ref ");
+						paramType = paramType.GetElementType ();
+					} else if (p.IsOut) {
+						sb.Append ("out ");
+					}
+				} else if (p.IsOut) {
 					sb.Append ("out ");
+				}
 				sb.Append (beautify
-				           ? CecilUtils.PrettyType (p.ParameterType)
+				           ? CecilUtils.PrettyType (paramType)
 				           : CecilUtils.FormatTypeLikeCorCompare (p.ParameterType));
 				if (beautify) {
 					sb.Append (" ");
@@ -1179,55 +1189,213 @@ namespace GuiCompare {
 		public CecilAttribute (CustomAttribute ca)
 			: base (ca.Constructor.DeclaringType.FullName)
 		{
-			var sb = new StringBuilder ("[" + ca.Constructor.DeclaringType.FullName);
-			bool first = true;
-			
-			var cargs = ca.ConstructorArguments;
-			if (cargs != null && cargs.Count > 0) {
-				foreach (var argument in cargs) {
-					if (first) {
-						sb.Append (" (");
-						first = false;
-					} else
-						sb.Append (", ");
+			Dictionary<string, object> attribute_mapping = CreateAttributeMapping (ca);
+
+			foreach (string name in attribute_mapping.Keys) {
+				if (name == "TypeId")
+					continue;
+
+				object o = attribute_mapping[name];
+				Properties.Add (name, o == null ? "null" : o.ToString ());
+			}
+		}
+
+		static Dictionary<string, object> CreateAttributeMapping (CustomAttribute attribute)
+		{
+			var mapping = new Dictionary<string, object> ();
+
+			PopulateMapping (mapping, attribute);
+
+			var constructor = attribute.Constructor.Resolve ();
+			if (constructor == null || constructor.Parameters.Count == 0)
+				return mapping;
+
+			PopulateMapping (mapping, constructor, attribute);
+
+			return mapping;
+		}
+
+		static void PopulateMapping (Dictionary<string, object> mapping, CustomAttribute attribute)
+		{
+			foreach (var named_argument in attribute.Properties) {
+				var name = named_argument.Name;
+				var arg = named_argument.Argument;
+
+				if (arg.Value is CustomAttributeArgument)
+					arg = (CustomAttributeArgument) arg.Value;
+
+				mapping.Add (name, GetArgumentValue (arg.Type, arg.Value));
+			}
+		}
 
-					sb.Append (FormatValue (argument.Value));
+		static Dictionary<FieldReference, int> CreateArgumentFieldMapping (MethodDefinition constructor)
+		{
+			Dictionary<FieldReference, int> field_mapping = new Dictionary<FieldReference, int> ();
+
+			int? argument = null;
+
+			foreach (Instruction instruction in constructor.Body.Instructions) {
+				switch (instruction.OpCode.Code) {
+				case Code.Ldarg_1:
+					argument = 1;
+					break;
+				case Code.Ldarg_2:
+					argument = 2;
+					break;
+				case Code.Ldarg_3:
+					argument = 3;
+					break;
+				case Code.Ldarg:
+				case Code.Ldarg_S:
+					argument = ((ParameterDefinition) instruction.Operand).Index + 1;
+					break;
+
+				case Code.Stfld:
+					FieldReference field = (FieldReference) instruction.Operand;
+					if (field.DeclaringType.FullName != constructor.DeclaringType.FullName)
+						continue;
+
+					if (!argument.HasValue)
+						break;
+
+					if (!field_mapping.ContainsKey (field))
+						field_mapping.Add (field, (int) argument - 1);
+
+					argument = null;
+					break;
 				}
+			}
+
+			return field_mapping;
+		}
+
+		static Dictionary<PropertyDefinition, FieldReference> CreatePropertyFieldMapping (TypeDefinition type)
+		{
+			Dictionary<PropertyDefinition, FieldReference> property_mapping = new Dictionary<PropertyDefinition, FieldReference> ();
+
+			foreach (PropertyDefinition property in type.Properties) {
+				if (property.GetMethod == null)
+					continue;
+				if (!property.GetMethod.HasBody)
+					continue;
+
+				foreach (Instruction instruction in property.GetMethod.Body.Instructions) {
+					if (instruction.OpCode.Code != Code.Ldfld)
+						continue;
+
+					FieldReference field = (FieldReference) instruction.Operand;
+					if (field.DeclaringType.FullName != type.FullName)
+						continue;
+
+					property_mapping.Add (property, field);
+					break;
+				}
+			}
+
+			return property_mapping;
+		}
+
+		static void PopulateMapping (Dictionary<string, object> mapping, MethodDefinition constructor, CustomAttribute attribute)
+		{
+			if (!constructor.HasBody)
+				return;
+
+			if (constructor.DeclaringType.FullName == "System.Runtime.CompilerServices.DecimalConstantAttribute") {
+				var ca = attribute.ConstructorArguments;
+				var dca = constructor.Parameters[2].ParameterType == constructor.Module.TypeSystem.Int32 ?
+					new DecimalConstantAttribute ((byte) ca[0].Value, (byte) ca[1].Value, (int) ca[2].Value, (int) ca[3].Value, (int) ca[4].Value) :
+					new DecimalConstantAttribute ((byte) ca[0].Value, (byte) ca[1].Value, (uint) ca[2].Value, (uint) ca[3].Value, (uint) ca[4].Value);
+
+				mapping.Add ("Value", dca.Value);
+				return;
+			}
+
+			var field_mapping = CreateArgumentFieldMapping (constructor);
+			var property_mapping = CreatePropertyFieldMapping ((TypeDefinition) constructor.DeclaringType);
+
+			foreach (var pair in property_mapping) {
+				int argument;
+				if (!field_mapping.TryGetValue (pair.Value, out argument))
+					continue;
+
+				var ca_arg = attribute.ConstructorArguments[argument];
+				if (ca_arg.Value is CustomAttributeArgument)
+					ca_arg = (CustomAttributeArgument) ca_arg.Value;
 				
+				mapping[pair.Key.Name] = GetArgumentValue (ca_arg.Type, ca_arg.Value);
 			}
+		}
 
-			var properties = ca.Properties;
-			if (properties != null && properties.Count > 0) {
-				foreach (var namedArg in properties) {
-					if (first) {
-						sb.Append (" (");
-						first = false;
-					} else
-						sb.Append (", ");
-					
-					sb.AppendFormat ("{0}={1}", namedArg.Name, FormatValue (namedArg.Argument.Value));
+		static object GetArgumentValue (TypeReference reference, object value)
+		{
+			var type = reference.Resolve ();
+			if (type == null)
+				return value;
+
+			if (type.IsEnum) {
+				if (IsFlaggedEnum (type))
+					return GetFlaggedEnumValue (type, value);
+
+				return GetEnumValue (type, value);
+			}
+
+			return value;
+		}
+
+		static bool IsFlaggedEnum (TypeDefinition type)
+		{
+			if (!type.IsEnum)
+				return false;
+
+			if (type.CustomAttributes.Count == 0)
+				return false;
+
+			foreach (CustomAttribute attribute in type.CustomAttributes)
+				if (attribute.Constructor.DeclaringType.FullName == "System.FlagsAttribute")
+					return true;
+
+			return false;
+		}
+
+		static object GetFlaggedEnumValue (TypeDefinition type, object value)
+		{
+			long flags = Convert.ToInt64 (value);
+			var signature = new StringBuilder ();
+
+			for (int i = type.Fields.Count - 1; i >= 0; i--) {
+				FieldDefinition field = type.Fields[i];
+
+				if (!field.HasConstant)
+					continue;
+
+				long flag = Convert.ToInt64 (field.Constant);
+
+				if (flag == 0)
+					continue;
+
+				if ((flags & flag) == flag) {
+					if (signature.Length != 0)
+						signature.Append (", ");
+
+					signature.Append (field.Name);
+					flags -= flag;
 				}
 			}
-			
-			if (!first)
-				sb.Append (')');
-			sb.Append ("]");
-			
-			ExtraInfo = sb.ToString ();
+
+			return signature.ToString ();
 		}
 
-		string FormatValue (object o)
+		static object GetEnumValue (TypeDefinition type, object value)
 		{
-			if (o == null)
-				return "null";
+			foreach (FieldDefinition field in type.Fields) {
+				if (!field.HasConstant)
+					continue;
 
-			if (o is string)
-				return "\"" + o + "\"";
+				if (Comparer.Default.Compare (field.Constant, value) == 0)
+					return field.Name;
+			}
 
-			if (o is bool)
-				return o.ToString ().ToLowerInvariant ();
-			
-			return o.ToString ();
+			return value;
 		}
 	}
 
diff --git a/gui-compare/CompareContext.cs b/gui-compare/CompareContext.cs
index 8a3b932..b171ef8 100644
--- a/gui-compare/CompareContext.cs
+++ b/gui-compare/CompareContext.cs
@@ -26,6 +26,7 @@
 using System;
 using System.Collections.Generic;
 using System.Threading;
+using System.Linq;
 
 namespace GuiCompare {
 
@@ -153,7 +154,7 @@ namespace GuiCompare {
 		void CompareBaseTypes (ComparisonNode parent, ICompHasBaseType reference_type, ICompHasBaseType target_type)
 		{
 			if (reference_type.GetBaseType() != target_type.GetBaseType()) {
-				parent.AddError (String.Format ("reference has base class of {0}, target has base class of {1}",
+				parent.AddError (String.Format ("Expected base class of {0} but found {1}",
 								reference_type.GetBaseType(),
 								target_type.GetBaseType()));
 			}
@@ -162,7 +163,7 @@ namespace GuiCompare {
 				string ref_mod = (reference_type.IsAbstract && reference_type.IsSealed) ? "static" : "abstract";
 				string tar_mod = (target_type.IsAbstract && target_type.IsSealed) ? "static" : "abstract";
 
-				parent.AddError (String.Format ("reference is {0} {2}, target is {1} {3}",
+				parent.AddError (String.Format ("reference is {0} {2}, is {1} {3}",
 								reference_type.IsAbstract ? null : "not", target_type.IsAbstract ? null : "not",
 								ref_mod, tar_mod));
 			} else if (reference_type.IsSealed != target_type.IsSealed) {
@@ -211,19 +212,15 @@ namespace GuiCompare {
 		{
 			var r = reference.GetTypeParameters ();
 			var t = target.GetTypeParameters ();
-			if (r == null && t == null)
+			if (r == null && t == null || (r == null && t != null) || (r != null && t == null))
 				return;
 
-			if (r.Count != t.Count) {
-				throw new NotImplementedException (string.Format ("Should never happen with valid data ({0} != {1})", r.Count, t.Count));
-			}
-
 			for (int i = 0; i < r.Count; ++i) {
 				var r_i = r [i];
 				var t_i = t [i];
 				
 				if (r_i.GenericAttributes != t_i.GenericAttributes) {
-					parent.AddError (string.Format ("reference type parameter {2} has {0} generic attributes, target type parameter {3} has {1} generic attributes",
+					parent.AddError (string.Format ("Expected type parameter {2} with {0} generic attributes but found type parameter {3} with {1} generic attributes",
 						CompGenericParameter.GetGenericAttributeDesc (r_i.GenericAttributes),
 						CompGenericParameter.GetGenericAttributeDesc (t_i.GenericAttributes),
 						r_i.Name,
@@ -324,13 +321,42 @@ namespace GuiCompare {
 			
 			List<CompNamed> reference_attrs = reference_container.GetAttributes ();
 			List<CompNamed> target_attrs = target_container.GetAttributes ();
-			
-			reference_attrs.Sort (CompNamed.Compare);
-			target_attrs.Sort (CompNamed.Compare);
+
+			Comparison<CompNamed> comp = (x, y) => {
+				var r = CompNamed.Compare (x, y);
+				if (r != 0)
+					return r;
+
+				var xa = ((CompAttribute)x).Properties.Values.ToList ();
+				var ya = ((CompAttribute)y).Properties.Values.ToList ();
+
+				for (int i = 0; i < Math.Min (xa.Count, ya.Count); ++i) {
+					r = xa[i].CompareTo (ya[i]);
+					if (r != 0)
+						return r;
+				}
+
+				return 0;
+			};
+
+			reference_attrs.Sort (comp);
+			target_attrs.Sort (comp);
 			
 			while (m < reference_attrs.Count || a < target_attrs.Count) {
 				if (m == reference_attrs.Count) {
-					AddExtra (parent, target_attrs[a]);
+					
+					switch (target_attrs[a].Name) {
+						case "System.Diagnostics.DebuggerDisplayAttribute":
+						case "System.Runtime.CompilerServices.AsyncStateMachineAttribute":
+						case "System.Runtime.CompilerServices.IteratorStateMachineAttribute":
+						case "System.Diagnostics.DebuggerBrowsableAttribute":
+							// Ignore extra attributes in Mono source code
+						break;
+					default:
+						AddExtra (parent, target_attrs[a]);
+						break;
+					}
+					
 					a++;
 					continue;
 				}
@@ -345,10 +371,9 @@ namespace GuiCompare {
 
 				if (c == 0) {
 					/* the names match, further investigation is required */
-// 					Console.WriteLine ("method {0} is in both, doing more comparisons", reference_list[m].Name);
 					ComparisonNode comparison = target_attrs[a].GetComparisonNode();
 					parent.AddChild (comparison);
-					//CompareParameters (comparison, reference_list[m], target_namespace [target_list[a]]);
+					CompareAttributeArguments (comparison, (CompAttribute)reference_attrs[m], (CompAttribute)target_attrs[a]);
 					m++;
 					a++;
 				}
@@ -364,27 +389,120 @@ namespace GuiCompare {
 				}
 			}
 		}
+
+		void CompareAttributeArguments (ComparisonNode parent, CompAttribute referenceAttribute, CompAttribute actualAttribute)
+		{
+			// Ignore all parameter differences for some attributes
+			switch (referenceAttribute.Name) {
+			case "System.Diagnostics.DebuggerDisplayAttribute":
+			case "System.Diagnostics.DebuggerTypeProxyAttribute":
+			case "System.Runtime.CompilerServices.CompilationRelaxationsAttribute":
+			case "System.Reflection.AssemblyFileVersionAttribute":
+			case "System.Reflection.AssemblyCompanyAttribute":
+			case "System.Reflection.AssemblyCopyrightAttribute":
+			case "System.Reflection.AssemblyProductAttribute":
+			case "System.Reflection.AssemblyTrademarkAttribute":
+			case "System.Reflection.AssemblyInformationalVersionAttribute":
+			case "System.Reflection.AssemblyKeyFileAttribute":
+
+			// Don't care about these for now
+			case "System.ComponentModel.EditorAttribute":
+			case "System.ComponentModel.DesignerAttribute":
+				return;
+			}
+
+			foreach (var entry in referenceAttribute.Properties) {
+				if (!actualAttribute.Properties.ContainsKey (entry.Key)) {
+
+					//
+					// Ignore missing value difference for default values
+					//
+					switch (referenceAttribute.Name) {
+					case "System.AttributeUsageAttribute":
+						// AllowMultiple defaults to false
+						if (entry.Key == "AllowMultiple" && entry.Value == "False")
+							continue;
+						// Inherited defaults to true
+						if (entry.Key == "Inherited" && entry.Value == "True")
+							continue;
+						break;
+					case "System.ObsoleteAttribute":
+						if (entry.Key == "IsError" && entry.Value == "False")
+							continue;
+
+						if (entry.Key == "Message")
+							continue;
+
+						break;
+					}
+
+					parent.AddError (String.Format ("Property `{0}' value is not set. Expected value: {1}", entry.Key, entry.Value));
+					parent.Status = ComparisonStatus.Error;
+					continue;
+				}
+
+				var target_value = actualAttribute.Properties[entry.Key];
+
+				switch (referenceAttribute.Name) {
+				case "System.Runtime.CompilerServices.TypeForwardedFromAttribute":
+					if (entry.Key == "AssemblyFullName")
+						target_value = target_value.Replace ("neutral", "Neutral");
+					break;
+				case "System.Runtime.InteropServices.GuidAttribute":
+					if (entry.Key == "Value")
+						target_value = target_value.ToUpperInvariant ();
+					break;
+				case "System.ObsoleteAttribute":
+					if (entry.Key == "Message")
+						continue;
+
+					break;
+				}
+
+				if (target_value != entry.Value) {
+					parent.AddError (String.Format ("Expected value `{0}' for attribute property `{1}' but found `{2}'", entry.Value, entry.Key, target_value));
+					parent.Status = ComparisonStatus.Error;
+				}
+			}
+
+			
+			if (referenceAttribute.Properties.Count != actualAttribute.Properties.Count) {
+				foreach (var entry in actualAttribute.Properties) {
+					if (!referenceAttribute.Properties.ContainsKey (entry.Key)) {
+						parent.AddError (String.Format ("Property `{0}' should not be set", entry.Key));
+						parent.Status = ComparisonStatus.Error;
+						break;
+					}
+				}
+			}
+			
+
+			return;
+		}
 		
 		void CompareMembers (ComparisonNode parent,
 		                     ICompMemberContainer reference_container, ICompMemberContainer target_container)
 		{
+			bool is_sealed = reference_container.IsSealed;
+			
 			CompareMemberLists (parent,
-			                    reference_container.GetInterfaces(), target_container.GetInterfaces());
+			                    reference_container.GetInterfaces(), target_container.GetInterfaces(), is_sealed);
 			CompareMemberLists (parent,
-			                    reference_container.GetConstructors(), target_container.GetConstructors());
+			                    reference_container.GetConstructors(), target_container.GetConstructors(), is_sealed);
 			CompareMemberLists (parent,
-			                    reference_container.GetMethods(), target_container.GetMethods());
+			                    reference_container.GetMethods(), target_container.GetMethods(), is_sealed);
 			CompareMemberLists (parent,
-			                    reference_container.GetProperties(), target_container.GetProperties());
+			                    reference_container.GetProperties(), target_container.GetProperties(), is_sealed);
 			CompareMemberLists (parent,
-			                    reference_container.GetFields(), target_container.GetFields());
+			                    reference_container.GetFields(), target_container.GetFields(), is_sealed);
 			CompareMemberLists (parent,
-			                    reference_container.GetEvents(), target_container.GetEvents());
+			                    reference_container.GetEvents(), target_container.GetEvents(), is_sealed);
 		}
 
 		void CompareMemberLists (ComparisonNode parent,
 		                         List<CompNamed> reference_list,
-		                         List<CompNamed> target_list)
+		                         List<CompNamed> target_list,
+		                         bool isSealed)
 		{
 			int m = 0, a = 0;
 
@@ -427,9 +545,9 @@ namespace GuiCompare {
 							// Try to give some hints to the developer, best we can do with
 							// strings.
 							string extra_msg = "";
-							if (reference_access.IndexOf ("Public, Final, Virtual, HideBySig") != -1 &&
+							if (reference_access.IndexOf ("Private, Final, Virtual, HideBySig") != -1 &&
 							    target_access.IndexOf ("Public, HideBySig") != -1){
-								extra_msg = "\n\t\t<b>Hint:</b> reference uses an implicit interface implementation, target doesn't";
+								extra_msg = "\n\t\t<b>Hint:</b> reference uses an explicit interface implementation, target doesn't";
 							}
 
 							comparison.AddError (String.Format ("reference access is '<i>{0}</i>', target access is '<i>{1}</i>'{2}",
@@ -447,13 +565,53 @@ namespace GuiCompare {
 
 						CompareTypeParameters (comparison, r_method, t_method);
 						CompareParameters (comparison, r_method, t_method);
+					} else if (reference_list[m] is CompProperty) {
+						var m1 = ((CompProperty) reference_list[m]).GetMethods ();
+						var m2 = ((CompProperty) target_list[a]).GetMethods ();
+						if (m1.Count != m2.Count) {
+							comparison.AddError (String.Format ("Expected {0} accessors but found {1}", m1.Count, m2.Count));
+							comparison.Status = ComparisonStatus.Error;
+						} else {
+							for (int i = 0; i < m1.Count; ++i) {
+								string reference_access = ((CompMember) m1[i]).GetMemberAccess();
+								string target_access = ((CompMember) m2[i]).GetMemberAccess();
+								if (reference_access != target_access) {
+									// Try to give some hints to the developer, best we can do with
+									// strings.
+									string extra_msg = "";
+									if (reference_access.IndexOf ("Private, Final, Virtual, HideBySig") != -1 &&
+										target_access.IndexOf ("Public, HideBySig") != -1){
+										extra_msg = "\n\t\t<b>Hint:</b> reference uses an explicit interface implementation, target doesn't";
+									}
+
+									comparison.AddError (String.Format ("reference access is '<i>{0}</i>', target access is '<i>{1}</i>'{2}",
+																		reference_access, target_access, extra_msg));
+									comparison.Status = ComparisonStatus.Error;
+									break;
+								}
+							}
+							
+							if (m1[0].Name[0] == m2[0].Name[0]) {
+								CompareAttributes (comparison, (ICompAttributeContainer)m1[0], (ICompAttributeContainer)m2[0]);
+								if (m1.Count > 1)
+									CompareAttributes (comparison, (ICompAttributeContainer)m1[1], (ICompAttributeContainer)m2[1]);
+							} else {
+								CompareAttributes (comparison, (ICompAttributeContainer)m1[0], (ICompAttributeContainer)m2[1]);
+								if (m1.Count > 1)
+									CompareAttributes (comparison, (ICompAttributeContainer)m1[1], (ICompAttributeContainer)m2[0]);
+							}
+						}
+
+						// Compare indexer parameters
+						if (m1.Count == m2.Count)
+							CompareParameters (comparison, (ICompParameters) m1[0], (ICompParameters) m2[0]);
 					}
 
 					if (reference_list[m] is CompField) {
 						var v_ref = ((CompField)reference_list[m]).GetLiteralValue();
 						var v_tar = ((CompField)target_list[a]).GetLiteralValue();
 						if (v_ref != v_tar) {
-							comparison.AddError (String.Format ("reference field has value {0}, target field has value {1}", v_ref, v_tar));
+							comparison.AddError (String.Format ("Expected field value {0} but found value {1}", v_ref, v_tar));
 							comparison.Status = ComparisonStatus.Error;
 						}
 					}
@@ -476,13 +634,23 @@ namespace GuiCompare {
 					a++;
 				}
 				else if (c < 0) {
-					/* reference name is before target name, reference name is missing from target */
-					AddMissing (parent, reference_list[m]);
+					if (isSealed && reference_list[m].Name.Contains ("~")) {
+						// Ignore finalizer differences in sealed classes
+					} else {
+						/* reference name is before target name, reference name is missing from target */
+						AddMissing (parent, reference_list[m]);
+					}
+					
 					m++;
 				}
 				else {
-					/* reference name is after target name, target name is extra */
-					AddExtra (parent, target_list[a]);
+					if (isSealed && target_list[a].Name.Contains ("~")) {
+						// Ignore finalizer differences in sealed classes
+					} else {
+						/* reference name is after target name, target name is extra */
+						AddExtra (parent, target_list[a]);
+					}
+					
 					a++;
 				}
 			}
diff --git a/gui-compare/InfoManager.cs b/gui-compare/InfoManager.cs
index 1f8199d..246b2cd 100644
--- a/gui-compare/InfoManager.cs
+++ b/gui-compare/InfoManager.cs
@@ -205,6 +205,7 @@ namespace GuiCompare
 			"System.AddIn",
 			"System.AddIn.Contract",
 			"System.Configuration",
+			"System.ComponentModel.DataAnnotations",
 			"System.Core", 
 			// "System.Configuration.Install",
 			"System.Data",
@@ -364,12 +365,132 @@ namespace GuiCompare
 			"WindowsBase",
 		//	"XamlBuildTask"
 		};
-		
+
+		string [] api_4_5 = {
+			"mscorlib",
+
+			"System.Activities",			
+			"System.Activities.Core.Presentation",
+			"System.Activities.DurableInstancing",
+			"System.Activities.Design",
+			"System.AddIn.Contract",
+			"System.AddIn",
+			"System.ComponentModel.Composition",
+			"System.ComponentModel.DataAnnotations",
+			"System.configuration",
+		//	"System.Configuration.Install",
+			"System.Core",
+			"System.Data.DataSetExtensions",
+			"System.Data",
+			"System.Data.Entity.Design",
+			"System.Data.Entity",
+			"System.Data.Linq",
+			"System.Data.OracleClient",
+			"System.Data.Services.Client",
+			"System.Data.Services.Design",
+			"System.Data.Services",
+			"System.Data.SqlXml",
+			"System.Deployment",
+			"System.Design",
+			"System.Device",
+		//	"System.DirectoryServices.AccountManagement",
+			"System.DirectoryServices",
+		//	"System.DirectoryServices.Protocols",
+			"System",
+			"System.Drawing.Design",
+			"System.Drawing",
+			"System.Dynamic",
+			"System.EnterpriseServices",
+			"System.EnterpriseServices.Thunk",
+			"System.EnterpriseServices.Wrapper",
+			"System.IdentityModel",
+			"System.IdentityModel.Selectors",
+			"System.IO.Log",
+			"System.IO.Compression",
+			"System.IO.Compression.FileSystem",
+			"System.Management",
+		//	"System.Management.Instrumentation",
+			"System.Messaging",
+			"System.Net",
+			"System.Net.Http",
+			"System.Net.Http.WebRequest",
+			"System.Numerics",
+			"System.Printing",
+			"System.Runtime.Caching",
+			"System.Runtime.Remoting",
+			"System.Runtime.Serialization",
+			"System.Runtime.Serialization.Formatters.Soap",
+			"System.Security",
+			"System.ServiceModel.Activation",
+			"System.ServiceModel.Activities",
+			"System.ServiceModel.Channels",
+			"System.ServiceModel.Discovery",
+			"System.ServiceModel",
+			"System.ServiceModel.Routing",
+			"System.ServiceModel.Web",
+			"System.ServiceProcess",
+			"System.Speech",
+			"System.Threading.Tasks.Dataflow",
+			"System.Transactions",
+			"System.Web.Abstractions",
+			"System.Web.ApplicationServices",
+			"System.Web.DataVisualization.Design",
+			"System.Web.DataVisualization",
+			"System.Web",
+			"System.Web.DynamicData.Design",
+			"System.Web.DynamicData",
+			"System.Web.Entity.Design",
+			"System.Web.Entity",
+		//	"System.Web.Extensions.Design",
+			"System.Web.Extensions",
+		//	"System.Web.Mobile",
+		//	"System.Web.RegularExpressions",
+			"System.Web.Routing",
+			"System.Web.Services",
+			"System.Windows.Forms.DataVisualization.Design",
+			"System.Windows.Forms.DataVisualization",
+			"System.Windows.Forms",
+			"System.Windows.Presentation",
+			"System.Workflow.Activities",
+			"System.Workflow.ComponentModel",
+			"System.Workflow.Runtime",
+			"System.WorkflowServices",
+			"System.Xaml",
+			"System.Xaml.Hosting",
+			"System.Xml",
+			"System.Xml.Linq",
+
+			"Microsoft.Build.Conversion.v4.0",
+			"Microsoft.Build",
+			"Microsoft.Build.Engine",
+			"Microsoft.Build.Framework",
+			"Microsoft.Build.Tasks.v4.0",
+			"Microsoft.Build.Utilities.v4.0",
+			"Microsoft.CSharp",
+			"Microsoft.JScript",
+			"Microsoft.VisualBasic.Compatibility.Data",
+			"Microsoft.VisualBasic.Compatibility",
+			"Microsoft.VisualBasic",
+
+			"PresentationBuildTasks",
+			"PresentationCore",
+			"PresentationFramework.Aero",
+			"PresentationFramework.Classic",
+			"PresentationFramework",
+			"PresentationFramework.Luna",
+			"PresentationFramework.Royale",
+			"PresentationUI",
+			"ReachFramework",
+
+			"WindowsBase",
+		//	"XamlBuildTask"
+		};
+
 		const string masterinfos_version = "2.8";
 
 		static Uri GetMasterInfoUri (string file)
 		{
-			return new Uri (string.Format ("http://mono.ximian.com/masterinfos/{0}/{1}", masterinfos_version, file));
+			return new Uri (string.Format ("http://go-mono.com/masterinfos/{0}/{1}", masterinfos_version, file));
 		}
 		
 		public static void Init ()
@@ -417,9 +538,13 @@ namespace GuiCompare
 				break;
 				
 			case "4.0":
-				u = GetMasterInfoUri ("masterinfos-4.0.tar.gz");			
+				u = GetMasterInfoUri ("masterinfos-4.0.tar.gz");
 				break;
-			
+
+			case "4.5":
+				u = GetMasterInfoUri ("masterinfos-4.5.tar.gz");
+				break;
+
 			case "SL2":
 				u = GetMasterInfoUri ("masterinfos-SL2.tar.gz");
 				break;
@@ -564,6 +689,8 @@ namespace GuiCompare
 					main.Title = String.Format ("{0} to {1}", assemblyfile, masterinfo);
 				});
 			});
+			
+			main.SetComparedProfile (profile);
 		}
 
 		void Populate (Menu container, string caption, string pdir, string collection, string [] elements)
@@ -572,7 +699,7 @@ namespace GuiCompare
 			string MONO_GAC_PREFIX = Environment.GetEnvironmentVariable ("MONO_GAC_PREFIX");
 			string[] gac_prefixes = null;
 
-			if (MONO_GAC_PREFIX != null)
+			if (!string.IsNullOrEmpty (MONO_GAC_PREFIX))
 				gac_prefixes = MONO_GAC_PREFIX.Split (':');
 
 			MenuItem item = new MenuItem (caption);
@@ -671,12 +798,17 @@ namespace GuiCompare
 		// 
 		// Constructor
 		//
-		public InfoManager (MainWindow main)
+		public InfoManager (MainWindow main, string profilePath)
 		{
 			this.main = main;
 			
-			string corlibdir = System.IO.Path.GetDirectoryName (typeof (int).Assembly.Location);
-			monodir = System.IO.Path.GetFullPath (System.IO.Path.Combine (corlibdir, "..")); 
+			if (profilePath == null) {
+				string corlibdir = System.IO.Path.GetDirectoryName (typeof (int).Assembly.Location);
+				monodir = System.IO.Path.GetFullPath (System.IO.Path.Combine (corlibdir, "..")); 
+			} else {
+				monodir = profilePath;
+			}
+			
 			moondir = System.IO.Path.Combine (monodir, @"../moonlight/plugin");
 	
 			// Work around limitation in Stetic, there is no way
@@ -728,14 +860,15 @@ namespace GuiCompare
 			Populate (sub, "API 3.0 sp1", GetVersionPath ("2.0", "net_2_0"), "3.0", api_3_0);
 			Populate (sub, "API 3.5 sp1", GetVersionPath ("2.0", "net_2_0"), "3.5", api_3_5);
 			Populate (sub, "API 4.0", GetVersionPath ("4.0", "net_4_0"), "4.0", api_4_0);
+			Populate (sub, "API 4.5", GetVersionPath ("4.5", "net_4_5"), "4.5", api_4_5);
 //			Populate (sub, "Silverlight 2.0", GetVersionPath ("2.1", "net_2_1"), "SL2", api_sl2);
 //			Populate (sub, "Silverlight 3.0", GetVersionPath ("2.1", "net_2_1"), "SL3", api_sl2);
 			Populate (sub, "Silverlight 4.0", GetVersionPath ("2.1", "net_2_1"), "SL4", api_sl4);
 		}
 		
-		static string GetVersionPath (string version, string profile)
+		string GetVersionPath (string version, string profile)
 		{
-			if (string.IsNullOrEmpty (Environment.GetEnvironmentVariable ("MONO_PATH")))
+			if (!monodir.Contains (Path.Combine ("mcs", "class", "lib")))
 				return version;
 
 			// Developer's version pointing to /mcs/class/lib/<profile>/
diff --git a/gui-compare/Main.cs b/gui-compare/Main.cs
index 49c4617..e522501 100644
--- a/gui-compare/Main.cs
+++ b/gui-compare/Main.cs
@@ -36,7 +36,7 @@ namespace GuiCompare
 		{
 			Application.Init ();
 			
- 			try { 
+ 			try {
 				InfoManager.Init ();
 			} catch (Exception e) {
 				Dialog d = new Dialog ("Error", null, DialogFlags.Modal, new object [] {
@@ -46,7 +46,12 @@ namespace GuiCompare
 				d.Run ();
 				return;
 			}
-			MainWindow win = new MainWindow ();
+			
+			string profile_path = null;
+			if (args.Length != 0 && args[0].StartsWith ("--profile-path="))
+				profile_path = args[0].Substring (15);
+			
+			MainWindow win = new MainWindow (profile_path);
 			win.Show ();
 			if (args.Length == 2 && File.Exists (args [0]) && File.Exists (args [1])){
 				win.ComparePaths (args [0], args [1]);
diff --git a/gui-compare/MainWindow.cs b/gui-compare/MainWindow.cs
index 0da25a4..2792d0d 100644
--- a/gui-compare/MainWindow.cs
+++ b/gui-compare/MainWindow.cs
@@ -38,6 +38,7 @@ public partial class MainWindow: Gtk.Window
 	InfoManager info_manager;
 	Func<CompAssembly> reference_loader, target_loader;
 	CompareContext context;
+	string active_profile;
 
 	static readonly Regex markupRegex = new Regex (@"<(?:[^""']+?|.+?(?:""|').*?(?:""|')?.*?)*?>", RegexOptions.Compiled | RegexOptions.IgnoreCase);
 	static Gdk.Pixbuf classPixbuf, delegatePixbuf, enumPixbuf;
@@ -103,7 +104,7 @@ public partial class MainWindow: Gtk.Window
 		Gdk.Color.Parse ("#000000", ref black);		
 	}
 
-	public MainWindow () : base(Gtk.WindowType.Toplevel)
+	public MainWindow (string profilePath) : base(Gtk.WindowType.Toplevel)
 	{
 		Build ();
 		notebook1.Page = 1;
@@ -113,7 +114,7 @@ public partial class MainWindow: Gtk.Window
 		//
 		// Configure the GUI
 		//
-		info_manager = new InfoManager (this);
+		info_manager = new InfoManager (this, profilePath);
 		
 		treeStore = new Gtk.TreeStore (typeof (string), // Name
 		                               typeof (Gdk.Pixbuf), typeof (Gdk.Pixbuf), // TypeIcon, StatusIcon
@@ -245,7 +246,7 @@ public partial class MainWindow: Gtk.Window
 
 				string msdnUrl = n != null ? n.MSDNUrl : null;
 				if (!String.IsNullOrEmpty (msdnUrl))
-					Status = msdnUrl;
+					Status = GetMSDNVersionedUrl (msdnUrl);
 				else
 					Status = String.Empty;
 			}
@@ -261,7 +262,7 @@ public partial class MainWindow: Gtk.Window
 				return;
 
 			System.Diagnostics.Process browser = new System.Diagnostics.Process ();
-			browser.StartInfo.FileName = n.MSDNUrl;
+			browser.StartInfo.FileName = GetMSDNVersionedUrl (n.MSDNUrl);
 			browser.StartInfo.UseShellExecute = true;
 			browser.Start ();
 		};
@@ -361,6 +362,22 @@ public partial class MainWindow: Gtk.Window
 		tag.Underline = Pango.Underline.Single;
 		buffer.TagTable.Add (tag);
 	}
+	
+	string GetMSDNVersionedUrl (string url)
+	{
+		switch (active_profile) {
+			case "2.0":
+				return url.Replace (".aspx", "(v=VS.80).aspx");
+			case "3.0":
+				return url.Replace (".aspx", "(v=VS.90).aspx");
+			case "4.0":
+				return url.Replace (".aspx", "(v=VS.100).aspx");
+			case "4.5":
+				return url.Replace (".aspx", "(v=VS.110).aspx");
+			default:
+				return url;
+		}
+	}
 
 	void InsertWithMarkup (TextBuffer buffer, ref TextIter iter, string text)
 	{
@@ -509,6 +526,11 @@ public partial class MainWindow: Gtk.Window
 			SetTarget (delegate { return new CecilAssembly (cd.TargetPath); });
 	}
 	
+	public void SetComparedProfile (string profile)
+	{
+		active_profile = profile;
+	}
+	
 	public void StartCompare (WaitCallback done)
 	{		
 		AdditionalInfoWindow.Visible = false;
diff --git a/gui-compare/Makefile.am b/gui-compare/Makefile.am
index ef805eb..59829b2 100644
--- a/gui-compare/Makefile.am
+++ b/gui-compare/Makefile.am
@@ -56,4 +56,4 @@ assemblies = -r:System -r:System.Core -r:Mono.Posix -r:System.Xml
 ress= $(foreach res,$(gui_compare_resources), $(addprefix -resource:,$(res)),$(notdir $(res)))
 
 gui-compare.exe: $(gui_compare_sources) $(gui_compare_resources)
-	$(GMCS) -noconfig -codepage:utf8 -warn:4 -optimize+ -debug -define:DEBUG -target:exe -out:gui-compare.exe $(gui_compare_sources) $(ress) $(packages) $(assemblies)
+	$(DMCS) -noconfig -codepage:utf8 -warn:4 -optimize+ -debug -define:DEBUG -target:exe -out:gui-compare.exe $(gui_compare_sources) $(ress) $(packages) $(assemblies)
diff --git a/gui-compare/MasterMetadata.cs b/gui-compare/MasterMetadata.cs
index f25468e..189b42c 100644
--- a/gui-compare/MasterMetadata.cs
+++ b/gui-compare/MasterMetadata.cs
@@ -841,6 +841,9 @@ namespace GuiCompare {
 			if (props.Count == 0)
 				return;
 
+			foreach (var entry in props)
+				Properties.Add (entry.Key, entry.Value);
+
 			if (name == "System.Runtime.CompilerServices.TypeForwardedToAttribute") {
 				string dest;
 				if (props.TryGetValue ("Destination", out dest) && !String.IsNullOrEmpty (dest))
diff --git a/gui-compare/Masterinfo.cs b/gui-compare/Masterinfo.cs
index b91f99b..bc13a63 100644
--- a/gui-compare/Masterinfo.cs
+++ b/gui-compare/Masterinfo.cs
@@ -205,8 +205,13 @@ namespace GuiCompare {
 				string name = n.Attributes ["name"].Value;
 				if (CheckIfAdd (name, n)) {
 					string key = GetNodeKey (name, n);
-					//keys.Add (key, name);
-					keys [key] = name;
+					if (keys.Contains (key)) {
+						if ((string) keys[key] != name)
+							throw new NotImplementedException ("Attribute with same name but diffent value");
+					} else {
+						keys.Add (key, name);
+					}
+					
 					LoadExtraData (key, n);
 				}
 			}
@@ -532,24 +537,10 @@ namespace GuiCompare {
 
 	public class XMLAttributeProperties: XMLNameGroup
 	{
-		static Dictionary <string, string> ignored_properties;
 		SortedDictionary <string, string> properties;
 
 		static XMLAttributeProperties ()
 		{
-
-			ignored_properties = new Dictionary <string, string> ();
-			ignored_properties.Add ("System.Reflection.AssemblyKeyFileAttribute", "KeyFile");
-			ignored_properties.Add ("System.Reflection.AssemblyCompanyAttribute", "Company");
-			ignored_properties.Add ("System.Reflection.AssemblyConfigurationAttribute", "Configuration");
-			ignored_properties.Add ("System.Reflection.AssemblyCopyrightAttribute", "Copyright");
-			ignored_properties.Add ("System.Reflection.AssemblyProductAttribute", "Product");
-			ignored_properties.Add ("System.Reflection.AssemblyTrademarkAttribute", "Trademark");
-			ignored_properties.Add ("System.Reflection.AssemblyInformationalVersionAttribute", "InformationalVersion");
-
-			ignored_properties.Add ("System.ObsoleteAttribute", "Message");
-			ignored_properties.Add ("System.IO.IODescriptionAttribute", "Description");
-			ignored_properties.Add ("System.Diagnostics.MonitoringDescriptionAttribute", "Description");
 		}
 
 		string attribute;
@@ -571,15 +562,9 @@ namespace GuiCompare {
 			if (node.ChildNodes == null)
 				return;
 
-			string ignored;
-
-			if (!ignored_properties.TryGetValue (attribute, out ignored))
-				ignored = null;
 
 			foreach (XmlNode n in node.ChildNodes) {
 				string name = n.Attributes["name"].Value;
-				if (ignored != null && ignored == name)
-					continue;
 
 				if (n.Attributes["null"] != null) {
 					Properties.Add (name, null);
@@ -1045,9 +1030,11 @@ namespace GuiCompare {
 
 		public override string GetNodeKey (string name, XmlNode node)
 		{
-			if (genericParameters != null)
-				name = name + ":" + genericParameters.Count;
-
+			XmlNode genericNode = node.SelectSingleNode ("generic-parameters");
+			if (genericNode != null) {
+				name = name + "`" + genericNode.ChildNodes.Count;
+			}
+			
 			// for explicit/implicit operators we need to include the return
 			// type in the key to allow matching; as a side-effect, differences
 			// in return types will be reported as extra/missing methods
diff --git a/gui-compare/Metadata.cs b/gui-compare/Metadata.cs
index f365f7c..a04f39e 100644
--- a/gui-compare/Metadata.cs
+++ b/gui-compare/Metadata.cs
@@ -69,6 +69,8 @@ namespace GuiCompare {
 
 	public interface ICompMemberContainer
 	{
+		bool IsSealed { get; }
+
 		List<CompNamed> GetInterfaces ();
 		List<CompNamed> GetConstructors();
 		List<CompNamed> GetMethods();
@@ -130,27 +132,33 @@ namespace GuiCompare {
 
 		public static int Compare (CompNamed x, CompNamed y)
 		{
-			int res = string.Compare (x.Name, y.Name);
-			if (res != 0)
-				return res;
-
 			var x_g = x as CompMethod;
 			var y_g = y as CompMethod;
+			
 			if (x_g == null || y_g == null)
-				return res;
+				return string.Compare (x.Name, y.Name);
 
 			var x_tp = x_g.GetTypeParameters ();
+			if (x_tp != null && x_tp.Count == 0)
+				x_tp = null;
+			
 			var y_tp = y_g.GetTypeParameters ();
+			if (y_tp != null && y_tp.Count == 0)
+				y_tp = null;
+			
 			if (x_tp == null && y_tp != null)
 				return -1;
 
 			if (x_tp != null && y_tp == null)
 				return 1;
 
-			if (x_tp == null && y_tp == null)
-				return res;
-
-			return x_tp.Count.CompareTo (y_tp.Count);
+			if (x_tp != null && y_tp != null) {
+				var res = x_tp.Count.CompareTo (y_tp.Count);
+				if (res != 0)
+					return res;
+			}
+			
+			return string.Compare (x.Name, y.Name);
 		}
 
 		string displayName;
@@ -338,7 +346,10 @@ namespace GuiCompare {
 		public CompAttribute (string typename)
 			: base (typename, CompType.Attribute)
 		{
+			Properties = new SortedDictionary<string, string> ();
 		}
+
+		public IDictionary<string, string> Properties { get; private set;  }
 	}
 	
 	public abstract class CompGenericParameter : CompNamed, ICompAttributeContainer {
diff --git a/gui-compare/gtk-gui/GuiCompare.CustomCompare.cs b/gui-compare/gtk-gui/GuiCompare.CustomCompare.cs
index 7ca40c7..a027fb2 100644
--- a/gui-compare/gtk-gui/GuiCompare.CustomCompare.cs
+++ b/gui-compare/gtk-gui/GuiCompare.CustomCompare.cs
@@ -5,17 +5,27 @@ namespace GuiCompare
 	public partial class CustomCompare
 	{
 		private global::Gtk.HBox hbox1;
+		
 		private global::Gtk.Frame frame1;
+		
 		private global::Gtk.Alignment GtkAlignment2;
+		
 		private global::guicompare.ProviderSelector reference;
+		
 		private global::Gtk.Label GtkLabel4;
+		
 		private global::Gtk.Frame frame2;
+		
 		private global::Gtk.Alignment GtkAlignment3;
+		
 		private global::guicompare.ProviderSelector target;
+		
 		private global::Gtk.Label GtkLabel9;
+		
 		private global::Gtk.Button buttonCancel;
+		
 		private global::Gtk.Button buttonOk;
-
+		
 		protected virtual void Build ()
 		{
 			global::Stetic.Gui.Initialize (this);
@@ -40,7 +50,9 @@ namespace GuiCompare
 			this.GtkAlignment2.Name = "GtkAlignment2";
 			this.GtkAlignment2.LeftPadding = ((uint)(12));
 			// Container child GtkAlignment2.Gtk.Container+ContainerChild
-			this.reference = null;
+			this.reference = new guicompare.ProviderSelector();
+			this.reference.Events = ((Gdk.EventMask)(256));
+			this.reference.Name = "reference";
 			this.GtkAlignment2.Add (this.reference);
 			this.frame1.Add (this.GtkAlignment2);
 			this.GtkLabel4 = new global::Gtk.Label ();
@@ -61,7 +73,9 @@ namespace GuiCompare
 			this.GtkAlignment3.Name = "GtkAlignment3";
 			this.GtkAlignment3.LeftPadding = ((uint)(12));
 			// Container child GtkAlignment3.Gtk.Container+ContainerChild
-			this.target = null;
+			this.target = new guicompare.ProviderSelector();
+			this.target.Events = ((Gdk.EventMask)(256));
+			this.target.Name = "target";
 			this.GtkAlignment3.Add (this.target);
 			this.frame2.Add (this.GtkAlignment3);
 			this.GtkLabel9 = new global::Gtk.Label ();
diff --git a/gui-compare/gtk-gui/MainWindow.cs b/gui-compare/gtk-gui/MainWindow.cs
index 6e2d738..addb7cd 100644
--- a/gui-compare/gtk-gui/MainWindow.cs
+++ b/gui-compare/gtk-gui/MainWindow.cs
@@ -4,53 +4,99 @@
 public partial class MainWindow
 {
 	private global::Gtk.UIManager UIManager;
+	
 	private global::Gtk.Action File;
+	
 	private global::Gtk.Action quit;
+	
 	private global::Gtk.Action Compare;
+	
 	private global::Gtk.Action Custom;
+	
 	private global::Gtk.Action a;
+	
 	private global::Gtk.Action b;
+	
 	private global::Gtk.Action View;
+	
 	private global::Gtk.ToggleAction ShowMissing;
+	
 	private global::Gtk.ToggleAction ShowExtra;
+	
 	private global::Gtk.ToggleAction ShowPresent;
+	
 	private global::Gtk.ToggleAction ShowErrors;
+	
 	private global::Gtk.Action Refresh;
+	
 	private global::Gtk.ToggleAction ShowTodo;
+	
 	private global::Gtk.Action RecentComparisonsAction;
+	
 	private global::Gtk.ToggleAction ShowNotImplemented;
+	
 	private global::Gtk.Action ToggleRowExpansionAction;
+	
 	private global::Gtk.VBox vbox1;
+	
 	private global::Gtk.MenuBar menubar1;
+	
 	private global::Gtk.Notebook notebook1;
+	
 	private global::Gtk.ScrolledWindow GtkScrolledWindow;
+	
 	private global::Gtk.TreeView tree;
+	
 	private global::Gtk.Label label1;
+	
 	private global::Gtk.Label label3;
+	
 	private global::Gtk.Label label2;
+	
 	private global::Gtk.ScrolledWindow AdditionalInfoWindow;
+	
 	private global::Gtk.TextView AdditionalInfoText;
+	
 	private global::Gtk.Expander expander1;
+	
 	private global::Gtk.Table table1;
+	
 	private global::Gtk.Label label4;
+	
 	private global::Gtk.Label label5;
+	
 	private global::Gtk.Label label6;
+	
 	private global::Gtk.Label label7;
+	
 	private global::Gtk.Label label8;
+	
 	private global::Gtk.Label label9;
+	
 	private global::Gtk.Image legendImageError;
+	
 	private global::Gtk.Image legendImageExtra;
+	
 	private global::Gtk.Image legendImageMissing;
+	
 	private global::Gtk.Image legendImageNIEX;
+	
 	private global::Gtk.Image legendImageOK;
+	
 	private global::Gtk.Image legendImageTODO;
+	
 	private global::Gtk.VSeparator vseparator1;
+	
 	private global::Gtk.VSeparator vseparator2;
+	
 	private global::Gtk.VSeparator vseparator3;
+	
 	private global::Gtk.Label GtkLabel4;
+	
 	private global::Gtk.Statusbar statusbar1;
+	
 	private global::Gtk.ProgressBar progressbar1;
-
+	
 	protected virtual void Build ()
 	{
 		global::Stetic.Gui.Initialize (this);
diff --git a/gui-compare/gtk-gui/generated.cs b/gui-compare/gtk-gui/generated.cs
index 75935e2..71410df 100644
--- a/gui-compare/gtk-gui/generated.cs
+++ b/gui-compare/gtk-gui/generated.cs
@@ -5,7 +5,7 @@ namespace Stetic
 	internal class Gui
 	{
 		private static bool initialized;
-
+		
 		internal static void Initialize (Gtk.Widget iconRenderer)
 		{
 			if ((Stetic.Gui.initialized == false)) {
@@ -13,12 +13,13 @@ namespace Stetic
 			}
 		}
 	}
-
+	
 	internal class BinContainer
 	{
 		private Gtk.Widget child;
+		
 		private Gtk.UIManager uimanager;
-
+		
 		public static BinContainer Attach (Gtk.Bin bin)
 		{
 			BinContainer bc = new BinContainer ();
@@ -27,32 +28,32 @@ namespace Stetic
 			bin.Added += new Gtk.AddedHandler (bc.OnAdded);
 			return bc;
 		}
-
+		
 		private void OnSizeRequested (object sender, Gtk.SizeRequestedArgs args)
 		{
 			if ((this.child != null)) {
 				args.Requisition = this.child.SizeRequest ();
 			}
 		}
-
+		
 		private void OnSizeAllocated (object sender, Gtk.SizeAllocatedArgs args)
 		{
 			if ((this.child != null)) {
 				this.child.Allocation = args.Allocation;
 			}
 		}
-
+		
 		private void OnAdded (object sender, Gtk.AddedArgs args)
 		{
 			this.child = args.Widget;
 		}
-
+		
 		public void SetUiManager (Gtk.UIManager uim)
 		{
 			this.uimanager = uim;
 			this.child.Realized += new System.EventHandler (this.OnRealized);
 		}
-
+		
 		private void OnRealized (object sender, System.EventArgs args)
 		{
 			if ((this.uimanager != null)) {
@@ -65,14 +66,14 @@ namespace Stetic
 			}
 		}
 	}
-
+	
 	internal class ActionGroups
 	{
 		public static Gtk.ActionGroup GetActionGroup (System.Type type)
 		{
 			return Stetic.ActionGroups.GetActionGroup (type.FullName);
 		}
-
+		
 		public static Gtk.ActionGroup GetActionGroup (string name)
 		{
 			return null;
diff --git a/gui-compare/gtk-gui/gui.stetic b/gui-compare/gtk-gui/gui.stetic
index ce143e5..da239dc 100644
--- a/gui-compare/gtk-gui/gui.stetic
+++ b/gui-compare/gtk-gui/gui.stetic
@@ -1,8 +1,8 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
 <stetic-interface>
   <configuration>
-    <images-root-path>..</images-root-path>
-    <target-gtk-version>2.10</target-gtk-version>
+    <images-root-path>../../gui-compare</images-root-path>
+    <target-gtk-version>2.12</target-gtk-version>
   </configuration>
   <import>
     <widget-library name="glade-sharp, Version=2.12.0.0, Culture=neutral, PublicKeyToken=35e10195dab3c99f" />
diff --git a/gui-compare/gtk-gui/guicompare.ProviderSelector.cs b/gui-compare/gtk-gui/guicompare.ProviderSelector.cs
index dbc910a..32b051f 100644
--- a/gui-compare/gtk-gui/guicompare.ProviderSelector.cs
+++ b/gui-compare/gtk-gui/guicompare.ProviderSelector.cs
@@ -5,12 +5,17 @@ namespace guicompare
 	public partial class ProviderSelector
 	{
 		private global::Gtk.Table table2;
+		
 		private global::Gtk.FileChooserButton filechooserbutton1;
+		
 		private global::Gtk.FileChooserButton filechooserbutton2;
+		
 		private global::Gtk.Label label2;
+		
 		private global::Gtk.RadioButton radiobutton1;
+		
 		private global::Gtk.RadioButton radiobutton2;
-
+		
 		protected virtual void Build ()
 		{
 			global::Stetic.Gui.Initialize (this);
diff --git a/gui-compare/gui-compare.csproj b/gui-compare/gui-compare.csproj
new file mode 100644
index 0000000..33408f6
--- /dev/null
+++ b/gui-compare/gui-compare.csproj
@@ -0,0 +1,142 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+    <Platform Condition=" '$(Platform)' == '' ">x86</Platform>
+    <ProductVersion>10.0.0</ProductVersion>
+    <SchemaVersion>2.0</SchemaVersion>
+    <ProjectGuid>{CB1CD99D-21A1-4C8B-BC71-C5B384EB50E7}</ProjectGuid>
+    <OutputType>WinExe</OutputType>
+    <RootNamespace>guicompare</RootNamespace>
+    <AssemblyName>gui-compare</AssemblyName>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|x86' ">
+    <DebugSymbols>true</DebugSymbols>
+    <DebugType>full</DebugType>
+    <Optimize>false</Optimize>
+    <OutputPath>bin\Debug</OutputPath>
+    <DefineConstants>DEBUG;</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+    <ConsolePause>false</ConsolePause>
+    <PlatformTarget>x86</PlatformTarget>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|x86' ">
+    <DebugType>none</DebugType>
+    <Optimize>true</Optimize>
+    <OutputPath>bin\Release</OutputPath>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+    <ConsolePause>false</ConsolePause>
+    <PlatformTarget>x86</PlatformTarget>
+  </PropertyGroup>
+  <ItemGroup>
+    <Reference Include="System" />
+    <Reference Include="Mono.Posix" />
+    <Reference Include="gtk-sharp, Version=2.12.0.0, Culture=neutral, PublicKeyToken=35e10195dab3c99f" />
+    <Reference Include="gdk-sharp, Version=2.12.0.0, Culture=neutral, PublicKeyToken=35e10195dab3c99f" />
+    <Reference Include="glib-sharp, Version=2.12.0.0, Culture=neutral, PublicKeyToken=35e10195dab3c99f" />
+    <Reference Include="glade-sharp, Version=2.12.0.0, Culture=neutral, PublicKeyToken=35e10195dab3c99f" />
+    <Reference Include="pango-sharp, Version=2.12.0.0, Culture=neutral, PublicKeyToken=35e10195dab3c99f" />
+    <Reference Include="atk-sharp, Version=2.12.0.0, Culture=neutral, PublicKeyToken=35e10195dab3c99f" />
+    <Reference Include="System.Xml" />
+    <Reference Include="System.Core" />
+    <Reference Include="Mono.Cecil, Version=0.9.5.0, Culture=neutral, PublicKeyToken=0738eb9f132ed756">
+      <Private>False</Private>
+    </Reference>
+  </ItemGroup>
+  <ItemGroup>
+    <EmbeddedResource Include="gtk-gui\gui.stetic">
+      <LogicalName>gui.stetic</LogicalName>
+    </EmbeddedResource>
+    <EmbeddedResource Include="cm\d.gif">
+      <LogicalName>d.gif</LogicalName>
+    </EmbeddedResource>
+    <EmbeddedResource Include="cm\e.gif">
+      <LogicalName>e.gif</LogicalName>
+    </EmbeddedResource>
+    <EmbeddedResource Include="cm\en.gif">
+      <LogicalName>en.gif</LogicalName>
+    </EmbeddedResource>
+    <EmbeddedResource Include="cm\f.gif">
+      <LogicalName>f.gif</LogicalName>
+    </EmbeddedResource>
+    <EmbeddedResource Include="cm\i.gif">
+      <LogicalName>i.gif</LogicalName>
+    </EmbeddedResource>
+    <EmbeddedResource Include="cm\m.gif">
+      <LogicalName>m.gif</LogicalName>
+    </EmbeddedResource>
+    <EmbeddedResource Include="cm\mn.png">
+      <LogicalName>mn.png</LogicalName>
+    </EmbeddedResource>
+    <EmbeddedResource Include="cm\n.gif">
+      <LogicalName>n.gif</LogicalName>
+    </EmbeddedResource>
+    <EmbeddedResource Include="cm\p.gif">
+      <LogicalName>p.gif</LogicalName>
+    </EmbeddedResource>
+    <EmbeddedResource Include="cm\r.gif">
+      <LogicalName>r.gif</LogicalName>
+    </EmbeddedResource>
+    <EmbeddedResource Include="cm\s.gif">
+      <LogicalName>s.gif</LogicalName>
+    </EmbeddedResource>
+    <EmbeddedResource Include="cm\sc.gif">
+      <LogicalName>sc.gif</LogicalName>
+    </EmbeddedResource>
+    <EmbeddedResource Include="cm\se.gif">
+      <LogicalName>se.gif</LogicalName>
+    </EmbeddedResource>
+    <EmbeddedResource Include="cm\sm.gif">
+      <LogicalName>sm.gif</LogicalName>
+    </EmbeddedResource>
+    <EmbeddedResource Include="cm\st.gif">
+      <LogicalName>st.gif</LogicalName>
+    </EmbeddedResource>
+    <EmbeddedResource Include="cm\sx.gif">
+      <LogicalName>sx.gif</LogicalName>
+    </EmbeddedResource>
+    <EmbeddedResource Include="cm\tb.gif">
+      <LogicalName>tb.gif</LogicalName>
+    </EmbeddedResource>
+    <EmbeddedResource Include="cm\tm.gif">
+      <LogicalName>tm.gif</LogicalName>
+    </EmbeddedResource>
+    <EmbeddedResource Include="cm\tp.gif">
+      <LogicalName>tp.gif</LogicalName>
+    </EmbeddedResource>
+    <EmbeddedResource Include="cm\w.gif">
+      <LogicalName>w.gif</LogicalName>
+    </EmbeddedResource>
+    <EmbeddedResource Include="cm\y.gif">
+      <LogicalName>y.gif</LogicalName>
+    </EmbeddedResource>
+    <EmbeddedResource Include="cm\c.gif">
+      <LogicalName>c.gif</LogicalName>
+    </EmbeddedResource>
+  </ItemGroup>
+  <ItemGroup>
+    <Compile Include="gtk-gui\generated.cs" />
+    <Compile Include="MainWindow.cs" />
+    <Compile Include="gtk-gui\MainWindow.cs" />
+    <Compile Include="Main.cs" />
+    <Compile Include="AssemblyInfo.cs" />
+    <Compile Include="gtk-gui\guicompare.ProviderSelector.cs" />
+    <Compile Include="gtk-gui\GuiCompare.CustomCompare.cs" />
+    <Compile Include="CecilMetadata.cs" />
+    <Compile Include="CompareContext.cs" />
+    <Compile Include="Comparison.cs" />
+    <Compile Include="CustomCompare.cs" />
+    <Compile Include="InfoManager.cs" />
+    <Compile Include="Masterinfo.cs" />
+    <Compile Include="MasterMetadata.cs" />
+    <Compile Include="Metadata.cs" />
+    <Compile Include="ProviderSelector.cs" />
+    <Compile Include="Config.cs" />
+  </ItemGroup>
+  <Import Project="$(MSBuildBinPath)\Microsoft.CSharp.targets" />
+  <ItemGroup>
+    <Folder Include="cm\" />
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/gui-compare/gui-compare.in b/gui-compare/gui-compare.in
index 456a9fa..aa39b8f 100644
--- a/gui-compare/gui-compare.in
+++ b/gui-compare/gui-compare.in
@@ -1,3 +1,5 @@
 #!/bin/sh
 
+export DYLD_FALLBACK_LIBRARY_PATH=/Library/Frameworks/Mono.framework/Versions/Current/lib:/usr/lib 
+
 exec mono $MONO_OPTIONS "@prefix@/lib/gui-compare/gui-compare.exe" "$@"
